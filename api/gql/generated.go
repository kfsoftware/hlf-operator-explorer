// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/kfsoftware/hlf-operator-ui/api/gql/models"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	CA() CAResolver
	Channel() ChannelResolver
	Mutation() MutationResolver
	Orderer() OrdererResolver
	Peer() PeerResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	RequiresAuth func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	ApplicationConfig struct {
		Acls          func(childComplexity int) int
		Capabilities  func(childComplexity int) int
		Organizations func(childComplexity int) int
		Policies      func(childComplexity int) int
	}

	ApplicationPolicy struct {
		ChannelConfigPolicy func(childComplexity int) int
		SignaturePolicy     func(childComplexity int) int
	}

	Block struct {
		BlockNumber     func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		DataHash        func(childComplexity int) int
		NumTransactions func(childComplexity int) int
		Transactions    func(childComplexity int) int
	}

	BlockWithPrivateData struct {
		BlockNumber     func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		DataHash        func(childComplexity int) int
		NumTransactions func(childComplexity int) int
		Transactions    func(childComplexity int) int
	}

	BlocksResponse struct {
		Blocks func(childComplexity int) int
		Height func(childComplexity int) int
	}

	CA struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
		Storage   func(childComplexity int) int
		Yaml      func(childComplexity int) int
	}

	CAStorage struct {
		Ca func(childComplexity int) int
	}

	ChaincodeApproval struct {
		Approved func(childComplexity int) int
		MspID    func(childComplexity int) int
	}

	Channel struct {
		Application   func(childComplexity int) int
		Chaincodes    func(childComplexity int) int
		ChannelConfig func(childComplexity int) int
		Height        func(childComplexity int) int
		Name          func(childComplexity int) int
		Orderer       func(childComplexity int) int
		Peers         func(childComplexity int) int
		ProtoConfig   func(childComplexity int) int
		RawConfig     func(childComplexity int) int
	}

	ChannelACL struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ChannelAnchorPeer struct {
		Host  func(childComplexity int) int
		MspID func(childComplexity int) int
		Port  func(childComplexity int) int
	}

	ChannelChaincode struct {
		Approvals              func(childComplexity int) int
		ConfigPolicy           func(childComplexity int) int
		EndorsementPlugin      func(childComplexity int) int
		Name                   func(childComplexity int) int
		PrivateDataCollections func(childComplexity int) int
		Sequence               func(childComplexity int) int
		SignaturePolicy        func(childComplexity int) int
		ValidationPlugin       func(childComplexity int) int
		Version                func(childComplexity int) int
	}

	ChannelConfig struct {
		Capabilities func(childComplexity int) int
		Policies     func(childComplexity int) int
	}

	ChannelMSP struct {
		Admins               func(childComplexity int) int
		IntermediateCerts    func(childComplexity int) int
		Name                 func(childComplexity int) int
		RevocationList       func(childComplexity int) int
		RootCerts            func(childComplexity int) int
		TLSIntermediateCerts func(childComplexity int) int
		TLSRootCerts         func(childComplexity int) int
	}

	ChannelOrg struct {
		AnchorPeer       func(childComplexity int) int
		CryptoConfig     func(childComplexity int) int
		ModPolicy        func(childComplexity int) int
		Msp              func(childComplexity int) int
		MspID            func(childComplexity int) int
		NodeOUs          func(childComplexity int) int
		OrdererEndpoints func(childComplexity int) int
		Ous              func(childComplexity int) int
		Policies         func(childComplexity int) int
	}

	ChannelPeer struct {
		Height func(childComplexity int) int
		MspID  func(childComplexity int) int
		URL    func(childComplexity int) int
	}

	ChannelPolicy struct {
		Key       func(childComplexity int) int
		ModPolicy func(childComplexity int) int
		Rule      func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	CryptoConfig struct {
		IdentityIdentifierHashFunction func(childComplexity int) int
		SignatureHashFamily            func(childComplexity int) int
	}

	Error struct {
		Message func(childComplexity int) int
	}

	GetUpdateChannelBlockResponse struct {
		Block        func(childComplexity int) int
		ConfigUpdate func(childComplexity int) int
		Errors       func(childComplexity int) int
	}

	LightChannel struct {
		Name func(childComplexity int) int
	}

	MSPPrincipal struct {
		Combined func(childComplexity int) int
		Role     func(childComplexity int) int
	}

	MSPPrincipalCombined struct {
		Classification func(childComplexity int) int
		MspPrincipals  func(childComplexity int) int
	}

	MSPPrincipalRole struct {
		MspID func(childComplexity int) int
		Role  func(childComplexity int) int
	}

	Mutation struct {
		CreateCa                 func(childComplexity int, input models.CreateCAInput) int
		CreateOrderer            func(childComplexity int, input models.CreateOrdererInput) int
		CreatePeer               func(childComplexity int, input models.CreatePeerInput) int
		GetUpdateChannelBlock    func(childComplexity int, input models.GetUpdateChannelBlockInput) int
		RenewOrdererCertificates func(childComplexity int, input models.RenewOrdererCertificatesInput) int
		RenewPeerCertificates    func(childComplexity int, input models.RenewPeerCertificatesInput) int
		UpdateCa                 func(childComplexity int, filter models.NameAndNamespace, input models.UpdateCAInput) int
		UpdateChannel            func(childComplexity int, input models.UpdateChannelInput) int
		UpdateOrderer            func(childComplexity int, filter models.NameAndNamespace, input models.UpdateeOrdererInput) int
		UpdatePeer               func(childComplexity int, filter models.NameAndNamespace, input models.UpdateePeerInput) int
	}

	Namespace struct {
		Name func(childComplexity int) int
	}

	NetworkAddress struct {
		Host func(childComplexity int) int
		Port func(childComplexity int) int
	}

	NodeOUs struct {
		AdminOUIdentifier   func(childComplexity int) int
		ClientOUIdentifier  func(childComplexity int) int
		Enable              func(childComplexity int) int
		OrdererOUIdentifier func(childComplexity int) int
		PeerOUIdentifier    func(childComplexity int) int
	}

	OUIdentifier struct {
		Certificate  func(childComplexity int) int
		OuIdentifier func(childComplexity int) int
	}

	Orderer struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
		Storage   func(childComplexity int) int
		Yaml      func(childComplexity int) int
	}

	OrdererConfig struct {
		BatchSize     func(childComplexity int) int
		BatchTimeout  func(childComplexity int) int
		Capabilities  func(childComplexity int) int
		EtcdDraft     func(childComplexity int) int
		MaxChannels   func(childComplexity int) int
		Organizations func(childComplexity int) int
		Policies      func(childComplexity int) int
		State         func(childComplexity int) int
		Type          func(childComplexity int) int
	}

	OrdererConfigBatchSize struct {
		AbsoluteMaxBytes  func(childComplexity int) int
		MaxMessageCount   func(childComplexity int) int
		PreferredMaxBytes func(childComplexity int) int
	}

	OrdererConfigRaft struct {
		Consenters func(childComplexity int) int
		Options    func(childComplexity int) int
	}

	OrdererConfigRaftConsenter struct {
		Address       func(childComplexity int) int
		ClientTLSCert func(childComplexity int) int
		ServerTLSCert func(childComplexity int) int
	}

	OrdererConfigRaftOptions struct {
		ElectionTick         func(childComplexity int) int
		HeartbeatTick        func(childComplexity int) int
		MaxInflightBlocks    func(childComplexity int) int
		SnapshotIntervalSize func(childComplexity int) int
		TickInterval         func(childComplexity int) int
	}

	OrdererStorage struct {
		Orderer func(childComplexity int) int
	}

	PDCRead struct {
		Block          func(childComplexity int) int
		CollectionName func(childComplexity int) int
		Key            func(childComplexity int) int
		TxNum          func(childComplexity int) int
	}

	PDCReadHash struct {
		KeyHash   func(childComplexity int) int
		PdcName   func(childComplexity int) int
		RwSetHash func(childComplexity int) int
		Version   func(childComplexity int) int
	}

	PDCReadVersion struct {
		BlockNum func(childComplexity int) int
		TxNum    func(childComplexity int) int
	}

	PDCWrite struct {
		CollectionName func(childComplexity int) int
		Deleted        func(childComplexity int) int
		Key            func(childComplexity int) int
		Value          func(childComplexity int) int
	}

	PDCWriteHash struct {
		IsDelete  func(childComplexity int) int
		IsPurge   func(childComplexity int) int
		KeyHash   func(childComplexity int) int
		PdcName   func(childComplexity int) int
		RwSetHash func(childComplexity int) int
		ValueHash func(childComplexity int) int
	}

	Peer struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
		Storage   func(childComplexity int) int
		Yaml      func(childComplexity int) int
	}

	PeerStorage struct {
		Chaincode func(childComplexity int) int
		CouchDb   func(childComplexity int) int
		Peer      func(childComplexity int) int
	}

	PrivateDataCollection struct {
		BlockToLive       func(childComplexity int) int
		EndorsementPolicy func(childComplexity int) int
		MaxPeerCount      func(childComplexity int) int
		MemberOnlyRead    func(childComplexity int) int
		MemberOnlyWrite   func(childComplexity int) int
		MemberOrgsPolicy  func(childComplexity int) int
		Name              func(childComplexity int) int
		RequiredPeerCount func(childComplexity int) int
	}

	Query struct {
		Block                func(childComplexity int, channelID string, blockNumber int) int
		BlockByTxid          func(childComplexity int, channelID string, transactionID string) int
		BlockWithPrivateData func(childComplexity int, channelID string, blockNumber int) int
		Blocks               func(childComplexity int, channelID string, from int, to int, reverse bool) int
		Ca                   func(childComplexity int, input models.NameAndNamespace) int
		Cas                  func(childComplexity int) int
		Channel              func(childComplexity int, channelID string) int
		Channels             func(childComplexity int) int
		Namespaces           func(childComplexity int) int
		NetworkConfigEnabled func(childComplexity int) int
		Orderer              func(childComplexity int, input models.NameAndNamespace) int
		Orderers             func(childComplexity int) int
		Peer                 func(childComplexity int, input models.NameAndNamespace) int
		Peers                func(childComplexity int) int
		StorageClasses       func(childComplexity int) int
	}

	RenewOrdererCertificatesResponse struct {
		Errors  func(childComplexity int) int
		Orderer func(childComplexity int) int
	}

	RenewPeerCertificatesResponse struct {
		Errors func(childComplexity int) int
		Peer   func(childComplexity int) int
	}

	SignaturePolicy struct {
		Principals func(childComplexity int) int
		Rule       func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	SignaturePolicyNOutOf struct {
		N     func(childComplexity int) int
		Rules func(childComplexity int) int
	}

	SignaturePolicyRule struct {
		NoutOf   func(childComplexity int) int
		SignedBy func(childComplexity int) int
		Type     func(childComplexity int) int
	}

	SignaturePolicySignedBy struct {
		SignedBy func(childComplexity int) int
	}

	StorageClass struct {
		Name func(childComplexity int) int
	}

	StorageUsage struct {
		Free           func(childComplexity int) int
		FreeGb         func(childComplexity int) int
		PercentageUsed func(childComplexity int) int
		Size           func(childComplexity int) int
		SizeGb         func(childComplexity int) int
		Used           func(childComplexity int) int
		UsedGb         func(childComplexity int) int
	}

	Transaction struct {
		Chaincode func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		Path      func(childComplexity int) int
		Reads     func(childComplexity int) int
		Request   func(childComplexity int) int
		Response  func(childComplexity int) int
		TxID      func(childComplexity int) int
		Type      func(childComplexity int) int
		Version   func(childComplexity int) int
		Writes    func(childComplexity int) int
	}

	TransactionRead struct {
		BlockNumVersion func(childComplexity int) int
		ChaincodeID     func(childComplexity int) int
		Key             func(childComplexity int) int
		TxNumVersion    func(childComplexity int) int
	}

	TransactionWithPrivateData struct {
		Chaincode      func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Path           func(childComplexity int) int
		PdcReadHashes  func(childComplexity int) int
		PdcReads       func(childComplexity int) int
		PdcWriteHashes func(childComplexity int) int
		PdcWrites      func(childComplexity int) int
		Reads          func(childComplexity int) int
		Request        func(childComplexity int) int
		Response       func(childComplexity int) int
		TxID           func(childComplexity int) int
		Type           func(childComplexity int) int
		Version        func(childComplexity int) int
		Writes         func(childComplexity int) int
	}

	TransactionWrite struct {
		ChaincodeID func(childComplexity int) int
		Deleted     func(childComplexity int) int
		Key         func(childComplexity int) int
		Value       func(childComplexity int) int
	}

	UpdateChannelResponse struct {
		Errors        func(childComplexity int) int
		TransactionID func(childComplexity int) int
	}
}

type CAResolver interface {
	Storage(ctx context.Context, obj *models.Ca) (*models.CAStorage, error)
}
type ChannelResolver interface {
	Chaincodes(ctx context.Context, obj *models.Channel) ([]*models.ChannelChaincode, error)
	Peers(ctx context.Context, obj *models.Channel) ([]*models.ChannelPeer, error)
}
type MutationResolver interface {
	CreatePeer(ctx context.Context, input models.CreatePeerInput) (*models.Peer, error)
	UpdatePeer(ctx context.Context, filter models.NameAndNamespace, input models.UpdateePeerInput) (*models.Peer, error)
	CreateOrderer(ctx context.Context, input models.CreateOrdererInput) (*models.Orderer, error)
	UpdateOrderer(ctx context.Context, filter models.NameAndNamespace, input models.UpdateeOrdererInput) (*models.Orderer, error)
	CreateCa(ctx context.Context, input models.CreateCAInput) (*models.Ca, error)
	UpdateCa(ctx context.Context, filter models.NameAndNamespace, input models.UpdateCAInput) (*models.Ca, error)
	RenewPeerCertificates(ctx context.Context, input models.RenewPeerCertificatesInput) (*models.RenewPeerCertificatesResponse, error)
	RenewOrdererCertificates(ctx context.Context, input models.RenewOrdererCertificatesInput) (*models.RenewOrdererCertificatesResponse, error)
	UpdateChannel(ctx context.Context, input models.UpdateChannelInput) (*models.UpdateChannelResponse, error)
	GetUpdateChannelBlock(ctx context.Context, input models.GetUpdateChannelBlockInput) (*models.GetUpdateChannelBlockResponse, error)
}
type OrdererResolver interface {
	Storage(ctx context.Context, obj *models.Orderer) (*models.OrdererStorage, error)
}
type PeerResolver interface {
	Storage(ctx context.Context, obj *models.Peer) (*models.PeerStorage, error)
}
type QueryResolver interface {
	Peers(ctx context.Context) ([]*models.Peer, error)
	Peer(ctx context.Context, input models.NameAndNamespace) (*models.Peer, error)
	Orderers(ctx context.Context) ([]*models.Orderer, error)
	Orderer(ctx context.Context, input models.NameAndNamespace) (*models.Orderer, error)
	NetworkConfigEnabled(ctx context.Context) (bool, error)
	Cas(ctx context.Context) ([]*models.Ca, error)
	Ca(ctx context.Context, input models.NameAndNamespace) (*models.Ca, error)
	Namespaces(ctx context.Context) ([]*models.Namespace, error)
	StorageClasses(ctx context.Context) ([]*models.StorageClass, error)
	Channels(ctx context.Context) ([]*models.LightChannel, error)
	Channel(ctx context.Context, channelID string) (*models.Channel, error)
	Blocks(ctx context.Context, channelID string, from int, to int, reverse bool) (*models.BlocksResponse, error)
	Block(ctx context.Context, channelID string, blockNumber int) (*models.Block, error)
	BlockWithPrivateData(ctx context.Context, channelID string, blockNumber int) (*models.BlockWithPrivateData, error)
	BlockByTxid(ctx context.Context, channelID string, transactionID string) (*models.Block, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "ApplicationConfig.acls":
		if e.complexity.ApplicationConfig.Acls == nil {
			break
		}

		return e.complexity.ApplicationConfig.Acls(childComplexity), true

	case "ApplicationConfig.capabilities":
		if e.complexity.ApplicationConfig.Capabilities == nil {
			break
		}

		return e.complexity.ApplicationConfig.Capabilities(childComplexity), true

	case "ApplicationConfig.organizations":
		if e.complexity.ApplicationConfig.Organizations == nil {
			break
		}

		return e.complexity.ApplicationConfig.Organizations(childComplexity), true

	case "ApplicationConfig.policies":
		if e.complexity.ApplicationConfig.Policies == nil {
			break
		}

		return e.complexity.ApplicationConfig.Policies(childComplexity), true

	case "ApplicationPolicy.channelConfigPolicy":
		if e.complexity.ApplicationPolicy.ChannelConfigPolicy == nil {
			break
		}

		return e.complexity.ApplicationPolicy.ChannelConfigPolicy(childComplexity), true

	case "ApplicationPolicy.signaturePolicy":
		if e.complexity.ApplicationPolicy.SignaturePolicy == nil {
			break
		}

		return e.complexity.ApplicationPolicy.SignaturePolicy(childComplexity), true

	case "Block.blockNumber":
		if e.complexity.Block.BlockNumber == nil {
			break
		}

		return e.complexity.Block.BlockNumber(childComplexity), true

	case "Block.createdAt":
		if e.complexity.Block.CreatedAt == nil {
			break
		}

		return e.complexity.Block.CreatedAt(childComplexity), true

	case "Block.dataHash":
		if e.complexity.Block.DataHash == nil {
			break
		}

		return e.complexity.Block.DataHash(childComplexity), true

	case "Block.numTransactions":
		if e.complexity.Block.NumTransactions == nil {
			break
		}

		return e.complexity.Block.NumTransactions(childComplexity), true

	case "Block.transactions":
		if e.complexity.Block.Transactions == nil {
			break
		}

		return e.complexity.Block.Transactions(childComplexity), true

	case "BlockWithPrivateData.blockNumber":
		if e.complexity.BlockWithPrivateData.BlockNumber == nil {
			break
		}

		return e.complexity.BlockWithPrivateData.BlockNumber(childComplexity), true

	case "BlockWithPrivateData.createdAt":
		if e.complexity.BlockWithPrivateData.CreatedAt == nil {
			break
		}

		return e.complexity.BlockWithPrivateData.CreatedAt(childComplexity), true

	case "BlockWithPrivateData.dataHash":
		if e.complexity.BlockWithPrivateData.DataHash == nil {
			break
		}

		return e.complexity.BlockWithPrivateData.DataHash(childComplexity), true

	case "BlockWithPrivateData.numTransactions":
		if e.complexity.BlockWithPrivateData.NumTransactions == nil {
			break
		}

		return e.complexity.BlockWithPrivateData.NumTransactions(childComplexity), true

	case "BlockWithPrivateData.transactions":
		if e.complexity.BlockWithPrivateData.Transactions == nil {
			break
		}

		return e.complexity.BlockWithPrivateData.Transactions(childComplexity), true

	case "BlocksResponse.blocks":
		if e.complexity.BlocksResponse.Blocks == nil {
			break
		}

		return e.complexity.BlocksResponse.Blocks(childComplexity), true

	case "BlocksResponse.height":
		if e.complexity.BlocksResponse.Height == nil {
			break
		}

		return e.complexity.BlocksResponse.Height(childComplexity), true

	case "CA.name":
		if e.complexity.CA.Name == nil {
			break
		}

		return e.complexity.CA.Name(childComplexity), true

	case "CA.namespace":
		if e.complexity.CA.Namespace == nil {
			break
		}

		return e.complexity.CA.Namespace(childComplexity), true

	case "CA.storage":
		if e.complexity.CA.Storage == nil {
			break
		}

		return e.complexity.CA.Storage(childComplexity), true

	case "CA.yaml":
		if e.complexity.CA.Yaml == nil {
			break
		}

		return e.complexity.CA.Yaml(childComplexity), true

	case "CAStorage.ca":
		if e.complexity.CAStorage.Ca == nil {
			break
		}

		return e.complexity.CAStorage.Ca(childComplexity), true

	case "ChaincodeApproval.approved":
		if e.complexity.ChaincodeApproval.Approved == nil {
			break
		}

		return e.complexity.ChaincodeApproval.Approved(childComplexity), true

	case "ChaincodeApproval.mspID":
		if e.complexity.ChaincodeApproval.MspID == nil {
			break
		}

		return e.complexity.ChaincodeApproval.MspID(childComplexity), true

	case "Channel.application":
		if e.complexity.Channel.Application == nil {
			break
		}

		return e.complexity.Channel.Application(childComplexity), true

	case "Channel.chaincodes":
		if e.complexity.Channel.Chaincodes == nil {
			break
		}

		return e.complexity.Channel.Chaincodes(childComplexity), true

	case "Channel.channelConfig":
		if e.complexity.Channel.ChannelConfig == nil {
			break
		}

		return e.complexity.Channel.ChannelConfig(childComplexity), true

	case "Channel.height":
		if e.complexity.Channel.Height == nil {
			break
		}

		return e.complexity.Channel.Height(childComplexity), true

	case "Channel.name":
		if e.complexity.Channel.Name == nil {
			break
		}

		return e.complexity.Channel.Name(childComplexity), true

	case "Channel.orderer":
		if e.complexity.Channel.Orderer == nil {
			break
		}

		return e.complexity.Channel.Orderer(childComplexity), true

	case "Channel.peers":
		if e.complexity.Channel.Peers == nil {
			break
		}

		return e.complexity.Channel.Peers(childComplexity), true

	case "Channel.protoConfig":
		if e.complexity.Channel.ProtoConfig == nil {
			break
		}

		return e.complexity.Channel.ProtoConfig(childComplexity), true

	case "Channel.rawConfig":
		if e.complexity.Channel.RawConfig == nil {
			break
		}

		return e.complexity.Channel.RawConfig(childComplexity), true

	case "ChannelACL.key":
		if e.complexity.ChannelACL.Key == nil {
			break
		}

		return e.complexity.ChannelACL.Key(childComplexity), true

	case "ChannelACL.value":
		if e.complexity.ChannelACL.Value == nil {
			break
		}

		return e.complexity.ChannelACL.Value(childComplexity), true

	case "ChannelAnchorPeer.host":
		if e.complexity.ChannelAnchorPeer.Host == nil {
			break
		}

		return e.complexity.ChannelAnchorPeer.Host(childComplexity), true

	case "ChannelAnchorPeer.mspID":
		if e.complexity.ChannelAnchorPeer.MspID == nil {
			break
		}

		return e.complexity.ChannelAnchorPeer.MspID(childComplexity), true

	case "ChannelAnchorPeer.port":
		if e.complexity.ChannelAnchorPeer.Port == nil {
			break
		}

		return e.complexity.ChannelAnchorPeer.Port(childComplexity), true

	case "ChannelChaincode.approvals":
		if e.complexity.ChannelChaincode.Approvals == nil {
			break
		}

		return e.complexity.ChannelChaincode.Approvals(childComplexity), true

	case "ChannelChaincode.configPolicy":
		if e.complexity.ChannelChaincode.ConfigPolicy == nil {
			break
		}

		return e.complexity.ChannelChaincode.ConfigPolicy(childComplexity), true

	case "ChannelChaincode.endorsementPlugin":
		if e.complexity.ChannelChaincode.EndorsementPlugin == nil {
			break
		}

		return e.complexity.ChannelChaincode.EndorsementPlugin(childComplexity), true

	case "ChannelChaincode.name":
		if e.complexity.ChannelChaincode.Name == nil {
			break
		}

		return e.complexity.ChannelChaincode.Name(childComplexity), true

	case "ChannelChaincode.privateDataCollections":
		if e.complexity.ChannelChaincode.PrivateDataCollections == nil {
			break
		}

		return e.complexity.ChannelChaincode.PrivateDataCollections(childComplexity), true

	case "ChannelChaincode.sequence":
		if e.complexity.ChannelChaincode.Sequence == nil {
			break
		}

		return e.complexity.ChannelChaincode.Sequence(childComplexity), true

	case "ChannelChaincode.signaturePolicy":
		if e.complexity.ChannelChaincode.SignaturePolicy == nil {
			break
		}

		return e.complexity.ChannelChaincode.SignaturePolicy(childComplexity), true

	case "ChannelChaincode.validationPlugin":
		if e.complexity.ChannelChaincode.ValidationPlugin == nil {
			break
		}

		return e.complexity.ChannelChaincode.ValidationPlugin(childComplexity), true

	case "ChannelChaincode.version":
		if e.complexity.ChannelChaincode.Version == nil {
			break
		}

		return e.complexity.ChannelChaincode.Version(childComplexity), true

	case "ChannelConfig.capabilities":
		if e.complexity.ChannelConfig.Capabilities == nil {
			break
		}

		return e.complexity.ChannelConfig.Capabilities(childComplexity), true

	case "ChannelConfig.policies":
		if e.complexity.ChannelConfig.Policies == nil {
			break
		}

		return e.complexity.ChannelConfig.Policies(childComplexity), true

	case "ChannelMSP.admins":
		if e.complexity.ChannelMSP.Admins == nil {
			break
		}

		return e.complexity.ChannelMSP.Admins(childComplexity), true

	case "ChannelMSP.intermediateCerts":
		if e.complexity.ChannelMSP.IntermediateCerts == nil {
			break
		}

		return e.complexity.ChannelMSP.IntermediateCerts(childComplexity), true

	case "ChannelMSP.name":
		if e.complexity.ChannelMSP.Name == nil {
			break
		}

		return e.complexity.ChannelMSP.Name(childComplexity), true

	case "ChannelMSP.revocationList":
		if e.complexity.ChannelMSP.RevocationList == nil {
			break
		}

		return e.complexity.ChannelMSP.RevocationList(childComplexity), true

	case "ChannelMSP.rootCerts":
		if e.complexity.ChannelMSP.RootCerts == nil {
			break
		}

		return e.complexity.ChannelMSP.RootCerts(childComplexity), true

	case "ChannelMSP.tlsIntermediateCerts":
		if e.complexity.ChannelMSP.TLSIntermediateCerts == nil {
			break
		}

		return e.complexity.ChannelMSP.TLSIntermediateCerts(childComplexity), true

	case "ChannelMSP.tlsRootCerts":
		if e.complexity.ChannelMSP.TLSRootCerts == nil {
			break
		}

		return e.complexity.ChannelMSP.TLSRootCerts(childComplexity), true

	case "ChannelOrg.anchorPeer":
		if e.complexity.ChannelOrg.AnchorPeer == nil {
			break
		}

		return e.complexity.ChannelOrg.AnchorPeer(childComplexity), true

	case "ChannelOrg.cryptoConfig":
		if e.complexity.ChannelOrg.CryptoConfig == nil {
			break
		}

		return e.complexity.ChannelOrg.CryptoConfig(childComplexity), true

	case "ChannelOrg.modPolicy":
		if e.complexity.ChannelOrg.ModPolicy == nil {
			break
		}

		return e.complexity.ChannelOrg.ModPolicy(childComplexity), true

	case "ChannelOrg.msp":
		if e.complexity.ChannelOrg.Msp == nil {
			break
		}

		return e.complexity.ChannelOrg.Msp(childComplexity), true

	case "ChannelOrg.mspID":
		if e.complexity.ChannelOrg.MspID == nil {
			break
		}

		return e.complexity.ChannelOrg.MspID(childComplexity), true

	case "ChannelOrg.nodeOUs":
		if e.complexity.ChannelOrg.NodeOUs == nil {
			break
		}

		return e.complexity.ChannelOrg.NodeOUs(childComplexity), true

	case "ChannelOrg.ordererEndpoints":
		if e.complexity.ChannelOrg.OrdererEndpoints == nil {
			break
		}

		return e.complexity.ChannelOrg.OrdererEndpoints(childComplexity), true

	case "ChannelOrg.ous":
		if e.complexity.ChannelOrg.Ous == nil {
			break
		}

		return e.complexity.ChannelOrg.Ous(childComplexity), true

	case "ChannelOrg.policies":
		if e.complexity.ChannelOrg.Policies == nil {
			break
		}

		return e.complexity.ChannelOrg.Policies(childComplexity), true

	case "ChannelPeer.height":
		if e.complexity.ChannelPeer.Height == nil {
			break
		}

		return e.complexity.ChannelPeer.Height(childComplexity), true

	case "ChannelPeer.mspID":
		if e.complexity.ChannelPeer.MspID == nil {
			break
		}

		return e.complexity.ChannelPeer.MspID(childComplexity), true

	case "ChannelPeer.url":
		if e.complexity.ChannelPeer.URL == nil {
			break
		}

		return e.complexity.ChannelPeer.URL(childComplexity), true

	case "ChannelPolicy.key":
		if e.complexity.ChannelPolicy.Key == nil {
			break
		}

		return e.complexity.ChannelPolicy.Key(childComplexity), true

	case "ChannelPolicy.modPolicy":
		if e.complexity.ChannelPolicy.ModPolicy == nil {
			break
		}

		return e.complexity.ChannelPolicy.ModPolicy(childComplexity), true

	case "ChannelPolicy.rule":
		if e.complexity.ChannelPolicy.Rule == nil {
			break
		}

		return e.complexity.ChannelPolicy.Rule(childComplexity), true

	case "ChannelPolicy.type":
		if e.complexity.ChannelPolicy.Type == nil {
			break
		}

		return e.complexity.ChannelPolicy.Type(childComplexity), true

	case "CryptoConfig.identityIdentifierHashFunction":
		if e.complexity.CryptoConfig.IdentityIdentifierHashFunction == nil {
			break
		}

		return e.complexity.CryptoConfig.IdentityIdentifierHashFunction(childComplexity), true

	case "CryptoConfig.signatureHashFamily":
		if e.complexity.CryptoConfig.SignatureHashFamily == nil {
			break
		}

		return e.complexity.CryptoConfig.SignatureHashFamily(childComplexity), true

	case "Error.message":
		if e.complexity.Error.Message == nil {
			break
		}

		return e.complexity.Error.Message(childComplexity), true

	case "GetUpdateChannelBlockResponse.block":
		if e.complexity.GetUpdateChannelBlockResponse.Block == nil {
			break
		}

		return e.complexity.GetUpdateChannelBlockResponse.Block(childComplexity), true

	case "GetUpdateChannelBlockResponse.configUpdate":
		if e.complexity.GetUpdateChannelBlockResponse.ConfigUpdate == nil {
			break
		}

		return e.complexity.GetUpdateChannelBlockResponse.ConfigUpdate(childComplexity), true

	case "GetUpdateChannelBlockResponse.errors":
		if e.complexity.GetUpdateChannelBlockResponse.Errors == nil {
			break
		}

		return e.complexity.GetUpdateChannelBlockResponse.Errors(childComplexity), true

	case "LightChannel.name":
		if e.complexity.LightChannel.Name == nil {
			break
		}

		return e.complexity.LightChannel.Name(childComplexity), true

	case "MSPPrincipal.combined":
		if e.complexity.MSPPrincipal.Combined == nil {
			break
		}

		return e.complexity.MSPPrincipal.Combined(childComplexity), true

	case "MSPPrincipal.role":
		if e.complexity.MSPPrincipal.Role == nil {
			break
		}

		return e.complexity.MSPPrincipal.Role(childComplexity), true

	case "MSPPrincipalCombined.classification":
		if e.complexity.MSPPrincipalCombined.Classification == nil {
			break
		}

		return e.complexity.MSPPrincipalCombined.Classification(childComplexity), true

	case "MSPPrincipalCombined.mspPrincipals":
		if e.complexity.MSPPrincipalCombined.MspPrincipals == nil {
			break
		}

		return e.complexity.MSPPrincipalCombined.MspPrincipals(childComplexity), true

	case "MSPPrincipalRole.mspID":
		if e.complexity.MSPPrincipalRole.MspID == nil {
			break
		}

		return e.complexity.MSPPrincipalRole.MspID(childComplexity), true

	case "MSPPrincipalRole.role":
		if e.complexity.MSPPrincipalRole.Role == nil {
			break
		}

		return e.complexity.MSPPrincipalRole.Role(childComplexity), true

	case "Mutation.createCA":
		if e.complexity.Mutation.CreateCa == nil {
			break
		}

		args, err := ec.field_Mutation_createCA_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCa(childComplexity, args["input"].(models.CreateCAInput)), true

	case "Mutation.createOrderer":
		if e.complexity.Mutation.CreateOrderer == nil {
			break
		}

		args, err := ec.field_Mutation_createOrderer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateOrderer(childComplexity, args["input"].(models.CreateOrdererInput)), true

	case "Mutation.createPeer":
		if e.complexity.Mutation.CreatePeer == nil {
			break
		}

		args, err := ec.field_Mutation_createPeer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePeer(childComplexity, args["input"].(models.CreatePeerInput)), true

	case "Mutation.getUpdateChannelBlock":
		if e.complexity.Mutation.GetUpdateChannelBlock == nil {
			break
		}

		args, err := ec.field_Mutation_getUpdateChannelBlock_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GetUpdateChannelBlock(childComplexity, args["input"].(models.GetUpdateChannelBlockInput)), true

	case "Mutation.renewOrdererCertificates":
		if e.complexity.Mutation.RenewOrdererCertificates == nil {
			break
		}

		args, err := ec.field_Mutation_renewOrdererCertificates_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RenewOrdererCertificates(childComplexity, args["input"].(models.RenewOrdererCertificatesInput)), true

	case "Mutation.renewPeerCertificates":
		if e.complexity.Mutation.RenewPeerCertificates == nil {
			break
		}

		args, err := ec.field_Mutation_renewPeerCertificates_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RenewPeerCertificates(childComplexity, args["input"].(models.RenewPeerCertificatesInput)), true

	case "Mutation.updateCA":
		if e.complexity.Mutation.UpdateCa == nil {
			break
		}

		args, err := ec.field_Mutation_updateCA_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCa(childComplexity, args["filter"].(models.NameAndNamespace), args["input"].(models.UpdateCAInput)), true

	case "Mutation.updateChannel":
		if e.complexity.Mutation.UpdateChannel == nil {
			break
		}

		args, err := ec.field_Mutation_updateChannel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateChannel(childComplexity, args["input"].(models.UpdateChannelInput)), true

	case "Mutation.updateOrderer":
		if e.complexity.Mutation.UpdateOrderer == nil {
			break
		}

		args, err := ec.field_Mutation_updateOrderer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateOrderer(childComplexity, args["filter"].(models.NameAndNamespace), args["input"].(models.UpdateeOrdererInput)), true

	case "Mutation.updatePeer":
		if e.complexity.Mutation.UpdatePeer == nil {
			break
		}

		args, err := ec.field_Mutation_updatePeer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePeer(childComplexity, args["filter"].(models.NameAndNamespace), args["input"].(models.UpdateePeerInput)), true

	case "Namespace.name":
		if e.complexity.Namespace.Name == nil {
			break
		}

		return e.complexity.Namespace.Name(childComplexity), true

	case "NetworkAddress.host":
		if e.complexity.NetworkAddress.Host == nil {
			break
		}

		return e.complexity.NetworkAddress.Host(childComplexity), true

	case "NetworkAddress.port":
		if e.complexity.NetworkAddress.Port == nil {
			break
		}

		return e.complexity.NetworkAddress.Port(childComplexity), true

	case "NodeOUs.adminOUIdentifier":
		if e.complexity.NodeOUs.AdminOUIdentifier == nil {
			break
		}

		return e.complexity.NodeOUs.AdminOUIdentifier(childComplexity), true

	case "NodeOUs.clientOUIdentifier":
		if e.complexity.NodeOUs.ClientOUIdentifier == nil {
			break
		}

		return e.complexity.NodeOUs.ClientOUIdentifier(childComplexity), true

	case "NodeOUs.enable":
		if e.complexity.NodeOUs.Enable == nil {
			break
		}

		return e.complexity.NodeOUs.Enable(childComplexity), true

	case "NodeOUs.ordererOUIdentifier":
		if e.complexity.NodeOUs.OrdererOUIdentifier == nil {
			break
		}

		return e.complexity.NodeOUs.OrdererOUIdentifier(childComplexity), true

	case "NodeOUs.peerOUIdentifier":
		if e.complexity.NodeOUs.PeerOUIdentifier == nil {
			break
		}

		return e.complexity.NodeOUs.PeerOUIdentifier(childComplexity), true

	case "OUIdentifier.certificate":
		if e.complexity.OUIdentifier.Certificate == nil {
			break
		}

		return e.complexity.OUIdentifier.Certificate(childComplexity), true

	case "OUIdentifier.ouIdentifier":
		if e.complexity.OUIdentifier.OuIdentifier == nil {
			break
		}

		return e.complexity.OUIdentifier.OuIdentifier(childComplexity), true

	case "Orderer.name":
		if e.complexity.Orderer.Name == nil {
			break
		}

		return e.complexity.Orderer.Name(childComplexity), true

	case "Orderer.namespace":
		if e.complexity.Orderer.Namespace == nil {
			break
		}

		return e.complexity.Orderer.Namespace(childComplexity), true

	case "Orderer.storage":
		if e.complexity.Orderer.Storage == nil {
			break
		}

		return e.complexity.Orderer.Storage(childComplexity), true

	case "Orderer.yaml":
		if e.complexity.Orderer.Yaml == nil {
			break
		}

		return e.complexity.Orderer.Yaml(childComplexity), true

	case "OrdererConfig.batchSize":
		if e.complexity.OrdererConfig.BatchSize == nil {
			break
		}

		return e.complexity.OrdererConfig.BatchSize(childComplexity), true

	case "OrdererConfig.batchTimeout":
		if e.complexity.OrdererConfig.BatchTimeout == nil {
			break
		}

		return e.complexity.OrdererConfig.BatchTimeout(childComplexity), true

	case "OrdererConfig.capabilities":
		if e.complexity.OrdererConfig.Capabilities == nil {
			break
		}

		return e.complexity.OrdererConfig.Capabilities(childComplexity), true

	case "OrdererConfig.etcdDraft":
		if e.complexity.OrdererConfig.EtcdDraft == nil {
			break
		}

		return e.complexity.OrdererConfig.EtcdDraft(childComplexity), true

	case "OrdererConfig.maxChannels":
		if e.complexity.OrdererConfig.MaxChannels == nil {
			break
		}

		return e.complexity.OrdererConfig.MaxChannels(childComplexity), true

	case "OrdererConfig.organizations":
		if e.complexity.OrdererConfig.Organizations == nil {
			break
		}

		return e.complexity.OrdererConfig.Organizations(childComplexity), true

	case "OrdererConfig.policies":
		if e.complexity.OrdererConfig.Policies == nil {
			break
		}

		return e.complexity.OrdererConfig.Policies(childComplexity), true

	case "OrdererConfig.state":
		if e.complexity.OrdererConfig.State == nil {
			break
		}

		return e.complexity.OrdererConfig.State(childComplexity), true

	case "OrdererConfig.type":
		if e.complexity.OrdererConfig.Type == nil {
			break
		}

		return e.complexity.OrdererConfig.Type(childComplexity), true

	case "OrdererConfigBatchSize.absoluteMaxBytes":
		if e.complexity.OrdererConfigBatchSize.AbsoluteMaxBytes == nil {
			break
		}

		return e.complexity.OrdererConfigBatchSize.AbsoluteMaxBytes(childComplexity), true

	case "OrdererConfigBatchSize.maxMessageCount":
		if e.complexity.OrdererConfigBatchSize.MaxMessageCount == nil {
			break
		}

		return e.complexity.OrdererConfigBatchSize.MaxMessageCount(childComplexity), true

	case "OrdererConfigBatchSize.preferredMaxBytes":
		if e.complexity.OrdererConfigBatchSize.PreferredMaxBytes == nil {
			break
		}

		return e.complexity.OrdererConfigBatchSize.PreferredMaxBytes(childComplexity), true

	case "OrdererConfigRaft.consenters":
		if e.complexity.OrdererConfigRaft.Consenters == nil {
			break
		}

		return e.complexity.OrdererConfigRaft.Consenters(childComplexity), true

	case "OrdererConfigRaft.options":
		if e.complexity.OrdererConfigRaft.Options == nil {
			break
		}

		return e.complexity.OrdererConfigRaft.Options(childComplexity), true

	case "OrdererConfigRaftConsenter.address":
		if e.complexity.OrdererConfigRaftConsenter.Address == nil {
			break
		}

		return e.complexity.OrdererConfigRaftConsenter.Address(childComplexity), true

	case "OrdererConfigRaftConsenter.clientTlsCert":
		if e.complexity.OrdererConfigRaftConsenter.ClientTLSCert == nil {
			break
		}

		return e.complexity.OrdererConfigRaftConsenter.ClientTLSCert(childComplexity), true

	case "OrdererConfigRaftConsenter.serverTlsCert":
		if e.complexity.OrdererConfigRaftConsenter.ServerTLSCert == nil {
			break
		}

		return e.complexity.OrdererConfigRaftConsenter.ServerTLSCert(childComplexity), true

	case "OrdererConfigRaftOptions.electionTick":
		if e.complexity.OrdererConfigRaftOptions.ElectionTick == nil {
			break
		}

		return e.complexity.OrdererConfigRaftOptions.ElectionTick(childComplexity), true

	case "OrdererConfigRaftOptions.heartbeatTick":
		if e.complexity.OrdererConfigRaftOptions.HeartbeatTick == nil {
			break
		}

		return e.complexity.OrdererConfigRaftOptions.HeartbeatTick(childComplexity), true

	case "OrdererConfigRaftOptions.maxInflightBlocks":
		if e.complexity.OrdererConfigRaftOptions.MaxInflightBlocks == nil {
			break
		}

		return e.complexity.OrdererConfigRaftOptions.MaxInflightBlocks(childComplexity), true

	case "OrdererConfigRaftOptions.snapshotIntervalSize":
		if e.complexity.OrdererConfigRaftOptions.SnapshotIntervalSize == nil {
			break
		}

		return e.complexity.OrdererConfigRaftOptions.SnapshotIntervalSize(childComplexity), true

	case "OrdererConfigRaftOptions.tickInterval":
		if e.complexity.OrdererConfigRaftOptions.TickInterval == nil {
			break
		}

		return e.complexity.OrdererConfigRaftOptions.TickInterval(childComplexity), true

	case "OrdererStorage.orderer":
		if e.complexity.OrdererStorage.Orderer == nil {
			break
		}

		return e.complexity.OrdererStorage.Orderer(childComplexity), true

	case "PDCRead.block":
		if e.complexity.PDCRead.Block == nil {
			break
		}

		return e.complexity.PDCRead.Block(childComplexity), true

	case "PDCRead.collectionName":
		if e.complexity.PDCRead.CollectionName == nil {
			break
		}

		return e.complexity.PDCRead.CollectionName(childComplexity), true

	case "PDCRead.key":
		if e.complexity.PDCRead.Key == nil {
			break
		}

		return e.complexity.PDCRead.Key(childComplexity), true

	case "PDCRead.txNum":
		if e.complexity.PDCRead.TxNum == nil {
			break
		}

		return e.complexity.PDCRead.TxNum(childComplexity), true

	case "PDCReadHash.keyHash":
		if e.complexity.PDCReadHash.KeyHash == nil {
			break
		}

		return e.complexity.PDCReadHash.KeyHash(childComplexity), true

	case "PDCReadHash.pdcName":
		if e.complexity.PDCReadHash.PdcName == nil {
			break
		}

		return e.complexity.PDCReadHash.PdcName(childComplexity), true

	case "PDCReadHash.rwSetHash":
		if e.complexity.PDCReadHash.RwSetHash == nil {
			break
		}

		return e.complexity.PDCReadHash.RwSetHash(childComplexity), true

	case "PDCReadHash.version":
		if e.complexity.PDCReadHash.Version == nil {
			break
		}

		return e.complexity.PDCReadHash.Version(childComplexity), true

	case "PDCReadVersion.blockNum":
		if e.complexity.PDCReadVersion.BlockNum == nil {
			break
		}

		return e.complexity.PDCReadVersion.BlockNum(childComplexity), true

	case "PDCReadVersion.txNum":
		if e.complexity.PDCReadVersion.TxNum == nil {
			break
		}

		return e.complexity.PDCReadVersion.TxNum(childComplexity), true

	case "PDCWrite.collectionName":
		if e.complexity.PDCWrite.CollectionName == nil {
			break
		}

		return e.complexity.PDCWrite.CollectionName(childComplexity), true

	case "PDCWrite.deleted":
		if e.complexity.PDCWrite.Deleted == nil {
			break
		}

		return e.complexity.PDCWrite.Deleted(childComplexity), true

	case "PDCWrite.key":
		if e.complexity.PDCWrite.Key == nil {
			break
		}

		return e.complexity.PDCWrite.Key(childComplexity), true

	case "PDCWrite.value":
		if e.complexity.PDCWrite.Value == nil {
			break
		}

		return e.complexity.PDCWrite.Value(childComplexity), true

	case "PDCWriteHash.isDelete":
		if e.complexity.PDCWriteHash.IsDelete == nil {
			break
		}

		return e.complexity.PDCWriteHash.IsDelete(childComplexity), true

	case "PDCWriteHash.isPurge":
		if e.complexity.PDCWriteHash.IsPurge == nil {
			break
		}

		return e.complexity.PDCWriteHash.IsPurge(childComplexity), true

	case "PDCWriteHash.keyHash":
		if e.complexity.PDCWriteHash.KeyHash == nil {
			break
		}

		return e.complexity.PDCWriteHash.KeyHash(childComplexity), true

	case "PDCWriteHash.pdcName":
		if e.complexity.PDCWriteHash.PdcName == nil {
			break
		}

		return e.complexity.PDCWriteHash.PdcName(childComplexity), true

	case "PDCWriteHash.rwSetHash":
		if e.complexity.PDCWriteHash.RwSetHash == nil {
			break
		}

		return e.complexity.PDCWriteHash.RwSetHash(childComplexity), true

	case "PDCWriteHash.valueHash":
		if e.complexity.PDCWriteHash.ValueHash == nil {
			break
		}

		return e.complexity.PDCWriteHash.ValueHash(childComplexity), true

	case "Peer.name":
		if e.complexity.Peer.Name == nil {
			break
		}

		return e.complexity.Peer.Name(childComplexity), true

	case "Peer.namespace":
		if e.complexity.Peer.Namespace == nil {
			break
		}

		return e.complexity.Peer.Namespace(childComplexity), true

	case "Peer.storage":
		if e.complexity.Peer.Storage == nil {
			break
		}

		return e.complexity.Peer.Storage(childComplexity), true

	case "Peer.yaml":
		if e.complexity.Peer.Yaml == nil {
			break
		}

		return e.complexity.Peer.Yaml(childComplexity), true

	case "PeerStorage.chaincode":
		if e.complexity.PeerStorage.Chaincode == nil {
			break
		}

		return e.complexity.PeerStorage.Chaincode(childComplexity), true

	case "PeerStorage.couchDB":
		if e.complexity.PeerStorage.CouchDb == nil {
			break
		}

		return e.complexity.PeerStorage.CouchDb(childComplexity), true

	case "PeerStorage.peer":
		if e.complexity.PeerStorage.Peer == nil {
			break
		}

		return e.complexity.PeerStorage.Peer(childComplexity), true

	case "PrivateDataCollection.blockToLive":
		if e.complexity.PrivateDataCollection.BlockToLive == nil {
			break
		}

		return e.complexity.PrivateDataCollection.BlockToLive(childComplexity), true

	case "PrivateDataCollection.endorsementPolicy":
		if e.complexity.PrivateDataCollection.EndorsementPolicy == nil {
			break
		}

		return e.complexity.PrivateDataCollection.EndorsementPolicy(childComplexity), true

	case "PrivateDataCollection.maxPeerCount":
		if e.complexity.PrivateDataCollection.MaxPeerCount == nil {
			break
		}

		return e.complexity.PrivateDataCollection.MaxPeerCount(childComplexity), true

	case "PrivateDataCollection.memberOnlyRead":
		if e.complexity.PrivateDataCollection.MemberOnlyRead == nil {
			break
		}

		return e.complexity.PrivateDataCollection.MemberOnlyRead(childComplexity), true

	case "PrivateDataCollection.memberOnlyWrite":
		if e.complexity.PrivateDataCollection.MemberOnlyWrite == nil {
			break
		}

		return e.complexity.PrivateDataCollection.MemberOnlyWrite(childComplexity), true

	case "PrivateDataCollection.memberOrgsPolicy":
		if e.complexity.PrivateDataCollection.MemberOrgsPolicy == nil {
			break
		}

		return e.complexity.PrivateDataCollection.MemberOrgsPolicy(childComplexity), true

	case "PrivateDataCollection.name":
		if e.complexity.PrivateDataCollection.Name == nil {
			break
		}

		return e.complexity.PrivateDataCollection.Name(childComplexity), true

	case "PrivateDataCollection.requiredPeerCount":
		if e.complexity.PrivateDataCollection.RequiredPeerCount == nil {
			break
		}

		return e.complexity.PrivateDataCollection.RequiredPeerCount(childComplexity), true

	case "Query.block":
		if e.complexity.Query.Block == nil {
			break
		}

		args, err := ec.field_Query_block_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Block(childComplexity, args["channelID"].(string), args["blockNumber"].(int)), true

	case "Query.blockByTXID":
		if e.complexity.Query.BlockByTxid == nil {
			break
		}

		args, err := ec.field_Query_blockByTXID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BlockByTxid(childComplexity, args["channelID"].(string), args["transactionID"].(string)), true

	case "Query.blockWithPrivateData":
		if e.complexity.Query.BlockWithPrivateData == nil {
			break
		}

		args, err := ec.field_Query_blockWithPrivateData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BlockWithPrivateData(childComplexity, args["channelID"].(string), args["blockNumber"].(int)), true

	case "Query.blocks":
		if e.complexity.Query.Blocks == nil {
			break
		}

		args, err := ec.field_Query_blocks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Blocks(childComplexity, args["channelID"].(string), args["from"].(int), args["to"].(int), args["reverse"].(bool)), true

	case "Query.ca":
		if e.complexity.Query.Ca == nil {
			break
		}

		args, err := ec.field_Query_ca_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Ca(childComplexity, args["input"].(models.NameAndNamespace)), true

	case "Query.cas":
		if e.complexity.Query.Cas == nil {
			break
		}

		return e.complexity.Query.Cas(childComplexity), true

	case "Query.channel":
		if e.complexity.Query.Channel == nil {
			break
		}

		args, err := ec.field_Query_channel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Channel(childComplexity, args["channelID"].(string)), true

	case "Query.channels":
		if e.complexity.Query.Channels == nil {
			break
		}

		return e.complexity.Query.Channels(childComplexity), true

	case "Query.namespaces":
		if e.complexity.Query.Namespaces == nil {
			break
		}

		return e.complexity.Query.Namespaces(childComplexity), true

	case "Query.networkConfigEnabled":
		if e.complexity.Query.NetworkConfigEnabled == nil {
			break
		}

		return e.complexity.Query.NetworkConfigEnabled(childComplexity), true

	case "Query.orderer":
		if e.complexity.Query.Orderer == nil {
			break
		}

		args, err := ec.field_Query_orderer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Orderer(childComplexity, args["input"].(models.NameAndNamespace)), true

	case "Query.orderers":
		if e.complexity.Query.Orderers == nil {
			break
		}

		return e.complexity.Query.Orderers(childComplexity), true

	case "Query.peer":
		if e.complexity.Query.Peer == nil {
			break
		}

		args, err := ec.field_Query_peer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Peer(childComplexity, args["input"].(models.NameAndNamespace)), true

	case "Query.peers":
		if e.complexity.Query.Peers == nil {
			break
		}

		return e.complexity.Query.Peers(childComplexity), true

	case "Query.storageClasses":
		if e.complexity.Query.StorageClasses == nil {
			break
		}

		return e.complexity.Query.StorageClasses(childComplexity), true

	case "RenewOrdererCertificatesResponse.errors":
		if e.complexity.RenewOrdererCertificatesResponse.Errors == nil {
			break
		}

		return e.complexity.RenewOrdererCertificatesResponse.Errors(childComplexity), true

	case "RenewOrdererCertificatesResponse.orderer":
		if e.complexity.RenewOrdererCertificatesResponse.Orderer == nil {
			break
		}

		return e.complexity.RenewOrdererCertificatesResponse.Orderer(childComplexity), true

	case "RenewPeerCertificatesResponse.errors":
		if e.complexity.RenewPeerCertificatesResponse.Errors == nil {
			break
		}

		return e.complexity.RenewPeerCertificatesResponse.Errors(childComplexity), true

	case "RenewPeerCertificatesResponse.peer":
		if e.complexity.RenewPeerCertificatesResponse.Peer == nil {
			break
		}

		return e.complexity.RenewPeerCertificatesResponse.Peer(childComplexity), true

	case "SignaturePolicy.principals":
		if e.complexity.SignaturePolicy.Principals == nil {
			break
		}

		return e.complexity.SignaturePolicy.Principals(childComplexity), true

	case "SignaturePolicy.rule":
		if e.complexity.SignaturePolicy.Rule == nil {
			break
		}

		return e.complexity.SignaturePolicy.Rule(childComplexity), true

	case "SignaturePolicy.version":
		if e.complexity.SignaturePolicy.Version == nil {
			break
		}

		return e.complexity.SignaturePolicy.Version(childComplexity), true

	case "SignaturePolicyNOutOf.n":
		if e.complexity.SignaturePolicyNOutOf.N == nil {
			break
		}

		return e.complexity.SignaturePolicyNOutOf.N(childComplexity), true

	case "SignaturePolicyNOutOf.rules":
		if e.complexity.SignaturePolicyNOutOf.Rules == nil {
			break
		}

		return e.complexity.SignaturePolicyNOutOf.Rules(childComplexity), true

	case "SignaturePolicyRule.noutOf":
		if e.complexity.SignaturePolicyRule.NoutOf == nil {
			break
		}

		return e.complexity.SignaturePolicyRule.NoutOf(childComplexity), true

	case "SignaturePolicyRule.signedBy":
		if e.complexity.SignaturePolicyRule.SignedBy == nil {
			break
		}

		return e.complexity.SignaturePolicyRule.SignedBy(childComplexity), true

	case "SignaturePolicyRule.type":
		if e.complexity.SignaturePolicyRule.Type == nil {
			break
		}

		return e.complexity.SignaturePolicyRule.Type(childComplexity), true

	case "SignaturePolicySignedBy.signedBy":
		if e.complexity.SignaturePolicySignedBy.SignedBy == nil {
			break
		}

		return e.complexity.SignaturePolicySignedBy.SignedBy(childComplexity), true

	case "StorageClass.name":
		if e.complexity.StorageClass.Name == nil {
			break
		}

		return e.complexity.StorageClass.Name(childComplexity), true

	case "StorageUsage.free":
		if e.complexity.StorageUsage.Free == nil {
			break
		}

		return e.complexity.StorageUsage.Free(childComplexity), true

	case "StorageUsage.freeGB":
		if e.complexity.StorageUsage.FreeGb == nil {
			break
		}

		return e.complexity.StorageUsage.FreeGb(childComplexity), true

	case "StorageUsage.percentageUsed":
		if e.complexity.StorageUsage.PercentageUsed == nil {
			break
		}

		return e.complexity.StorageUsage.PercentageUsed(childComplexity), true

	case "StorageUsage.size":
		if e.complexity.StorageUsage.Size == nil {
			break
		}

		return e.complexity.StorageUsage.Size(childComplexity), true

	case "StorageUsage.sizeGB":
		if e.complexity.StorageUsage.SizeGb == nil {
			break
		}

		return e.complexity.StorageUsage.SizeGb(childComplexity), true

	case "StorageUsage.used":
		if e.complexity.StorageUsage.Used == nil {
			break
		}

		return e.complexity.StorageUsage.Used(childComplexity), true

	case "StorageUsage.usedGB":
		if e.complexity.StorageUsage.UsedGb == nil {
			break
		}

		return e.complexity.StorageUsage.UsedGb(childComplexity), true

	case "Transaction.chaincode":
		if e.complexity.Transaction.Chaincode == nil {
			break
		}

		return e.complexity.Transaction.Chaincode(childComplexity), true

	case "Transaction.createdAt":
		if e.complexity.Transaction.CreatedAt == nil {
			break
		}

		return e.complexity.Transaction.CreatedAt(childComplexity), true

	case "Transaction.path":
		if e.complexity.Transaction.Path == nil {
			break
		}

		return e.complexity.Transaction.Path(childComplexity), true

	case "Transaction.reads":
		if e.complexity.Transaction.Reads == nil {
			break
		}

		return e.complexity.Transaction.Reads(childComplexity), true

	case "Transaction.request":
		if e.complexity.Transaction.Request == nil {
			break
		}

		return e.complexity.Transaction.Request(childComplexity), true

	case "Transaction.response":
		if e.complexity.Transaction.Response == nil {
			break
		}

		return e.complexity.Transaction.Response(childComplexity), true

	case "Transaction.txID":
		if e.complexity.Transaction.TxID == nil {
			break
		}

		return e.complexity.Transaction.TxID(childComplexity), true

	case "Transaction.type":
		if e.complexity.Transaction.Type == nil {
			break
		}

		return e.complexity.Transaction.Type(childComplexity), true

	case "Transaction.version":
		if e.complexity.Transaction.Version == nil {
			break
		}

		return e.complexity.Transaction.Version(childComplexity), true

	case "Transaction.writes":
		if e.complexity.Transaction.Writes == nil {
			break
		}

		return e.complexity.Transaction.Writes(childComplexity), true

	case "TransactionRead.blockNumVersion":
		if e.complexity.TransactionRead.BlockNumVersion == nil {
			break
		}

		return e.complexity.TransactionRead.BlockNumVersion(childComplexity), true

	case "TransactionRead.chaincodeID":
		if e.complexity.TransactionRead.ChaincodeID == nil {
			break
		}

		return e.complexity.TransactionRead.ChaincodeID(childComplexity), true

	case "TransactionRead.key":
		if e.complexity.TransactionRead.Key == nil {
			break
		}

		return e.complexity.TransactionRead.Key(childComplexity), true

	case "TransactionRead.txNumVersion":
		if e.complexity.TransactionRead.TxNumVersion == nil {
			break
		}

		return e.complexity.TransactionRead.TxNumVersion(childComplexity), true

	case "TransactionWithPrivateData.chaincode":
		if e.complexity.TransactionWithPrivateData.Chaincode == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.Chaincode(childComplexity), true

	case "TransactionWithPrivateData.createdAt":
		if e.complexity.TransactionWithPrivateData.CreatedAt == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.CreatedAt(childComplexity), true

	case "TransactionWithPrivateData.path":
		if e.complexity.TransactionWithPrivateData.Path == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.Path(childComplexity), true

	case "TransactionWithPrivateData.pdcReadHashes":
		if e.complexity.TransactionWithPrivateData.PdcReadHashes == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.PdcReadHashes(childComplexity), true

	case "TransactionWithPrivateData.pdcReads":
		if e.complexity.TransactionWithPrivateData.PdcReads == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.PdcReads(childComplexity), true

	case "TransactionWithPrivateData.pdcWriteHashes":
		if e.complexity.TransactionWithPrivateData.PdcWriteHashes == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.PdcWriteHashes(childComplexity), true

	case "TransactionWithPrivateData.pdcWrites":
		if e.complexity.TransactionWithPrivateData.PdcWrites == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.PdcWrites(childComplexity), true

	case "TransactionWithPrivateData.reads":
		if e.complexity.TransactionWithPrivateData.Reads == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.Reads(childComplexity), true

	case "TransactionWithPrivateData.request":
		if e.complexity.TransactionWithPrivateData.Request == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.Request(childComplexity), true

	case "TransactionWithPrivateData.response":
		if e.complexity.TransactionWithPrivateData.Response == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.Response(childComplexity), true

	case "TransactionWithPrivateData.txID":
		if e.complexity.TransactionWithPrivateData.TxID == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.TxID(childComplexity), true

	case "TransactionWithPrivateData.type":
		if e.complexity.TransactionWithPrivateData.Type == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.Type(childComplexity), true

	case "TransactionWithPrivateData.version":
		if e.complexity.TransactionWithPrivateData.Version == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.Version(childComplexity), true

	case "TransactionWithPrivateData.writes":
		if e.complexity.TransactionWithPrivateData.Writes == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.Writes(childComplexity), true

	case "TransactionWrite.chaincodeID":
		if e.complexity.TransactionWrite.ChaincodeID == nil {
			break
		}

		return e.complexity.TransactionWrite.ChaincodeID(childComplexity), true

	case "TransactionWrite.deleted":
		if e.complexity.TransactionWrite.Deleted == nil {
			break
		}

		return e.complexity.TransactionWrite.Deleted(childComplexity), true

	case "TransactionWrite.key":
		if e.complexity.TransactionWrite.Key == nil {
			break
		}

		return e.complexity.TransactionWrite.Key(childComplexity), true

	case "TransactionWrite.value":
		if e.complexity.TransactionWrite.Value == nil {
			break
		}

		return e.complexity.TransactionWrite.Value(childComplexity), true

	case "UpdateChannelResponse.errors":
		if e.complexity.UpdateChannelResponse.Errors == nil {
			break
		}

		return e.complexity.UpdateChannelResponse.Errors(childComplexity), true

	case "UpdateChannelResponse.transactionID":
		if e.complexity.UpdateChannelResponse.TransactionID == nil {
			break
		}

		return e.complexity.UpdateChannelResponse.TransactionID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputApplicationConfigInput,
		ec.unmarshalInputChannelACLInput,
		ec.unmarshalInputChannelConfigInput,
		ec.unmarshalInputChannelOrganization,
		ec.unmarshalInputCreateCAInput,
		ec.unmarshalInputCreateOrdererInput,
		ec.unmarshalInputCreatePeerInput,
		ec.unmarshalInputCryptoConfigInput,
		ec.unmarshalInputEtcdRaftInput,
		ec.unmarshalInputGetUpdateChannelBlockInput,
		ec.unmarshalInputMSPInput,
		ec.unmarshalInputMSPSignature,
		ec.unmarshalInputNameAndNamespace,
		ec.unmarshalInputNetworkAddressInput,
		ec.unmarshalInputNodeOUsInput,
		ec.unmarshalInputOUIdentifierInput,
		ec.unmarshalInputOrdererConfigBatchSizeInput,
		ec.unmarshalInputOrdererConfigInput,
		ec.unmarshalInputOrdererConfigRaftConsenterInput,
		ec.unmarshalInputOrdererConfigRaftOptionsInput,
		ec.unmarshalInputPolicyInput,
		ec.unmarshalInputRawSignature,
		ec.unmarshalInputRenewOrdererCertificatesInput,
		ec.unmarshalInputRenewPeerCertificatesInput,
		ec.unmarshalInputUpdateCAInput,
		ec.unmarshalInputUpdateChannelInput,
		ec.unmarshalInputUpdateeOrdererInput,
		ec.unmarshalInputUpdateePeerInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schemas/mutation.graphql", Input: `type Mutation {
    createPeer(input: CreatePeerInput!): Peer
    updatePeer(filter: NameAndNamespace!, input: UpdateePeerInput!): Peer

    createOrderer(input: CreateOrdererInput!): Orderer
    updateOrderer(filter: NameAndNamespace!, input: UpdateeOrdererInput!): Orderer

    createCA(input: CreateCAInput!): CA
    updateCA(filter: NameAndNamespace!, input: UpdateCAInput!): CA

    renewPeerCertificates(input: RenewPeerCertificatesInput!): RenewPeerCertificatesResponse!
    renewOrdererCertificates(input: RenewOrdererCertificatesInput!): RenewOrdererCertificatesResponse!

    updateChannel(input: UpdateChannelInput!): UpdateChannelResponse!
    getUpdateChannelBlock(input: GetUpdateChannelBlockInput!): GetUpdateChannelBlockResponse!
}
type GetUpdateChannelBlockResponse {
    errors: [Error!]
    block: String!
    configUpdate: String!
}

input UpdateChannelInput {
    name: String!
    block: String!
    rawSignatures: [RawSignature!]
    mspSignatures: [MSPSignature!]
}
type UpdateChannelResponse {
    errors: [Error!]
    transactionID: String!
}
input RawSignature {
    raw: String!
}
input MSPSignature {
    mspID: String!
}

input GetUpdateChannelBlockInput {
    channelID: String!
    application: ApplicationConfigInput!
    orderer: OrdererConfigInput
    channel: ChannelConfigInput!
}

input OrdererConfigInput {
    batchTimeout: Int
    state: String
    etcdRaft: EtcdRaftInput
    addPolicies: [PolicyInput!]
    addCapabilities: [String!]
    addOrganizations: [ChannelOrganization]
    delOrganizations: [String!]
    batchSize: OrdererConfigBatchSizeInput
}
input ChannelOrganization {
    mspID: String!
    modPolicy: String!
    policies: [PolicyInput!]
    msp: MSPInput!
    anchorPeers: [NetworkAddressInput!]
    ordererEndpoints: [String!]
}
input OrdererConfigBatchSizeInput {
    maxMessageCount: Int!
    absoluteMaxBytes: Int!
    preferredMaxBytes: Int!
}
input MSPInput {
    name: String!
    rootCerts: [String!]
    intermediateCerts: [String!]
    admins: [String!]
    revocationList: [String!]
    ous: [OUIdentifierInput!]
    tlsRootCerts: [String!]
    tlsIntermediateCerts: [String!]
    nodeOUs: NodeOUsInput!
    cryptoConfig: CryptoConfigInput!
}

input NodeOUsInput {
    enable: Boolean!
    clientOUIdentifier: OUIdentifierInput!
    peerOUIdentifier: OUIdentifierInput!
    adminOUIdentifier: OUIdentifierInput!
    ordererOUIdentifier: OUIdentifierInput!
}
input CryptoConfigInput {
    signatureHashFamily: String! = "SHA2"
    identityIdentifierHashFunction: String! = "SHA256"
}
input OUIdentifierInput {
    certificate: String!
    ouIdentifier: String!
}
input EtcdRaftInput {
    addConsenters: [OrdererConfigRaftConsenterInput!]
    delConsenters: [OrdererConfigRaftConsenterInput!]
    options: OrdererConfigRaftOptionsInput
}
input OrdererConfigRaftOptionsInput {
    tickInterval: String!
    electionTick: Int!
    heartbeatTick: Int!
    maxInflightBlocks: Int!
    snapshotIntervalSize: Int!
}
input NetworkAddressInput {
    host: String!
    port: Int!
}
input OrdererConfigRaftConsenterInput {
    address: NetworkAddressInput!
    clientTlsCert: String!
    serverTlsCert: String!
}
input ApplicationConfigInput {
    policies: [PolicyInput!]
    acls: [ChannelACLInput!]
    capabilities: [String!]
    addOrgs: [ChannelOrganization!]
    delOrgs: [String!]
}

input ChannelACLInput {
    key: String!
    value: String!
}
input ChannelConfigInput {
    policies: [PolicyInput!]
    capabilities: [String!]
}
input PolicyInput {
    key: String!
    type: String!
    rule: String!
    modPolicy: String!
}




input RenewOrdererCertificatesInput {
    namespace: String!
    name: String!
    force: Boolean
}
type RenewOrdererCertificatesResponse {
    orderer: Orderer
    errors: [Error!]
}

input RenewPeerCertificatesInput {
    namespace: String!
    name: String!
}
type RenewPeerCertificatesResponse {
    peer: Peer
    errors: [Error!]
}
type Error {
    message: String!
}


input CreatePeerInput {
    yaml: String!
}

input UpdateePeerInput {
    yaml: String!
}

input CreateOrdererInput {
    yaml: String!
}

input UpdateeOrdererInput {
    yaml: String!
}

input CreateCAInput {
    yaml: String!
}

input UpdateCAInput {
    yaml: String!
}


`, BuiltIn: false},
	{Name: "../schemas/query.graphql", Input: `type Query {
    peers: [Peer!] @requiresAuth
    peer(input: NameAndNamespace!): Peer @requiresAuth

    orderers: [Orderer!] @requiresAuth
    orderer(input: NameAndNamespace!): Orderer @requiresAuth

    networkConfigEnabled: Boolean!

    cas: [CA!] @requiresAuth
    ca(input: NameAndNamespace!): CA @requiresAuth
    namespaces: [Namespace!] @requiresAuth
    storageClasses: [StorageClass!] @requiresAuth
    channels: [LightChannel!] @requiresAuth
    channel(channelID: String!): Channel! @requiresAuth
    blocks(
        channelID: String!
        from: Int!
        to: Int!
        reverse: Boolean!
    ): BlocksResponse! @requiresAuth
    block(channelID: String!, blockNumber: Int!): Block! @requiresAuth
    blockWithPrivateData(channelID: String!, blockNumber: Int!): BlockWithPrivateData! @requiresAuth
    blockByTXID(channelID: String!, transactionID: String!): Block! @requiresAuth
}
type StorageClass {
    name: String!
}
type LightChannel {
    name: String!
}
type BlocksResponse {
    height: Int!
    blocks: [Block!]
}

type Block {
    blockNumber: Int!
    dataHash: String!
    numTransactions: Int!
    createdAt: Time!
    transactions: [Transaction!]
}

type BlockWithPrivateData {
    blockNumber: Int!
    dataHash: String!
    numTransactions: Int!
    createdAt: Time!
    transactions: [TransactionWithPrivateData!]
}

enum TransactionType {
    MESSAGE
    CONFIG
    CONFIG_UPDATE
    ENDORSER_TRANSACTION
    ORDERER_TRANSACTION
    DELIVER_SEEK_INFO
    CHAINCODE_PACKAGE
}

type Transaction {
    txID: String!
    type: TransactionType!
    createdAt: Time!
    version: String!
    path: String
    response: String
    request: String
    chaincode: String!
    writes: [TransactionWrite!]
    reads: [TransactionRead!]
}
type PDCReadHash {
    pdcName: String!
    keyHash: String!
    rwSetHash: String!
    version: PDCReadVersion
}
type PDCReadVersion {
    blockNum: Int!
    txNum: Int!
}

type PDCWriteHash {
    pdcName: String!
    keyHash: String!
    rwSetHash: String!
    valueHash: String!
    isDelete: Boolean!
    isPurge: Boolean!
}

type TransactionWithPrivateData {
    txID: String!
    type: TransactionType!
    createdAt: Time!
    version: String!
    path: String
    response: String
    request: String
    chaincode: String!
    writes: [TransactionWrite!]
    reads: [TransactionRead!]

    pdcWrites: [PDCWrite!]
    pdcReads: [PDCRead!]

    pdcWriteHashes: [PDCWriteHash!]
    pdcReadHashes: [PDCReadHash!]
}
type PDCRead {
    collectionName: String!
    key: String!
    block: Int!
    txNum: Int!
}
type PDCWrite {
    collectionName: String!
    deleted: Boolean!
    key: String!
    value: String!
}
type TransactionWrite {
    chaincodeID: String!
    deleted: Boolean!
    key: String!
    value: String!
}
type TransactionRead {
    chaincodeID: String!
    key: String!
    blockNumVersion: Int
    txNumVersion: Int
}

type Namespace {
    name: String!
}
input NameAndNamespace {
    name: String!
    namespace: String!
}

type Peer {
    name: String!
    namespace: String!
    yaml: String!
    storage: PeerStorage
}

type Orderer {
    name: String!
    namespace: String!
    yaml: String!
    storage: OrdererStorage
}

type CA {
    name: String!
    namespace: String!
    yaml: String!
    storage: CAStorage
}

type PeerStorage {
    chaincode: StorageUsage
    couchDB: StorageUsage!
    peer: StorageUsage!
}
type CAStorage {
    ca: StorageUsage!
}
type OrdererStorage {
    orderer: StorageUsage!
}
type StorageUsage {
    used: Int!
    usedGB: String!
    free: Int!
    freeGB: String!
    size: Int!
    sizeGB: String!
    percentageUsed: Float!
}

type Channel {
    name: String!
    rawConfig: String!
    protoConfig: String!
    channelConfig: ChannelConfig!
    application: ApplicationConfig
    orderer: OrdererConfig!
    height: Int!
    chaincodes: [ChannelChaincode!]
    peers: [ChannelPeer!]
}
type ChannelPeer {
    mspID: String!
    url: String!
    height: Int!
}
type ChannelChaincode {
    name: String!
    version: String!
    sequence: Int!
    signaturePolicy: SignaturePolicy!
    endorsementPlugin: String!
    validationPlugin: String!
    configPolicy: String!
    privateDataCollections: [PrivateDataCollection!]
    approvals: [ChaincodeApproval!]
}
type ChaincodeApproval {
    mspID: String!
    approved: Boolean!
}
type PrivateDataCollection {
    name: String!
    requiredPeerCount: Int!
    maxPeerCount: Int!
    blockToLive: Int!
    memberOnlyRead: Boolean!
    memberOnlyWrite: Boolean!
    endorsementPolicy: ApplicationPolicy
    memberOrgsPolicy: SignaturePolicy
}
type SignaturePolicy {
    version: Int!
    rule: SignaturePolicyRule!
    principals: [MSPPrincipal!]
}
type MSPPrincipal {
    combined: MSPPrincipalCombined
    role: MSPPrincipalRole
}
type MSPPrincipalRole {
    mspID: String!
    role: String!
}
type MSPPrincipalCombined {
    classification: String!
    mspPrincipals: [MSPPrincipal!]
}
type SignaturePolicyRule {
    type: String!
    noutOf: SignaturePolicyNOutOf
    signedBy: SignaturePolicySignedBy
}
type ApplicationPolicy {
    channelConfigPolicy: String!
    signaturePolicy: SignaturePolicy
}
type SignaturePolicySignedBy {
    signedBy: Int!
}
type SignaturePolicyNOutOf {
    n: Int!
    rules: [SignaturePolicyRule!]
}


type ChannelConfig {
    policies: [ChannelPolicy!]
    capabilities: [String!]
}
type ApplicationConfig {
    policies: [ChannelPolicy!]
    acls: [ChannelACL!]
    capabilities: [String!]
    organizations: [ChannelOrg!]
}
type ChannelACL {
    key: String!
    value: String!
}
type OrdererConfig {
    type: String!
    batchTimeout: Int!
    batchSize: OrdererConfigBatchSize!
    maxChannels: Int!
    capabilities: [String!]
    state: String!
    policies: [ChannelPolicy!]
    etcdDraft: OrdererConfigRaft!
    organizations: [ChannelOrg!]
}
type ChannelOrg {
    modPolicy: String!
    mspID: String!
    policies: [ChannelPolicy!]
    msp: ChannelMSP!
    ordererEndpoints: [String!]
    anchorPeer: [NetworkAddress!]
    nodeOUs: NodeOUs!
    cryptoConfig: CryptoConfig!
    ous: [OUIdentifier!]
}
type CryptoConfig {
    signatureHashFamily: String!
    identityIdentifierHashFunction: String!
}
type NodeOUs {
    enable: Boolean!
    clientOUIdentifier: OUIdentifier!
    peerOUIdentifier: OUIdentifier!
    adminOUIdentifier: OUIdentifier!
    ordererOUIdentifier: OUIdentifier!
}
type OUIdentifier {
    certificate: String!
    ouIdentifier: String!
}
type ChannelMSP {
    name: String!
    rootCerts: [String!]
    intermediateCerts: [String!]
    admins: [String!]
    revocationList: [String!]
    tlsRootCerts: [String!]
    tlsIntermediateCerts: [String!]
}
type OrdererConfigRaft {
    consenters: [OrdererConfigRaftConsenter!]
    options: OrdererConfigRaftOptions!
}
type OrdererConfigRaftConsenter {
    address: NetworkAddress!
    clientTlsCert: String!
    serverTlsCert: String!
}
type NetworkAddress {
    host: String!
    port: Int!
}
type OrdererConfigRaftOptions {
    tickInterval: String!
    electionTick: Int!
    heartbeatTick: Int!
    maxInflightBlocks: Int!
    snapshotIntervalSize: Int!
}
type ChannelPolicy {
    key: String!
    type: String!
    rule: String!
    modPolicy: String!
}
type OrdererConfigBatchSize {
    maxMessageCount: Int!
    absoluteMaxBytes: Int!
    preferredMaxBytes: Int!
}

type ChannelAnchorPeer {
    mspID: String!
    host: String!
    port: Int!
}

`, BuiltIn: false},
	{Name: "../schemas/schema.graphql", Input: `schema {
    query: Query
    mutation: Mutation
}

directive @requiresAuth on FIELD_DEFINITION

scalar Time
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_createCA_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateCAInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateCAInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCreateCAInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createOrderer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateOrdererInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateOrdererInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCreateOrdererInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createPeer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreatePeerInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreatePeerInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCreatePeerInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_getUpdateChannelBlock_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.GetUpdateChannelBlockInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNGetUpdateChannelBlockInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐGetUpdateChannelBlockInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_renewOrdererCertificates_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.RenewOrdererCertificatesInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNRenewOrdererCertificatesInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐRenewOrdererCertificatesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_renewPeerCertificates_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.RenewPeerCertificatesInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNRenewPeerCertificatesInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐRenewPeerCertificatesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCA_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.NameAndNamespace
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalNNameAndNamespace2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNameAndNamespace(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 models.UpdateCAInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateCAInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐUpdateCAInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateChannel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdateChannelInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateChannelInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐUpdateChannelInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateOrderer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.NameAndNamespace
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalNNameAndNamespace2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNameAndNamespace(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 models.UpdateeOrdererInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateeOrdererInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐUpdateeOrdererInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePeer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.NameAndNamespace
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalNNameAndNamespace2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNameAndNamespace(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 models.UpdateePeerInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateePeerInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐUpdateePeerInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_blockByTXID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["channelID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channelID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["channelID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["transactionID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionID"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["transactionID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_blockWithPrivateData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["channelID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channelID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["channelID"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["blockNumber"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockNumber"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["blockNumber"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_block_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["channelID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channelID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["channelID"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["blockNumber"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockNumber"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["blockNumber"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_blocks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["channelID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channelID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["channelID"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["from"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["from"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["to"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["to"] = arg2
	var arg3 bool
	if tmp, ok := rawArgs["reverse"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reverse"))
		arg3, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reverse"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_ca_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.NameAndNamespace
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNNameAndNamespace2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNameAndNamespace(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_channel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["channelID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channelID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["channelID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_orderer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.NameAndNamespace
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNNameAndNamespace2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNameAndNamespace(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_peer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.NameAndNamespace
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNNameAndNamespace2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNameAndNamespace(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ApplicationConfig_policies(ctx context.Context, field graphql.CollectedField, obj *models.ApplicationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationConfig_policies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Policies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelPolicy)
	fc.Result = res
	return ec.marshalOChannelPolicy2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelPolicyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationConfig_policies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_ChannelPolicy_key(ctx, field)
			case "type":
				return ec.fieldContext_ChannelPolicy_type(ctx, field)
			case "rule":
				return ec.fieldContext_ChannelPolicy_rule(ctx, field)
			case "modPolicy":
				return ec.fieldContext_ChannelPolicy_modPolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationConfig_acls(ctx context.Context, field graphql.CollectedField, obj *models.ApplicationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationConfig_acls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Acls, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelACL)
	fc.Result = res
	return ec.marshalOChannelACL2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelACLᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationConfig_acls(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_ChannelACL_key(ctx, field)
			case "value":
				return ec.fieldContext_ChannelACL_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelACL", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationConfig_capabilities(ctx context.Context, field graphql.CollectedField, obj *models.ApplicationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationConfig_capabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capabilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationConfig_capabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationConfig_organizations(ctx context.Context, field graphql.CollectedField, obj *models.ApplicationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationConfig_organizations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Organizations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelOrg)
	fc.Result = res
	return ec.marshalOChannelOrg2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelOrgᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationConfig_organizations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "modPolicy":
				return ec.fieldContext_ChannelOrg_modPolicy(ctx, field)
			case "mspID":
				return ec.fieldContext_ChannelOrg_mspID(ctx, field)
			case "policies":
				return ec.fieldContext_ChannelOrg_policies(ctx, field)
			case "msp":
				return ec.fieldContext_ChannelOrg_msp(ctx, field)
			case "ordererEndpoints":
				return ec.fieldContext_ChannelOrg_ordererEndpoints(ctx, field)
			case "anchorPeer":
				return ec.fieldContext_ChannelOrg_anchorPeer(ctx, field)
			case "nodeOUs":
				return ec.fieldContext_ChannelOrg_nodeOUs(ctx, field)
			case "cryptoConfig":
				return ec.fieldContext_ChannelOrg_cryptoConfig(ctx, field)
			case "ous":
				return ec.fieldContext_ChannelOrg_ous(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelOrg", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationPolicy_channelConfigPolicy(ctx context.Context, field graphql.CollectedField, obj *models.ApplicationPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationPolicy_channelConfigPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChannelConfigPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationPolicy_channelConfigPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationPolicy_signaturePolicy(ctx context.Context, field graphql.CollectedField, obj *models.ApplicationPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationPolicy_signaturePolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignaturePolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SignaturePolicy)
	fc.Result = res
	return ec.marshalOSignaturePolicy2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐSignaturePolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationPolicy_signaturePolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_SignaturePolicy_version(ctx, field)
			case "rule":
				return ec.fieldContext_SignaturePolicy_rule(ctx, field)
			case "principals":
				return ec.fieldContext_SignaturePolicy_principals(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignaturePolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_blockNumber(ctx context.Context, field graphql.CollectedField, obj *models.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_blockNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_blockNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_dataHash(ctx context.Context, field graphql.CollectedField, obj *models.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_dataHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_dataHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_numTransactions(ctx context.Context, field graphql.CollectedField, obj *models.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_numTransactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumTransactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_numTransactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_transactions(ctx context.Context, field graphql.CollectedField, obj *models.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_transactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Transaction)
	fc.Result = res
	return ec.marshalOTransaction2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_transactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "txID":
				return ec.fieldContext_Transaction_txID(ctx, field)
			case "type":
				return ec.fieldContext_Transaction_type(ctx, field)
			case "createdAt":
				return ec.fieldContext_Transaction_createdAt(ctx, field)
			case "version":
				return ec.fieldContext_Transaction_version(ctx, field)
			case "path":
				return ec.fieldContext_Transaction_path(ctx, field)
			case "response":
				return ec.fieldContext_Transaction_response(ctx, field)
			case "request":
				return ec.fieldContext_Transaction_request(ctx, field)
			case "chaincode":
				return ec.fieldContext_Transaction_chaincode(ctx, field)
			case "writes":
				return ec.fieldContext_Transaction_writes(ctx, field)
			case "reads":
				return ec.fieldContext_Transaction_reads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockWithPrivateData_blockNumber(ctx context.Context, field graphql.CollectedField, obj *models.BlockWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockWithPrivateData_blockNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockWithPrivateData_blockNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockWithPrivateData_dataHash(ctx context.Context, field graphql.CollectedField, obj *models.BlockWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockWithPrivateData_dataHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockWithPrivateData_dataHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockWithPrivateData_numTransactions(ctx context.Context, field graphql.CollectedField, obj *models.BlockWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockWithPrivateData_numTransactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumTransactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockWithPrivateData_numTransactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockWithPrivateData_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.BlockWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockWithPrivateData_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockWithPrivateData_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockWithPrivateData_transactions(ctx context.Context, field graphql.CollectedField, obj *models.BlockWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockWithPrivateData_transactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.TransactionWithPrivateData)
	fc.Result = res
	return ec.marshalOTransactionWithPrivateData2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionWithPrivateDataᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockWithPrivateData_transactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "txID":
				return ec.fieldContext_TransactionWithPrivateData_txID(ctx, field)
			case "type":
				return ec.fieldContext_TransactionWithPrivateData_type(ctx, field)
			case "createdAt":
				return ec.fieldContext_TransactionWithPrivateData_createdAt(ctx, field)
			case "version":
				return ec.fieldContext_TransactionWithPrivateData_version(ctx, field)
			case "path":
				return ec.fieldContext_TransactionWithPrivateData_path(ctx, field)
			case "response":
				return ec.fieldContext_TransactionWithPrivateData_response(ctx, field)
			case "request":
				return ec.fieldContext_TransactionWithPrivateData_request(ctx, field)
			case "chaincode":
				return ec.fieldContext_TransactionWithPrivateData_chaincode(ctx, field)
			case "writes":
				return ec.fieldContext_TransactionWithPrivateData_writes(ctx, field)
			case "reads":
				return ec.fieldContext_TransactionWithPrivateData_reads(ctx, field)
			case "pdcWrites":
				return ec.fieldContext_TransactionWithPrivateData_pdcWrites(ctx, field)
			case "pdcReads":
				return ec.fieldContext_TransactionWithPrivateData_pdcReads(ctx, field)
			case "pdcWriteHashes":
				return ec.fieldContext_TransactionWithPrivateData_pdcWriteHashes(ctx, field)
			case "pdcReadHashes":
				return ec.fieldContext_TransactionWithPrivateData_pdcReadHashes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionWithPrivateData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlocksResponse_height(ctx context.Context, field graphql.CollectedField, obj *models.BlocksResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlocksResponse_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlocksResponse_height(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlocksResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlocksResponse_blocks(ctx context.Context, field graphql.CollectedField, obj *models.BlocksResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlocksResponse_blocks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Blocks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Block)
	fc.Result = res
	return ec.marshalOBlock2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐBlockᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlocksResponse_blocks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlocksResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "blockNumber":
				return ec.fieldContext_Block_blockNumber(ctx, field)
			case "dataHash":
				return ec.fieldContext_Block_dataHash(ctx, field)
			case "numTransactions":
				return ec.fieldContext_Block_numTransactions(ctx, field)
			case "createdAt":
				return ec.fieldContext_Block_createdAt(ctx, field)
			case "transactions":
				return ec.fieldContext_Block_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Block", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CA_name(ctx context.Context, field graphql.CollectedField, obj *models.Ca) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CA_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CA_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CA_namespace(ctx context.Context, field graphql.CollectedField, obj *models.Ca) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CA_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CA_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CA_yaml(ctx context.Context, field graphql.CollectedField, obj *models.Ca) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CA_yaml(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Yaml, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CA_yaml(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CA_storage(ctx context.Context, field graphql.CollectedField, obj *models.Ca) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CA_storage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CA().Storage(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.CAStorage)
	fc.Result = res
	return ec.marshalOCAStorage2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCAStorage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CA_storage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CA",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ca":
				return ec.fieldContext_CAStorage_ca(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CAStorage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CAStorage_ca(ctx context.Context, field graphql.CollectedField, obj *models.CAStorage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CAStorage_ca(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ca, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.StorageUsage)
	fc.Result = res
	return ec.marshalNStorageUsage2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐStorageUsage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CAStorage_ca(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CAStorage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "used":
				return ec.fieldContext_StorageUsage_used(ctx, field)
			case "usedGB":
				return ec.fieldContext_StorageUsage_usedGB(ctx, field)
			case "free":
				return ec.fieldContext_StorageUsage_free(ctx, field)
			case "freeGB":
				return ec.fieldContext_StorageUsage_freeGB(ctx, field)
			case "size":
				return ec.fieldContext_StorageUsage_size(ctx, field)
			case "sizeGB":
				return ec.fieldContext_StorageUsage_sizeGB(ctx, field)
			case "percentageUsed":
				return ec.fieldContext_StorageUsage_percentageUsed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StorageUsage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChaincodeApproval_mspID(ctx context.Context, field graphql.CollectedField, obj *models.ChaincodeApproval) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChaincodeApproval_mspID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MspID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChaincodeApproval_mspID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChaincodeApproval",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChaincodeApproval_approved(ctx context.Context, field graphql.CollectedField, obj *models.ChaincodeApproval) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChaincodeApproval_approved(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Approved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChaincodeApproval_approved(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChaincodeApproval",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_name(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_rawConfig(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_rawConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RawConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_rawConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_protoConfig(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_protoConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProtoConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_protoConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_channelConfig(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_channelConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChannelConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.ChannelConfig)
	fc.Result = res
	return ec.marshalNChannelConfig2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_channelConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "policies":
				return ec.fieldContext_ChannelConfig_policies(ctx, field)
			case "capabilities":
				return ec.fieldContext_ChannelConfig_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_application(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_application(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Application, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ApplicationConfig)
	fc.Result = res
	return ec.marshalOApplicationConfig2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐApplicationConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_application(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "policies":
				return ec.fieldContext_ApplicationConfig_policies(ctx, field)
			case "acls":
				return ec.fieldContext_ApplicationConfig_acls(ctx, field)
			case "capabilities":
				return ec.fieldContext_ApplicationConfig_capabilities(ctx, field)
			case "organizations":
				return ec.fieldContext_ApplicationConfig_organizations(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_orderer(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_orderer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Orderer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OrdererConfig)
	fc.Result = res
	return ec.marshalNOrdererConfig2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_orderer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_OrdererConfig_type(ctx, field)
			case "batchTimeout":
				return ec.fieldContext_OrdererConfig_batchTimeout(ctx, field)
			case "batchSize":
				return ec.fieldContext_OrdererConfig_batchSize(ctx, field)
			case "maxChannels":
				return ec.fieldContext_OrdererConfig_maxChannels(ctx, field)
			case "capabilities":
				return ec.fieldContext_OrdererConfig_capabilities(ctx, field)
			case "state":
				return ec.fieldContext_OrdererConfig_state(ctx, field)
			case "policies":
				return ec.fieldContext_OrdererConfig_policies(ctx, field)
			case "etcdDraft":
				return ec.fieldContext_OrdererConfig_etcdDraft(ctx, field)
			case "organizations":
				return ec.fieldContext_OrdererConfig_organizations(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrdererConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_height(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_height(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_chaincodes(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_chaincodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Channel().Chaincodes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelChaincode)
	fc.Result = res
	return ec.marshalOChannelChaincode2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelChaincodeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_chaincodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ChannelChaincode_name(ctx, field)
			case "version":
				return ec.fieldContext_ChannelChaincode_version(ctx, field)
			case "sequence":
				return ec.fieldContext_ChannelChaincode_sequence(ctx, field)
			case "signaturePolicy":
				return ec.fieldContext_ChannelChaincode_signaturePolicy(ctx, field)
			case "endorsementPlugin":
				return ec.fieldContext_ChannelChaincode_endorsementPlugin(ctx, field)
			case "validationPlugin":
				return ec.fieldContext_ChannelChaincode_validationPlugin(ctx, field)
			case "configPolicy":
				return ec.fieldContext_ChannelChaincode_configPolicy(ctx, field)
			case "privateDataCollections":
				return ec.fieldContext_ChannelChaincode_privateDataCollections(ctx, field)
			case "approvals":
				return ec.fieldContext_ChannelChaincode_approvals(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelChaincode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_peers(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_peers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Channel().Peers(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelPeer)
	fc.Result = res
	return ec.marshalOChannelPeer2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelPeerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_peers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mspID":
				return ec.fieldContext_ChannelPeer_mspID(ctx, field)
			case "url":
				return ec.fieldContext_ChannelPeer_url(ctx, field)
			case "height":
				return ec.fieldContext_ChannelPeer_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelPeer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelACL_key(ctx context.Context, field graphql.CollectedField, obj *models.ChannelACL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelACL_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelACL_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelACL",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelACL_value(ctx context.Context, field graphql.CollectedField, obj *models.ChannelACL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelACL_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelACL_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelACL",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelAnchorPeer_mspID(ctx context.Context, field graphql.CollectedField, obj *models.ChannelAnchorPeer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelAnchorPeer_mspID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MspID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelAnchorPeer_mspID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelAnchorPeer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelAnchorPeer_host(ctx context.Context, field graphql.CollectedField, obj *models.ChannelAnchorPeer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelAnchorPeer_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelAnchorPeer_host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelAnchorPeer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelAnchorPeer_port(ctx context.Context, field graphql.CollectedField, obj *models.ChannelAnchorPeer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelAnchorPeer_port(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelAnchorPeer_port(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelAnchorPeer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_name(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_version(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_sequence(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_sequence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sequence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_sequence(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_signaturePolicy(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_signaturePolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignaturePolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.SignaturePolicy)
	fc.Result = res
	return ec.marshalNSignaturePolicy2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐSignaturePolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_signaturePolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_SignaturePolicy_version(ctx, field)
			case "rule":
				return ec.fieldContext_SignaturePolicy_rule(ctx, field)
			case "principals":
				return ec.fieldContext_SignaturePolicy_principals(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignaturePolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_endorsementPlugin(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_endorsementPlugin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndorsementPlugin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_endorsementPlugin(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_validationPlugin(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_validationPlugin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidationPlugin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_validationPlugin(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_configPolicy(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_configPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_configPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_privateDataCollections(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_privateDataCollections(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrivateDataCollections, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.PrivateDataCollection)
	fc.Result = res
	return ec.marshalOPrivateDataCollection2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPrivateDataCollectionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_privateDataCollections(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_PrivateDataCollection_name(ctx, field)
			case "requiredPeerCount":
				return ec.fieldContext_PrivateDataCollection_requiredPeerCount(ctx, field)
			case "maxPeerCount":
				return ec.fieldContext_PrivateDataCollection_maxPeerCount(ctx, field)
			case "blockToLive":
				return ec.fieldContext_PrivateDataCollection_blockToLive(ctx, field)
			case "memberOnlyRead":
				return ec.fieldContext_PrivateDataCollection_memberOnlyRead(ctx, field)
			case "memberOnlyWrite":
				return ec.fieldContext_PrivateDataCollection_memberOnlyWrite(ctx, field)
			case "endorsementPolicy":
				return ec.fieldContext_PrivateDataCollection_endorsementPolicy(ctx, field)
			case "memberOrgsPolicy":
				return ec.fieldContext_PrivateDataCollection_memberOrgsPolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PrivateDataCollection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_approvals(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_approvals(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Approvals, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChaincodeApproval)
	fc.Result = res
	return ec.marshalOChaincodeApproval2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChaincodeApprovalᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_approvals(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mspID":
				return ec.fieldContext_ChaincodeApproval_mspID(ctx, field)
			case "approved":
				return ec.fieldContext_ChaincodeApproval_approved(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChaincodeApproval", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelConfig_policies(ctx context.Context, field graphql.CollectedField, obj *models.ChannelConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelConfig_policies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Policies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelPolicy)
	fc.Result = res
	return ec.marshalOChannelPolicy2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelPolicyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelConfig_policies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_ChannelPolicy_key(ctx, field)
			case "type":
				return ec.fieldContext_ChannelPolicy_type(ctx, field)
			case "rule":
				return ec.fieldContext_ChannelPolicy_rule(ctx, field)
			case "modPolicy":
				return ec.fieldContext_ChannelPolicy_modPolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelConfig_capabilities(ctx context.Context, field graphql.CollectedField, obj *models.ChannelConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelConfig_capabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capabilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelConfig_capabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMSP_name(ctx context.Context, field graphql.CollectedField, obj *models.ChannelMsp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelMSP_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelMSP_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMSP",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMSP_rootCerts(ctx context.Context, field graphql.CollectedField, obj *models.ChannelMsp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelMSP_rootCerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootCerts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelMSP_rootCerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMSP",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMSP_intermediateCerts(ctx context.Context, field graphql.CollectedField, obj *models.ChannelMsp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelMSP_intermediateCerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IntermediateCerts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelMSP_intermediateCerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMSP",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMSP_admins(ctx context.Context, field graphql.CollectedField, obj *models.ChannelMsp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelMSP_admins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Admins, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelMSP_admins(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMSP",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMSP_revocationList(ctx context.Context, field graphql.CollectedField, obj *models.ChannelMsp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelMSP_revocationList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RevocationList, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelMSP_revocationList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMSP",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMSP_tlsRootCerts(ctx context.Context, field graphql.CollectedField, obj *models.ChannelMsp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelMSP_tlsRootCerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TLSRootCerts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelMSP_tlsRootCerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMSP",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMSP_tlsIntermediateCerts(ctx context.Context, field graphql.CollectedField, obj *models.ChannelMsp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelMSP_tlsIntermediateCerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TLSIntermediateCerts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelMSP_tlsIntermediateCerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMSP",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_modPolicy(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_modPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_modPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_mspID(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_mspID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MspID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_mspID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_policies(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_policies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Policies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelPolicy)
	fc.Result = res
	return ec.marshalOChannelPolicy2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelPolicyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_policies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_ChannelPolicy_key(ctx, field)
			case "type":
				return ec.fieldContext_ChannelPolicy_type(ctx, field)
			case "rule":
				return ec.fieldContext_ChannelPolicy_rule(ctx, field)
			case "modPolicy":
				return ec.fieldContext_ChannelPolicy_modPolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_msp(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_msp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Msp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.ChannelMsp)
	fc.Result = res
	return ec.marshalNChannelMSP2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelMsp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_msp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ChannelMSP_name(ctx, field)
			case "rootCerts":
				return ec.fieldContext_ChannelMSP_rootCerts(ctx, field)
			case "intermediateCerts":
				return ec.fieldContext_ChannelMSP_intermediateCerts(ctx, field)
			case "admins":
				return ec.fieldContext_ChannelMSP_admins(ctx, field)
			case "revocationList":
				return ec.fieldContext_ChannelMSP_revocationList(ctx, field)
			case "tlsRootCerts":
				return ec.fieldContext_ChannelMSP_tlsRootCerts(ctx, field)
			case "tlsIntermediateCerts":
				return ec.fieldContext_ChannelMSP_tlsIntermediateCerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelMSP", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_ordererEndpoints(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_ordererEndpoints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrdererEndpoints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_ordererEndpoints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_anchorPeer(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_anchorPeer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnchorPeer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.NetworkAddress)
	fc.Result = res
	return ec.marshalONetworkAddress2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNetworkAddressᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_anchorPeer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "host":
				return ec.fieldContext_NetworkAddress_host(ctx, field)
			case "port":
				return ec.fieldContext_NetworkAddress_port(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NetworkAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_nodeOUs(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_nodeOUs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NodeOUs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.NodeOUs)
	fc.Result = res
	return ec.marshalNNodeOUs2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNodeOUs(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_nodeOUs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "enable":
				return ec.fieldContext_NodeOUs_enable(ctx, field)
			case "clientOUIdentifier":
				return ec.fieldContext_NodeOUs_clientOUIdentifier(ctx, field)
			case "peerOUIdentifier":
				return ec.fieldContext_NodeOUs_peerOUIdentifier(ctx, field)
			case "adminOUIdentifier":
				return ec.fieldContext_NodeOUs_adminOUIdentifier(ctx, field)
			case "ordererOUIdentifier":
				return ec.fieldContext_NodeOUs_ordererOUIdentifier(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeOUs", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_cryptoConfig(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_cryptoConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CryptoConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.CryptoConfig)
	fc.Result = res
	return ec.marshalNCryptoConfig2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCryptoConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_cryptoConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "signatureHashFamily":
				return ec.fieldContext_CryptoConfig_signatureHashFamily(ctx, field)
			case "identityIdentifierHashFunction":
				return ec.fieldContext_CryptoConfig_identityIdentifierHashFunction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CryptoConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_ous(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_ous(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ous, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.OUIdentifier)
	fc.Result = res
	return ec.marshalOOUIdentifier2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOUIdentifierᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_ous(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "certificate":
				return ec.fieldContext_OUIdentifier_certificate(ctx, field)
			case "ouIdentifier":
				return ec.fieldContext_OUIdentifier_ouIdentifier(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OUIdentifier", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelPeer_mspID(ctx context.Context, field graphql.CollectedField, obj *models.ChannelPeer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelPeer_mspID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MspID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelPeer_mspID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelPeer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelPeer_url(ctx context.Context, field graphql.CollectedField, obj *models.ChannelPeer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelPeer_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelPeer_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelPeer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelPeer_height(ctx context.Context, field graphql.CollectedField, obj *models.ChannelPeer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelPeer_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelPeer_height(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelPeer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelPolicy_key(ctx context.Context, field graphql.CollectedField, obj *models.ChannelPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelPolicy_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelPolicy_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelPolicy_type(ctx context.Context, field graphql.CollectedField, obj *models.ChannelPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelPolicy_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelPolicy_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelPolicy_rule(ctx context.Context, field graphql.CollectedField, obj *models.ChannelPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelPolicy_rule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelPolicy_rule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelPolicy_modPolicy(ctx context.Context, field graphql.CollectedField, obj *models.ChannelPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelPolicy_modPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelPolicy_modPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CryptoConfig_signatureHashFamily(ctx context.Context, field graphql.CollectedField, obj *models.CryptoConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CryptoConfig_signatureHashFamily(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignatureHashFamily, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CryptoConfig_signatureHashFamily(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CryptoConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CryptoConfig_identityIdentifierHashFunction(ctx context.Context, field graphql.CollectedField, obj *models.CryptoConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CryptoConfig_identityIdentifierHashFunction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IdentityIdentifierHashFunction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CryptoConfig_identityIdentifierHashFunction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CryptoConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Error_message(ctx context.Context, field graphql.CollectedField, obj *models.Error) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Error_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Error_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Error",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetUpdateChannelBlockResponse_errors(ctx context.Context, field graphql.CollectedField, obj *models.GetUpdateChannelBlockResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetUpdateChannelBlockResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Error)
	fc.Result = res
	return ec.marshalOError2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐErrorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetUpdateChannelBlockResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetUpdateChannelBlockResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_Error_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Error", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetUpdateChannelBlockResponse_block(ctx context.Context, field graphql.CollectedField, obj *models.GetUpdateChannelBlockResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetUpdateChannelBlockResponse_block(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Block, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetUpdateChannelBlockResponse_block(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetUpdateChannelBlockResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetUpdateChannelBlockResponse_configUpdate(ctx context.Context, field graphql.CollectedField, obj *models.GetUpdateChannelBlockResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetUpdateChannelBlockResponse_configUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigUpdate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetUpdateChannelBlockResponse_configUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetUpdateChannelBlockResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LightChannel_name(ctx context.Context, field graphql.CollectedField, obj *models.LightChannel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LightChannel_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LightChannel_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LightChannel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MSPPrincipal_combined(ctx context.Context, field graphql.CollectedField, obj *models.MSPPrincipal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MSPPrincipal_combined(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Combined, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MSPPrincipalCombined)
	fc.Result = res
	return ec.marshalOMSPPrincipalCombined2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐMSPPrincipalCombined(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MSPPrincipal_combined(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MSPPrincipal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "classification":
				return ec.fieldContext_MSPPrincipalCombined_classification(ctx, field)
			case "mspPrincipals":
				return ec.fieldContext_MSPPrincipalCombined_mspPrincipals(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MSPPrincipalCombined", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MSPPrincipal_role(ctx context.Context, field graphql.CollectedField, obj *models.MSPPrincipal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MSPPrincipal_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MSPPrincipalRole)
	fc.Result = res
	return ec.marshalOMSPPrincipalRole2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐMSPPrincipalRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MSPPrincipal_role(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MSPPrincipal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mspID":
				return ec.fieldContext_MSPPrincipalRole_mspID(ctx, field)
			case "role":
				return ec.fieldContext_MSPPrincipalRole_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MSPPrincipalRole", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MSPPrincipalCombined_classification(ctx context.Context, field graphql.CollectedField, obj *models.MSPPrincipalCombined) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MSPPrincipalCombined_classification(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Classification, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MSPPrincipalCombined_classification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MSPPrincipalCombined",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MSPPrincipalCombined_mspPrincipals(ctx context.Context, field graphql.CollectedField, obj *models.MSPPrincipalCombined) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MSPPrincipalCombined_mspPrincipals(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MspPrincipals, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.MSPPrincipal)
	fc.Result = res
	return ec.marshalOMSPPrincipal2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐMSPPrincipalᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MSPPrincipalCombined_mspPrincipals(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MSPPrincipalCombined",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "combined":
				return ec.fieldContext_MSPPrincipal_combined(ctx, field)
			case "role":
				return ec.fieldContext_MSPPrincipal_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MSPPrincipal", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MSPPrincipalRole_mspID(ctx context.Context, field graphql.CollectedField, obj *models.MSPPrincipalRole) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MSPPrincipalRole_mspID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MspID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MSPPrincipalRole_mspID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MSPPrincipalRole",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MSPPrincipalRole_role(ctx context.Context, field graphql.CollectedField, obj *models.MSPPrincipalRole) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MSPPrincipalRole_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MSPPrincipalRole_role(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MSPPrincipalRole",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createPeer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createPeer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePeer(rctx, fc.Args["input"].(models.CreatePeerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Peer)
	fc.Result = res
	return ec.marshalOPeer2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPeer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createPeer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Peer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Peer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Peer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Peer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Peer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createPeer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updatePeer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updatePeer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePeer(rctx, fc.Args["filter"].(models.NameAndNamespace), fc.Args["input"].(models.UpdateePeerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Peer)
	fc.Result = res
	return ec.marshalOPeer2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPeer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updatePeer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Peer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Peer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Peer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Peer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Peer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updatePeer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createOrderer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createOrderer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateOrderer(rctx, fc.Args["input"].(models.CreateOrdererInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Orderer)
	fc.Result = res
	return ec.marshalOOrderer2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrderer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createOrderer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Orderer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Orderer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Orderer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Orderer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Orderer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createOrderer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateOrderer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateOrderer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateOrderer(rctx, fc.Args["filter"].(models.NameAndNamespace), fc.Args["input"].(models.UpdateeOrdererInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Orderer)
	fc.Result = res
	return ec.marshalOOrderer2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrderer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateOrderer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Orderer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Orderer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Orderer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Orderer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Orderer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateOrderer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createCA(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createCA(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateCa(rctx, fc.Args["input"].(models.CreateCAInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Ca)
	fc.Result = res
	return ec.marshalOCA2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCa(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createCA(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_CA_name(ctx, field)
			case "namespace":
				return ec.fieldContext_CA_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_CA_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_CA_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CA", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createCA_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateCA(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateCA(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateCa(rctx, fc.Args["filter"].(models.NameAndNamespace), fc.Args["input"].(models.UpdateCAInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Ca)
	fc.Result = res
	return ec.marshalOCA2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCa(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateCA(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_CA_name(ctx, field)
			case "namespace":
				return ec.fieldContext_CA_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_CA_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_CA_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CA", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateCA_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_renewPeerCertificates(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_renewPeerCertificates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RenewPeerCertificates(rctx, fc.Args["input"].(models.RenewPeerCertificatesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.RenewPeerCertificatesResponse)
	fc.Result = res
	return ec.marshalNRenewPeerCertificatesResponse2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐRenewPeerCertificatesResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_renewPeerCertificates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "peer":
				return ec.fieldContext_RenewPeerCertificatesResponse_peer(ctx, field)
			case "errors":
				return ec.fieldContext_RenewPeerCertificatesResponse_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RenewPeerCertificatesResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_renewPeerCertificates_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_renewOrdererCertificates(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_renewOrdererCertificates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RenewOrdererCertificates(rctx, fc.Args["input"].(models.RenewOrdererCertificatesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.RenewOrdererCertificatesResponse)
	fc.Result = res
	return ec.marshalNRenewOrdererCertificatesResponse2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐRenewOrdererCertificatesResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_renewOrdererCertificates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "orderer":
				return ec.fieldContext_RenewOrdererCertificatesResponse_orderer(ctx, field)
			case "errors":
				return ec.fieldContext_RenewOrdererCertificatesResponse_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RenewOrdererCertificatesResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_renewOrdererCertificates_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateChannel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateChannel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateChannel(rctx, fc.Args["input"].(models.UpdateChannelInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.UpdateChannelResponse)
	fc.Result = res
	return ec.marshalNUpdateChannelResponse2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐUpdateChannelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateChannel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_UpdateChannelResponse_errors(ctx, field)
			case "transactionID":
				return ec.fieldContext_UpdateChannelResponse_transactionID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateChannelResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateChannel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_getUpdateChannelBlock(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_getUpdateChannelBlock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GetUpdateChannelBlock(rctx, fc.Args["input"].(models.GetUpdateChannelBlockInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.GetUpdateChannelBlockResponse)
	fc.Result = res
	return ec.marshalNGetUpdateChannelBlockResponse2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐGetUpdateChannelBlockResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_getUpdateChannelBlock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_GetUpdateChannelBlockResponse_errors(ctx, field)
			case "block":
				return ec.fieldContext_GetUpdateChannelBlockResponse_block(ctx, field)
			case "configUpdate":
				return ec.fieldContext_GetUpdateChannelBlockResponse_configUpdate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetUpdateChannelBlockResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_getUpdateChannelBlock_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Namespace_name(ctx context.Context, field graphql.CollectedField, obj *models.Namespace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Namespace_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Namespace_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Namespace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkAddress_host(ctx context.Context, field graphql.CollectedField, obj *models.NetworkAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkAddress_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkAddress_host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkAddress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkAddress_port(ctx context.Context, field graphql.CollectedField, obj *models.NetworkAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkAddress_port(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkAddress_port(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkAddress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeOUs_enable(ctx context.Context, field graphql.CollectedField, obj *models.NodeOUs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeOUs_enable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeOUs_enable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeOUs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeOUs_clientOUIdentifier(ctx context.Context, field graphql.CollectedField, obj *models.NodeOUs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeOUs_clientOUIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientOUIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OUIdentifier)
	fc.Result = res
	return ec.marshalNOUIdentifier2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOUIdentifier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeOUs_clientOUIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeOUs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "certificate":
				return ec.fieldContext_OUIdentifier_certificate(ctx, field)
			case "ouIdentifier":
				return ec.fieldContext_OUIdentifier_ouIdentifier(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OUIdentifier", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeOUs_peerOUIdentifier(ctx context.Context, field graphql.CollectedField, obj *models.NodeOUs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeOUs_peerOUIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PeerOUIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OUIdentifier)
	fc.Result = res
	return ec.marshalNOUIdentifier2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOUIdentifier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeOUs_peerOUIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeOUs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "certificate":
				return ec.fieldContext_OUIdentifier_certificate(ctx, field)
			case "ouIdentifier":
				return ec.fieldContext_OUIdentifier_ouIdentifier(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OUIdentifier", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeOUs_adminOUIdentifier(ctx context.Context, field graphql.CollectedField, obj *models.NodeOUs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeOUs_adminOUIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdminOUIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OUIdentifier)
	fc.Result = res
	return ec.marshalNOUIdentifier2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOUIdentifier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeOUs_adminOUIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeOUs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "certificate":
				return ec.fieldContext_OUIdentifier_certificate(ctx, field)
			case "ouIdentifier":
				return ec.fieldContext_OUIdentifier_ouIdentifier(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OUIdentifier", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeOUs_ordererOUIdentifier(ctx context.Context, field graphql.CollectedField, obj *models.NodeOUs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeOUs_ordererOUIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrdererOUIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OUIdentifier)
	fc.Result = res
	return ec.marshalNOUIdentifier2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOUIdentifier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeOUs_ordererOUIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeOUs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "certificate":
				return ec.fieldContext_OUIdentifier_certificate(ctx, field)
			case "ouIdentifier":
				return ec.fieldContext_OUIdentifier_ouIdentifier(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OUIdentifier", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OUIdentifier_certificate(ctx context.Context, field graphql.CollectedField, obj *models.OUIdentifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OUIdentifier_certificate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Certificate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OUIdentifier_certificate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OUIdentifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OUIdentifier_ouIdentifier(ctx context.Context, field graphql.CollectedField, obj *models.OUIdentifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OUIdentifier_ouIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OuIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OUIdentifier_ouIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OUIdentifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Orderer_name(ctx context.Context, field graphql.CollectedField, obj *models.Orderer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Orderer_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Orderer_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Orderer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Orderer_namespace(ctx context.Context, field graphql.CollectedField, obj *models.Orderer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Orderer_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Orderer_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Orderer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Orderer_yaml(ctx context.Context, field graphql.CollectedField, obj *models.Orderer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Orderer_yaml(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Yaml, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Orderer_yaml(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Orderer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Orderer_storage(ctx context.Context, field graphql.CollectedField, obj *models.Orderer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Orderer_storage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Orderer().Storage(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.OrdererStorage)
	fc.Result = res
	return ec.marshalOOrdererStorage2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererStorage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Orderer_storage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Orderer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "orderer":
				return ec.fieldContext_OrdererStorage_orderer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrdererStorage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_type(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_batchTimeout(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_batchTimeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BatchTimeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_batchTimeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_batchSize(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_batchSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BatchSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OrdererConfigBatchSize)
	fc.Result = res
	return ec.marshalNOrdererConfigBatchSize2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigBatchSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_batchSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "maxMessageCount":
				return ec.fieldContext_OrdererConfigBatchSize_maxMessageCount(ctx, field)
			case "absoluteMaxBytes":
				return ec.fieldContext_OrdererConfigBatchSize_absoluteMaxBytes(ctx, field)
			case "preferredMaxBytes":
				return ec.fieldContext_OrdererConfigBatchSize_preferredMaxBytes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrdererConfigBatchSize", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_maxChannels(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_maxChannels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxChannels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_maxChannels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_capabilities(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_capabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capabilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_capabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_state(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_policies(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_policies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Policies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelPolicy)
	fc.Result = res
	return ec.marshalOChannelPolicy2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelPolicyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_policies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_ChannelPolicy_key(ctx, field)
			case "type":
				return ec.fieldContext_ChannelPolicy_type(ctx, field)
			case "rule":
				return ec.fieldContext_ChannelPolicy_rule(ctx, field)
			case "modPolicy":
				return ec.fieldContext_ChannelPolicy_modPolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_etcdDraft(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_etcdDraft(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EtcdDraft, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OrdererConfigRaft)
	fc.Result = res
	return ec.marshalNOrdererConfigRaft2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigRaft(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_etcdDraft(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "consenters":
				return ec.fieldContext_OrdererConfigRaft_consenters(ctx, field)
			case "options":
				return ec.fieldContext_OrdererConfigRaft_options(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrdererConfigRaft", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_organizations(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_organizations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Organizations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelOrg)
	fc.Result = res
	return ec.marshalOChannelOrg2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelOrgᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_organizations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "modPolicy":
				return ec.fieldContext_ChannelOrg_modPolicy(ctx, field)
			case "mspID":
				return ec.fieldContext_ChannelOrg_mspID(ctx, field)
			case "policies":
				return ec.fieldContext_ChannelOrg_policies(ctx, field)
			case "msp":
				return ec.fieldContext_ChannelOrg_msp(ctx, field)
			case "ordererEndpoints":
				return ec.fieldContext_ChannelOrg_ordererEndpoints(ctx, field)
			case "anchorPeer":
				return ec.fieldContext_ChannelOrg_anchorPeer(ctx, field)
			case "nodeOUs":
				return ec.fieldContext_ChannelOrg_nodeOUs(ctx, field)
			case "cryptoConfig":
				return ec.fieldContext_ChannelOrg_cryptoConfig(ctx, field)
			case "ous":
				return ec.fieldContext_ChannelOrg_ous(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelOrg", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigBatchSize_maxMessageCount(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigBatchSize) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigBatchSize_maxMessageCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxMessageCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigBatchSize_maxMessageCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigBatchSize",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigBatchSize_absoluteMaxBytes(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigBatchSize) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigBatchSize_absoluteMaxBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbsoluteMaxBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigBatchSize_absoluteMaxBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigBatchSize",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigBatchSize_preferredMaxBytes(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigBatchSize) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigBatchSize_preferredMaxBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreferredMaxBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigBatchSize_preferredMaxBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigBatchSize",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaft_consenters(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaft_consenters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Consenters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.OrdererConfigRaftConsenter)
	fc.Result = res
	return ec.marshalOOrdererConfigRaftConsenter2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigRaftConsenterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaft_consenters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_OrdererConfigRaftConsenter_address(ctx, field)
			case "clientTlsCert":
				return ec.fieldContext_OrdererConfigRaftConsenter_clientTlsCert(ctx, field)
			case "serverTlsCert":
				return ec.fieldContext_OrdererConfigRaftConsenter_serverTlsCert(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrdererConfigRaftConsenter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaft_options(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaft_options(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Options, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OrdererConfigRaftOptions)
	fc.Result = res
	return ec.marshalNOrdererConfigRaftOptions2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigRaftOptions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaft_options(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tickInterval":
				return ec.fieldContext_OrdererConfigRaftOptions_tickInterval(ctx, field)
			case "electionTick":
				return ec.fieldContext_OrdererConfigRaftOptions_electionTick(ctx, field)
			case "heartbeatTick":
				return ec.fieldContext_OrdererConfigRaftOptions_heartbeatTick(ctx, field)
			case "maxInflightBlocks":
				return ec.fieldContext_OrdererConfigRaftOptions_maxInflightBlocks(ctx, field)
			case "snapshotIntervalSize":
				return ec.fieldContext_OrdererConfigRaftOptions_snapshotIntervalSize(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrdererConfigRaftOptions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaftConsenter_address(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaftConsenter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaftConsenter_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.NetworkAddress)
	fc.Result = res
	return ec.marshalNNetworkAddress2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNetworkAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaftConsenter_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaftConsenter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "host":
				return ec.fieldContext_NetworkAddress_host(ctx, field)
			case "port":
				return ec.fieldContext_NetworkAddress_port(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NetworkAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaftConsenter_clientTlsCert(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaftConsenter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaftConsenter_clientTlsCert(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientTLSCert, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaftConsenter_clientTlsCert(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaftConsenter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaftConsenter_serverTlsCert(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaftConsenter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaftConsenter_serverTlsCert(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServerTLSCert, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaftConsenter_serverTlsCert(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaftConsenter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaftOptions_tickInterval(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaftOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaftOptions_tickInterval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TickInterval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaftOptions_tickInterval(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaftOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaftOptions_electionTick(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaftOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaftOptions_electionTick(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ElectionTick, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaftOptions_electionTick(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaftOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaftOptions_heartbeatTick(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaftOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaftOptions_heartbeatTick(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeartbeatTick, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaftOptions_heartbeatTick(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaftOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaftOptions_maxInflightBlocks(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaftOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaftOptions_maxInflightBlocks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxInflightBlocks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaftOptions_maxInflightBlocks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaftOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaftOptions_snapshotIntervalSize(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaftOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaftOptions_snapshotIntervalSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SnapshotIntervalSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaftOptions_snapshotIntervalSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaftOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererStorage_orderer(ctx context.Context, field graphql.CollectedField, obj *models.OrdererStorage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererStorage_orderer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Orderer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.StorageUsage)
	fc.Result = res
	return ec.marshalNStorageUsage2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐStorageUsage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererStorage_orderer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererStorage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "used":
				return ec.fieldContext_StorageUsage_used(ctx, field)
			case "usedGB":
				return ec.fieldContext_StorageUsage_usedGB(ctx, field)
			case "free":
				return ec.fieldContext_StorageUsage_free(ctx, field)
			case "freeGB":
				return ec.fieldContext_StorageUsage_freeGB(ctx, field)
			case "size":
				return ec.fieldContext_StorageUsage_size(ctx, field)
			case "sizeGB":
				return ec.fieldContext_StorageUsage_sizeGB(ctx, field)
			case "percentageUsed":
				return ec.fieldContext_StorageUsage_percentageUsed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StorageUsage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCRead_collectionName(ctx context.Context, field graphql.CollectedField, obj *models.PDCRead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCRead_collectionName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CollectionName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCRead_collectionName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCRead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCRead_key(ctx context.Context, field graphql.CollectedField, obj *models.PDCRead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCRead_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCRead_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCRead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCRead_block(ctx context.Context, field graphql.CollectedField, obj *models.PDCRead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCRead_block(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Block, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCRead_block(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCRead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCRead_txNum(ctx context.Context, field graphql.CollectedField, obj *models.PDCRead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCRead_txNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCRead_txNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCRead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCReadHash_pdcName(ctx context.Context, field graphql.CollectedField, obj *models.PDCReadHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCReadHash_pdcName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PdcName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCReadHash_pdcName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCReadHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCReadHash_keyHash(ctx context.Context, field graphql.CollectedField, obj *models.PDCReadHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCReadHash_keyHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KeyHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCReadHash_keyHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCReadHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCReadHash_rwSetHash(ctx context.Context, field graphql.CollectedField, obj *models.PDCReadHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCReadHash_rwSetHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RwSetHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCReadHash_rwSetHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCReadHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCReadHash_version(ctx context.Context, field graphql.CollectedField, obj *models.PDCReadHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCReadHash_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.PDCReadVersion)
	fc.Result = res
	return ec.marshalOPDCReadVersion2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCReadVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCReadHash_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCReadHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "blockNum":
				return ec.fieldContext_PDCReadVersion_blockNum(ctx, field)
			case "txNum":
				return ec.fieldContext_PDCReadVersion_txNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PDCReadVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCReadVersion_blockNum(ctx context.Context, field graphql.CollectedField, obj *models.PDCReadVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCReadVersion_blockNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCReadVersion_blockNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCReadVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCReadVersion_txNum(ctx context.Context, field graphql.CollectedField, obj *models.PDCReadVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCReadVersion_txNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCReadVersion_txNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCReadVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWrite_collectionName(ctx context.Context, field graphql.CollectedField, obj *models.PDCWrite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWrite_collectionName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CollectionName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWrite_collectionName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWrite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWrite_deleted(ctx context.Context, field graphql.CollectedField, obj *models.PDCWrite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWrite_deleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWrite_deleted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWrite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWrite_key(ctx context.Context, field graphql.CollectedField, obj *models.PDCWrite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWrite_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWrite_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWrite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWrite_value(ctx context.Context, field graphql.CollectedField, obj *models.PDCWrite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWrite_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWrite_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWrite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWriteHash_pdcName(ctx context.Context, field graphql.CollectedField, obj *models.PDCWriteHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWriteHash_pdcName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PdcName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWriteHash_pdcName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWriteHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWriteHash_keyHash(ctx context.Context, field graphql.CollectedField, obj *models.PDCWriteHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWriteHash_keyHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KeyHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWriteHash_keyHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWriteHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWriteHash_rwSetHash(ctx context.Context, field graphql.CollectedField, obj *models.PDCWriteHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWriteHash_rwSetHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RwSetHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWriteHash_rwSetHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWriteHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWriteHash_valueHash(ctx context.Context, field graphql.CollectedField, obj *models.PDCWriteHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWriteHash_valueHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValueHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWriteHash_valueHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWriteHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWriteHash_isDelete(ctx context.Context, field graphql.CollectedField, obj *models.PDCWriteHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWriteHash_isDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDelete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWriteHash_isDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWriteHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWriteHash_isPurge(ctx context.Context, field graphql.CollectedField, obj *models.PDCWriteHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWriteHash_isPurge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPurge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWriteHash_isPurge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWriteHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Peer_name(ctx context.Context, field graphql.CollectedField, obj *models.Peer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Peer_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Peer_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Peer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Peer_namespace(ctx context.Context, field graphql.CollectedField, obj *models.Peer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Peer_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Peer_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Peer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Peer_yaml(ctx context.Context, field graphql.CollectedField, obj *models.Peer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Peer_yaml(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Yaml, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Peer_yaml(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Peer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Peer_storage(ctx context.Context, field graphql.CollectedField, obj *models.Peer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Peer_storage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Peer().Storage(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.PeerStorage)
	fc.Result = res
	return ec.marshalOPeerStorage2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPeerStorage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Peer_storage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Peer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "chaincode":
				return ec.fieldContext_PeerStorage_chaincode(ctx, field)
			case "couchDB":
				return ec.fieldContext_PeerStorage_couchDB(ctx, field)
			case "peer":
				return ec.fieldContext_PeerStorage_peer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PeerStorage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeerStorage_chaincode(ctx context.Context, field graphql.CollectedField, obj *models.PeerStorage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeerStorage_chaincode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chaincode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.StorageUsage)
	fc.Result = res
	return ec.marshalOStorageUsage2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐStorageUsage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeerStorage_chaincode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeerStorage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "used":
				return ec.fieldContext_StorageUsage_used(ctx, field)
			case "usedGB":
				return ec.fieldContext_StorageUsage_usedGB(ctx, field)
			case "free":
				return ec.fieldContext_StorageUsage_free(ctx, field)
			case "freeGB":
				return ec.fieldContext_StorageUsage_freeGB(ctx, field)
			case "size":
				return ec.fieldContext_StorageUsage_size(ctx, field)
			case "sizeGB":
				return ec.fieldContext_StorageUsage_sizeGB(ctx, field)
			case "percentageUsed":
				return ec.fieldContext_StorageUsage_percentageUsed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StorageUsage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeerStorage_couchDB(ctx context.Context, field graphql.CollectedField, obj *models.PeerStorage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeerStorage_couchDB(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CouchDb, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.StorageUsage)
	fc.Result = res
	return ec.marshalNStorageUsage2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐStorageUsage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeerStorage_couchDB(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeerStorage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "used":
				return ec.fieldContext_StorageUsage_used(ctx, field)
			case "usedGB":
				return ec.fieldContext_StorageUsage_usedGB(ctx, field)
			case "free":
				return ec.fieldContext_StorageUsage_free(ctx, field)
			case "freeGB":
				return ec.fieldContext_StorageUsage_freeGB(ctx, field)
			case "size":
				return ec.fieldContext_StorageUsage_size(ctx, field)
			case "sizeGB":
				return ec.fieldContext_StorageUsage_sizeGB(ctx, field)
			case "percentageUsed":
				return ec.fieldContext_StorageUsage_percentageUsed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StorageUsage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeerStorage_peer(ctx context.Context, field graphql.CollectedField, obj *models.PeerStorage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeerStorage_peer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Peer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.StorageUsage)
	fc.Result = res
	return ec.marshalNStorageUsage2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐStorageUsage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeerStorage_peer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeerStorage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "used":
				return ec.fieldContext_StorageUsage_used(ctx, field)
			case "usedGB":
				return ec.fieldContext_StorageUsage_usedGB(ctx, field)
			case "free":
				return ec.fieldContext_StorageUsage_free(ctx, field)
			case "freeGB":
				return ec.fieldContext_StorageUsage_freeGB(ctx, field)
			case "size":
				return ec.fieldContext_StorageUsage_size(ctx, field)
			case "sizeGB":
				return ec.fieldContext_StorageUsage_sizeGB(ctx, field)
			case "percentageUsed":
				return ec.fieldContext_StorageUsage_percentageUsed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StorageUsage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivateDataCollection_name(ctx context.Context, field graphql.CollectedField, obj *models.PrivateDataCollection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivateDataCollection_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivateDataCollection_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivateDataCollection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivateDataCollection_requiredPeerCount(ctx context.Context, field graphql.CollectedField, obj *models.PrivateDataCollection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivateDataCollection_requiredPeerCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredPeerCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivateDataCollection_requiredPeerCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivateDataCollection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivateDataCollection_maxPeerCount(ctx context.Context, field graphql.CollectedField, obj *models.PrivateDataCollection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivateDataCollection_maxPeerCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxPeerCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivateDataCollection_maxPeerCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivateDataCollection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivateDataCollection_blockToLive(ctx context.Context, field graphql.CollectedField, obj *models.PrivateDataCollection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivateDataCollection_blockToLive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockToLive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivateDataCollection_blockToLive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivateDataCollection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivateDataCollection_memberOnlyRead(ctx context.Context, field graphql.CollectedField, obj *models.PrivateDataCollection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivateDataCollection_memberOnlyRead(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MemberOnlyRead, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivateDataCollection_memberOnlyRead(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivateDataCollection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivateDataCollection_memberOnlyWrite(ctx context.Context, field graphql.CollectedField, obj *models.PrivateDataCollection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivateDataCollection_memberOnlyWrite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MemberOnlyWrite, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivateDataCollection_memberOnlyWrite(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivateDataCollection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivateDataCollection_endorsementPolicy(ctx context.Context, field graphql.CollectedField, obj *models.PrivateDataCollection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivateDataCollection_endorsementPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndorsementPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ApplicationPolicy)
	fc.Result = res
	return ec.marshalOApplicationPolicy2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐApplicationPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivateDataCollection_endorsementPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivateDataCollection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "channelConfigPolicy":
				return ec.fieldContext_ApplicationPolicy_channelConfigPolicy(ctx, field)
			case "signaturePolicy":
				return ec.fieldContext_ApplicationPolicy_signaturePolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivateDataCollection_memberOrgsPolicy(ctx context.Context, field graphql.CollectedField, obj *models.PrivateDataCollection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivateDataCollection_memberOrgsPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MemberOrgsPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SignaturePolicy)
	fc.Result = res
	return ec.marshalOSignaturePolicy2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐSignaturePolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivateDataCollection_memberOrgsPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivateDataCollection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_SignaturePolicy_version(ctx, field)
			case "rule":
				return ec.fieldContext_SignaturePolicy_rule(ctx, field)
			case "principals":
				return ec.fieldContext_SignaturePolicy_principals(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignaturePolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_peers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_peers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Peers(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*models.Peer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kfsoftware/hlf-operator-ui/api/gql/models.Peer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Peer)
	fc.Result = res
	return ec.marshalOPeer2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPeerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_peers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Peer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Peer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Peer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Peer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Peer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_peer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_peer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Peer(rctx, fc.Args["input"].(models.NameAndNamespace))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Peer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kfsoftware/hlf-operator-ui/api/gql/models.Peer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Peer)
	fc.Result = res
	return ec.marshalOPeer2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPeer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_peer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Peer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Peer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Peer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Peer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Peer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_peer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_orderers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_orderers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Orderers(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*models.Orderer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kfsoftware/hlf-operator-ui/api/gql/models.Orderer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Orderer)
	fc.Result = res
	return ec.marshalOOrderer2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_orderers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Orderer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Orderer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Orderer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Orderer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Orderer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_orderer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_orderer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Orderer(rctx, fc.Args["input"].(models.NameAndNamespace))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Orderer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kfsoftware/hlf-operator-ui/api/gql/models.Orderer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Orderer)
	fc.Result = res
	return ec.marshalOOrderer2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrderer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_orderer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Orderer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Orderer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Orderer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Orderer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Orderer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_orderer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_networkConfigEnabled(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_networkConfigEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().NetworkConfigEnabled(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_networkConfigEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_cas(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Cas(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*models.Ca); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kfsoftware/hlf-operator-ui/api/gql/models.Ca`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Ca)
	fc.Result = res
	return ec.marshalOCA2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCaᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_CA_name(ctx, field)
			case "namespace":
				return ec.fieldContext_CA_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_CA_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_CA_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CA", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_ca(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ca(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Ca(rctx, fc.Args["input"].(models.NameAndNamespace))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Ca); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kfsoftware/hlf-operator-ui/api/gql/models.Ca`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Ca)
	fc.Result = res
	return ec.marshalOCA2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCa(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ca(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_CA_name(ctx, field)
			case "namespace":
				return ec.fieldContext_CA_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_CA_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_CA_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CA", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ca_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_namespaces(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_namespaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Namespaces(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*models.Namespace); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kfsoftware/hlf-operator-ui/api/gql/models.Namespace`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Namespace)
	fc.Result = res
	return ec.marshalONamespace2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNamespaceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_namespaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Namespace_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Namespace", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_storageClasses(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_storageClasses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().StorageClasses(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*models.StorageClass); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kfsoftware/hlf-operator-ui/api/gql/models.StorageClass`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.StorageClass)
	fc.Result = res
	return ec.marshalOStorageClass2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐStorageClassᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_storageClasses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_StorageClass_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StorageClass", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_channels(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_channels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Channels(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*models.LightChannel); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kfsoftware/hlf-operator-ui/api/gql/models.LightChannel`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.LightChannel)
	fc.Result = res
	return ec.marshalOLightChannel2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐLightChannelᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_channels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_LightChannel_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LightChannel", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_channel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_channel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Channel(rctx, fc.Args["channelID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Channel); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kfsoftware/hlf-operator-ui/api/gql/models.Channel`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Channel)
	fc.Result = res
	return ec.marshalNChannel2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_channel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Channel_name(ctx, field)
			case "rawConfig":
				return ec.fieldContext_Channel_rawConfig(ctx, field)
			case "protoConfig":
				return ec.fieldContext_Channel_protoConfig(ctx, field)
			case "channelConfig":
				return ec.fieldContext_Channel_channelConfig(ctx, field)
			case "application":
				return ec.fieldContext_Channel_application(ctx, field)
			case "orderer":
				return ec.fieldContext_Channel_orderer(ctx, field)
			case "height":
				return ec.fieldContext_Channel_height(ctx, field)
			case "chaincodes":
				return ec.fieldContext_Channel_chaincodes(ctx, field)
			case "peers":
				return ec.fieldContext_Channel_peers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Channel", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_channel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_blocks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_blocks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Blocks(rctx, fc.Args["channelID"].(string), fc.Args["from"].(int), fc.Args["to"].(int), fc.Args["reverse"].(bool))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.BlocksResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kfsoftware/hlf-operator-ui/api/gql/models.BlocksResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BlocksResponse)
	fc.Result = res
	return ec.marshalNBlocksResponse2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐBlocksResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_blocks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "height":
				return ec.fieldContext_BlocksResponse_height(ctx, field)
			case "blocks":
				return ec.fieldContext_BlocksResponse_blocks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BlocksResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_blocks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_block(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_block(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Block(rctx, fc.Args["channelID"].(string), fc.Args["blockNumber"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Block); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kfsoftware/hlf-operator-ui/api/gql/models.Block`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Block)
	fc.Result = res
	return ec.marshalNBlock2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐBlock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_block(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "blockNumber":
				return ec.fieldContext_Block_blockNumber(ctx, field)
			case "dataHash":
				return ec.fieldContext_Block_dataHash(ctx, field)
			case "numTransactions":
				return ec.fieldContext_Block_numTransactions(ctx, field)
			case "createdAt":
				return ec.fieldContext_Block_createdAt(ctx, field)
			case "transactions":
				return ec.fieldContext_Block_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Block", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_block_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_blockWithPrivateData(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_blockWithPrivateData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().BlockWithPrivateData(rctx, fc.Args["channelID"].(string), fc.Args["blockNumber"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.BlockWithPrivateData); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kfsoftware/hlf-operator-ui/api/gql/models.BlockWithPrivateData`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BlockWithPrivateData)
	fc.Result = res
	return ec.marshalNBlockWithPrivateData2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐBlockWithPrivateData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_blockWithPrivateData(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "blockNumber":
				return ec.fieldContext_BlockWithPrivateData_blockNumber(ctx, field)
			case "dataHash":
				return ec.fieldContext_BlockWithPrivateData_dataHash(ctx, field)
			case "numTransactions":
				return ec.fieldContext_BlockWithPrivateData_numTransactions(ctx, field)
			case "createdAt":
				return ec.fieldContext_BlockWithPrivateData_createdAt(ctx, field)
			case "transactions":
				return ec.fieldContext_BlockWithPrivateData_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BlockWithPrivateData", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_blockWithPrivateData_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_blockByTXID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_blockByTXID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().BlockByTxid(rctx, fc.Args["channelID"].(string), fc.Args["transactionID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Block); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kfsoftware/hlf-operator-ui/api/gql/models.Block`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Block)
	fc.Result = res
	return ec.marshalNBlock2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐBlock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_blockByTXID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "blockNumber":
				return ec.fieldContext_Block_blockNumber(ctx, field)
			case "dataHash":
				return ec.fieldContext_Block_dataHash(ctx, field)
			case "numTransactions":
				return ec.fieldContext_Block_numTransactions(ctx, field)
			case "createdAt":
				return ec.fieldContext_Block_createdAt(ctx, field)
			case "transactions":
				return ec.fieldContext_Block_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Block", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_blockByTXID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RenewOrdererCertificatesResponse_orderer(ctx context.Context, field graphql.CollectedField, obj *models.RenewOrdererCertificatesResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RenewOrdererCertificatesResponse_orderer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Orderer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Orderer)
	fc.Result = res
	return ec.marshalOOrderer2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrderer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RenewOrdererCertificatesResponse_orderer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RenewOrdererCertificatesResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Orderer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Orderer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Orderer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Orderer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Orderer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RenewOrdererCertificatesResponse_errors(ctx context.Context, field graphql.CollectedField, obj *models.RenewOrdererCertificatesResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RenewOrdererCertificatesResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Error)
	fc.Result = res
	return ec.marshalOError2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐErrorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RenewOrdererCertificatesResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RenewOrdererCertificatesResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_Error_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Error", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RenewPeerCertificatesResponse_peer(ctx context.Context, field graphql.CollectedField, obj *models.RenewPeerCertificatesResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RenewPeerCertificatesResponse_peer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Peer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Peer)
	fc.Result = res
	return ec.marshalOPeer2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPeer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RenewPeerCertificatesResponse_peer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RenewPeerCertificatesResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Peer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Peer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Peer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Peer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Peer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RenewPeerCertificatesResponse_errors(ctx context.Context, field graphql.CollectedField, obj *models.RenewPeerCertificatesResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RenewPeerCertificatesResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Error)
	fc.Result = res
	return ec.marshalOError2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐErrorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RenewPeerCertificatesResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RenewPeerCertificatesResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_Error_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Error", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicy_version(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicy_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicy_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicy_rule(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicy_rule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.SignaturePolicyRule)
	fc.Result = res
	return ec.marshalNSignaturePolicyRule2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐSignaturePolicyRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicy_rule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_SignaturePolicyRule_type(ctx, field)
			case "noutOf":
				return ec.fieldContext_SignaturePolicyRule_noutOf(ctx, field)
			case "signedBy":
				return ec.fieldContext_SignaturePolicyRule_signedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignaturePolicyRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicy_principals(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicy_principals(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Principals, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.MSPPrincipal)
	fc.Result = res
	return ec.marshalOMSPPrincipal2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐMSPPrincipalᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicy_principals(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "combined":
				return ec.fieldContext_MSPPrincipal_combined(ctx, field)
			case "role":
				return ec.fieldContext_MSPPrincipal_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MSPPrincipal", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicyNOutOf_n(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicyNOutOf) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicyNOutOf_n(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.N, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicyNOutOf_n(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicyNOutOf",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicyNOutOf_rules(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicyNOutOf) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicyNOutOf_rules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.SignaturePolicyRule)
	fc.Result = res
	return ec.marshalOSignaturePolicyRule2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐSignaturePolicyRuleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicyNOutOf_rules(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicyNOutOf",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_SignaturePolicyRule_type(ctx, field)
			case "noutOf":
				return ec.fieldContext_SignaturePolicyRule_noutOf(ctx, field)
			case "signedBy":
				return ec.fieldContext_SignaturePolicyRule_signedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignaturePolicyRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicyRule_type(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicyRule_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicyRule_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicyRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicyRule_noutOf(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicyRule_noutOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoutOf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SignaturePolicyNOutOf)
	fc.Result = res
	return ec.marshalOSignaturePolicyNOutOf2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐSignaturePolicyNOutOf(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicyRule_noutOf(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicyRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "n":
				return ec.fieldContext_SignaturePolicyNOutOf_n(ctx, field)
			case "rules":
				return ec.fieldContext_SignaturePolicyNOutOf_rules(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignaturePolicyNOutOf", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicyRule_signedBy(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicyRule_signedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SignaturePolicySignedBy)
	fc.Result = res
	return ec.marshalOSignaturePolicySignedBy2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐSignaturePolicySignedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicyRule_signedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicyRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "signedBy":
				return ec.fieldContext_SignaturePolicySignedBy_signedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignaturePolicySignedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicySignedBy_signedBy(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicySignedBy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicySignedBy_signedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicySignedBy_signedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicySignedBy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageClass_name(ctx context.Context, field graphql.CollectedField, obj *models.StorageClass) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageClass_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageClass_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageClass",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_used(ctx context.Context, field graphql.CollectedField, obj *models.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_used(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_usedGB(ctx context.Context, field graphql.CollectedField, obj *models.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_usedGB(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsedGb, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_usedGB(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_free(ctx context.Context, field graphql.CollectedField, obj *models.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_free(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Free, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_free(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_freeGB(ctx context.Context, field graphql.CollectedField, obj *models.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_freeGB(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FreeGb, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_freeGB(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_size(ctx context.Context, field graphql.CollectedField, obj *models.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_sizeGB(ctx context.Context, field graphql.CollectedField, obj *models.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_sizeGB(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SizeGb, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_sizeGB(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_percentageUsed(ctx context.Context, field graphql.CollectedField, obj *models.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_percentageUsed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PercentageUsed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_percentageUsed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_txID(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_txID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_txID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_type(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.TransactionType)
	fc.Result = res
	return ec.marshalNTransactionType2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TransactionType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_version(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_path(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_response(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_response(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Response, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_response(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_request(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_request(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Request, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_request(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_chaincode(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_chaincode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chaincode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_chaincode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_writes(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_writes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Writes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.TransactionWrite)
	fc.Result = res
	return ec.marshalOTransactionWrite2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionWriteᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_writes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "chaincodeID":
				return ec.fieldContext_TransactionWrite_chaincodeID(ctx, field)
			case "deleted":
				return ec.fieldContext_TransactionWrite_deleted(ctx, field)
			case "key":
				return ec.fieldContext_TransactionWrite_key(ctx, field)
			case "value":
				return ec.fieldContext_TransactionWrite_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionWrite", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_reads(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_reads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reads, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.TransactionRead)
	fc.Result = res
	return ec.marshalOTransactionRead2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionReadᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_reads(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "chaincodeID":
				return ec.fieldContext_TransactionRead_chaincodeID(ctx, field)
			case "key":
				return ec.fieldContext_TransactionRead_key(ctx, field)
			case "blockNumVersion":
				return ec.fieldContext_TransactionRead_blockNumVersion(ctx, field)
			case "txNumVersion":
				return ec.fieldContext_TransactionRead_txNumVersion(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionRead", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRead_chaincodeID(ctx context.Context, field graphql.CollectedField, obj *models.TransactionRead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionRead_chaincodeID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaincodeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionRead_chaincodeID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRead_key(ctx context.Context, field graphql.CollectedField, obj *models.TransactionRead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionRead_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionRead_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRead_blockNumVersion(ctx context.Context, field graphql.CollectedField, obj *models.TransactionRead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionRead_blockNumVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockNumVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionRead_blockNumVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRead_txNumVersion(ctx context.Context, field graphql.CollectedField, obj *models.TransactionRead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionRead_txNumVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxNumVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionRead_txNumVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_txID(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_txID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_txID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_type(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.TransactionType)
	fc.Result = res
	return ec.marshalNTransactionType2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TransactionType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_version(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_path(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_response(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_response(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Response, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_response(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_request(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_request(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Request, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_request(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_chaincode(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_chaincode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chaincode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_chaincode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_writes(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_writes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Writes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.TransactionWrite)
	fc.Result = res
	return ec.marshalOTransactionWrite2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionWriteᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_writes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "chaincodeID":
				return ec.fieldContext_TransactionWrite_chaincodeID(ctx, field)
			case "deleted":
				return ec.fieldContext_TransactionWrite_deleted(ctx, field)
			case "key":
				return ec.fieldContext_TransactionWrite_key(ctx, field)
			case "value":
				return ec.fieldContext_TransactionWrite_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionWrite", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_reads(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_reads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reads, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.TransactionRead)
	fc.Result = res
	return ec.marshalOTransactionRead2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionReadᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_reads(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "chaincodeID":
				return ec.fieldContext_TransactionRead_chaincodeID(ctx, field)
			case "key":
				return ec.fieldContext_TransactionRead_key(ctx, field)
			case "blockNumVersion":
				return ec.fieldContext_TransactionRead_blockNumVersion(ctx, field)
			case "txNumVersion":
				return ec.fieldContext_TransactionRead_txNumVersion(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionRead", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_pdcWrites(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_pdcWrites(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PdcWrites, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.PDCWrite)
	fc.Result = res
	return ec.marshalOPDCWrite2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCWriteᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_pdcWrites(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "collectionName":
				return ec.fieldContext_PDCWrite_collectionName(ctx, field)
			case "deleted":
				return ec.fieldContext_PDCWrite_deleted(ctx, field)
			case "key":
				return ec.fieldContext_PDCWrite_key(ctx, field)
			case "value":
				return ec.fieldContext_PDCWrite_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PDCWrite", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_pdcReads(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_pdcReads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PdcReads, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.PDCRead)
	fc.Result = res
	return ec.marshalOPDCRead2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCReadᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_pdcReads(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "collectionName":
				return ec.fieldContext_PDCRead_collectionName(ctx, field)
			case "key":
				return ec.fieldContext_PDCRead_key(ctx, field)
			case "block":
				return ec.fieldContext_PDCRead_block(ctx, field)
			case "txNum":
				return ec.fieldContext_PDCRead_txNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PDCRead", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_pdcWriteHashes(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_pdcWriteHashes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PdcWriteHashes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.PDCWriteHash)
	fc.Result = res
	return ec.marshalOPDCWriteHash2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCWriteHashᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_pdcWriteHashes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pdcName":
				return ec.fieldContext_PDCWriteHash_pdcName(ctx, field)
			case "keyHash":
				return ec.fieldContext_PDCWriteHash_keyHash(ctx, field)
			case "rwSetHash":
				return ec.fieldContext_PDCWriteHash_rwSetHash(ctx, field)
			case "valueHash":
				return ec.fieldContext_PDCWriteHash_valueHash(ctx, field)
			case "isDelete":
				return ec.fieldContext_PDCWriteHash_isDelete(ctx, field)
			case "isPurge":
				return ec.fieldContext_PDCWriteHash_isPurge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PDCWriteHash", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_pdcReadHashes(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_pdcReadHashes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PdcReadHashes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.PDCReadHash)
	fc.Result = res
	return ec.marshalOPDCReadHash2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCReadHashᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_pdcReadHashes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pdcName":
				return ec.fieldContext_PDCReadHash_pdcName(ctx, field)
			case "keyHash":
				return ec.fieldContext_PDCReadHash_keyHash(ctx, field)
			case "rwSetHash":
				return ec.fieldContext_PDCReadHash_rwSetHash(ctx, field)
			case "version":
				return ec.fieldContext_PDCReadHash_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PDCReadHash", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWrite_chaincodeID(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWrite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWrite_chaincodeID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaincodeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWrite_chaincodeID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWrite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWrite_deleted(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWrite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWrite_deleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWrite_deleted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWrite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWrite_key(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWrite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWrite_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWrite_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWrite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWrite_value(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWrite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWrite_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWrite_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWrite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateChannelResponse_errors(ctx context.Context, field graphql.CollectedField, obj *models.UpdateChannelResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateChannelResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Error)
	fc.Result = res
	return ec.marshalOError2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐErrorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateChannelResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateChannelResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_Error_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Error", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateChannelResponse_transactionID(ctx context.Context, field graphql.CollectedField, obj *models.UpdateChannelResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateChannelResponse_transactionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TransactionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateChannelResponse_transactionID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateChannelResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputApplicationConfigInput(ctx context.Context, obj interface{}) (models.ApplicationConfigInput, error) {
	var it models.ApplicationConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"policies", "acls", "capabilities", "addOrgs", "delOrgs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "policies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("policies"))
			it.Policies, err = ec.unmarshalOPolicyInput2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPolicyInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "acls":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acls"))
			it.Acls, err = ec.unmarshalOChannelACLInput2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelACLInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "capabilities":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capabilities"))
			it.Capabilities, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "addOrgs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addOrgs"))
			it.AddOrgs, err = ec.unmarshalOChannelOrganization2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelOrganizationᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "delOrgs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("delOrgs"))
			it.DelOrgs, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChannelACLInput(ctx context.Context, obj interface{}) (models.ChannelACLInput, error) {
	var it models.ChannelACLInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			it.Key, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			it.Value, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChannelConfigInput(ctx context.Context, obj interface{}) (models.ChannelConfigInput, error) {
	var it models.ChannelConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"policies", "capabilities"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "policies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("policies"))
			it.Policies, err = ec.unmarshalOPolicyInput2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPolicyInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "capabilities":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capabilities"))
			it.Capabilities, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChannelOrganization(ctx context.Context, obj interface{}) (models.ChannelOrganization, error) {
	var it models.ChannelOrganization
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"mspID", "modPolicy", "policies", "msp", "anchorPeers", "ordererEndpoints"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "mspID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mspID"))
			it.MspID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "modPolicy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modPolicy"))
			it.ModPolicy, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("policies"))
			it.Policies, err = ec.unmarshalOPolicyInput2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPolicyInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "msp":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("msp"))
			it.Msp, err = ec.unmarshalNMSPInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐMSPInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "anchorPeers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("anchorPeers"))
			it.AnchorPeers, err = ec.unmarshalONetworkAddressInput2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNetworkAddressInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "ordererEndpoints":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ordererEndpoints"))
			it.OrdererEndpoints, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateCAInput(ctx context.Context, obj interface{}) (models.CreateCAInput, error) {
	var it models.CreateCAInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"yaml"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "yaml":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yaml"))
			it.Yaml, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateOrdererInput(ctx context.Context, obj interface{}) (models.CreateOrdererInput, error) {
	var it models.CreateOrdererInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"yaml"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "yaml":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yaml"))
			it.Yaml, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreatePeerInput(ctx context.Context, obj interface{}) (models.CreatePeerInput, error) {
	var it models.CreatePeerInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"yaml"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "yaml":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yaml"))
			it.Yaml, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCryptoConfigInput(ctx context.Context, obj interface{}) (models.CryptoConfigInput, error) {
	var it models.CryptoConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["signatureHashFamily"]; !present {
		asMap["signatureHashFamily"] = "SHA2"
	}
	if _, present := asMap["identityIdentifierHashFunction"]; !present {
		asMap["identityIdentifierHashFunction"] = "SHA256"
	}

	fieldsInOrder := [...]string{"signatureHashFamily", "identityIdentifierHashFunction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "signatureHashFamily":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signatureHashFamily"))
			it.SignatureHashFamily, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityIdentifierHashFunction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityIdentifierHashFunction"))
			it.IdentityIdentifierHashFunction, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEtcdRaftInput(ctx context.Context, obj interface{}) (models.EtcdRaftInput, error) {
	var it models.EtcdRaftInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"addConsenters", "delConsenters", "options"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "addConsenters":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addConsenters"))
			it.AddConsenters, err = ec.unmarshalOOrdererConfigRaftConsenterInput2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigRaftConsenterInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "delConsenters":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("delConsenters"))
			it.DelConsenters, err = ec.unmarshalOOrdererConfigRaftConsenterInput2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigRaftConsenterInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "options":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
			it.Options, err = ec.unmarshalOOrdererConfigRaftOptionsInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigRaftOptionsInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetUpdateChannelBlockInput(ctx context.Context, obj interface{}) (models.GetUpdateChannelBlockInput, error) {
	var it models.GetUpdateChannelBlockInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"channelID", "application", "orderer", "channel"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "channelID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channelID"))
			it.ChannelID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "application":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("application"))
			it.Application, err = ec.unmarshalNApplicationConfigInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐApplicationConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "orderer":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderer"))
			it.Orderer, err = ec.unmarshalOOrdererConfigInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "channel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channel"))
			it.Channel, err = ec.unmarshalNChannelConfigInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMSPInput(ctx context.Context, obj interface{}) (models.MSPInput, error) {
	var it models.MSPInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "rootCerts", "intermediateCerts", "admins", "revocationList", "ous", "tlsRootCerts", "tlsIntermediateCerts", "nodeOUs", "cryptoConfig"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rootCerts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rootCerts"))
			it.RootCerts, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "intermediateCerts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("intermediateCerts"))
			it.IntermediateCerts, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "admins":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
			it.Admins, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "revocationList":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revocationList"))
			it.RevocationList, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "ous":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ous"))
			it.Ous, err = ec.unmarshalOOUIdentifierInput2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOUIdentifierInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "tlsRootCerts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tlsRootCerts"))
			it.TLSRootCerts, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "tlsIntermediateCerts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tlsIntermediateCerts"))
			it.TLSIntermediateCerts, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nodeOUs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nodeOUs"))
			it.NodeOUs, err = ec.unmarshalNNodeOUsInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNodeOUsInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "cryptoConfig":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cryptoConfig"))
			it.CryptoConfig, err = ec.unmarshalNCryptoConfigInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCryptoConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMSPSignature(ctx context.Context, obj interface{}) (models.MSPSignature, error) {
	var it models.MSPSignature
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"mspID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "mspID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mspID"))
			it.MspID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNameAndNamespace(ctx context.Context, obj interface{}) (models.NameAndNamespace, error) {
	var it models.NameAndNamespace
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			it.Namespace, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNetworkAddressInput(ctx context.Context, obj interface{}) (models.NetworkAddressInput, error) {
	var it models.NetworkAddressInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"host", "port"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "host":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("host"))
			it.Host, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "port":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("port"))
			it.Port, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNodeOUsInput(ctx context.Context, obj interface{}) (models.NodeOUsInput, error) {
	var it models.NodeOUsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"enable", "clientOUIdentifier", "peerOUIdentifier", "adminOUIdentifier", "ordererOUIdentifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "enable":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enable"))
			it.Enable, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "clientOUIdentifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientOUIdentifier"))
			it.ClientOUIdentifier, err = ec.unmarshalNOUIdentifierInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOUIdentifierInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "peerOUIdentifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("peerOUIdentifier"))
			it.PeerOUIdentifier, err = ec.unmarshalNOUIdentifierInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOUIdentifierInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "adminOUIdentifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adminOUIdentifier"))
			it.AdminOUIdentifier, err = ec.unmarshalNOUIdentifierInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOUIdentifierInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "ordererOUIdentifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ordererOUIdentifier"))
			it.OrdererOUIdentifier, err = ec.unmarshalNOUIdentifierInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOUIdentifierInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOUIdentifierInput(ctx context.Context, obj interface{}) (models.OUIdentifierInput, error) {
	var it models.OUIdentifierInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"certificate", "ouIdentifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "certificate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("certificate"))
			it.Certificate, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ouIdentifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ouIdentifier"))
			it.OuIdentifier, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOrdererConfigBatchSizeInput(ctx context.Context, obj interface{}) (models.OrdererConfigBatchSizeInput, error) {
	var it models.OrdererConfigBatchSizeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"maxMessageCount", "absoluteMaxBytes", "preferredMaxBytes"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "maxMessageCount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxMessageCount"))
			it.MaxMessageCount, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "absoluteMaxBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("absoluteMaxBytes"))
			it.AbsoluteMaxBytes, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "preferredMaxBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preferredMaxBytes"))
			it.PreferredMaxBytes, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOrdererConfigInput(ctx context.Context, obj interface{}) (models.OrdererConfigInput, error) {
	var it models.OrdererConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"batchTimeout", "state", "etcdRaft", "addPolicies", "addCapabilities", "addOrganizations", "delOrganizations", "batchSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "batchTimeout":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("batchTimeout"))
			it.BatchTimeout, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "state":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
			it.State, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "etcdRaft":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("etcdRaft"))
			it.EtcdRaft, err = ec.unmarshalOEtcdRaftInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐEtcdRaftInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "addPolicies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addPolicies"))
			it.AddPolicies, err = ec.unmarshalOPolicyInput2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPolicyInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "addCapabilities":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addCapabilities"))
			it.AddCapabilities, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "addOrganizations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addOrganizations"))
			it.AddOrganizations, err = ec.unmarshalOChannelOrganization2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelOrganization(ctx, v)
			if err != nil {
				return it, err
			}
		case "delOrganizations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("delOrganizations"))
			it.DelOrganizations, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "batchSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("batchSize"))
			it.BatchSize, err = ec.unmarshalOOrdererConfigBatchSizeInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigBatchSizeInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOrdererConfigRaftConsenterInput(ctx context.Context, obj interface{}) (models.OrdererConfigRaftConsenterInput, error) {
	var it models.OrdererConfigRaftConsenterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"address", "clientTlsCert", "serverTlsCert"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "address":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
			it.Address, err = ec.unmarshalNNetworkAddressInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNetworkAddressInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "clientTlsCert":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientTlsCert"))
			it.ClientTLSCert, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "serverTlsCert":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serverTlsCert"))
			it.ServerTLSCert, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOrdererConfigRaftOptionsInput(ctx context.Context, obj interface{}) (models.OrdererConfigRaftOptionsInput, error) {
	var it models.OrdererConfigRaftOptionsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tickInterval", "electionTick", "heartbeatTick", "maxInflightBlocks", "snapshotIntervalSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tickInterval":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tickInterval"))
			it.TickInterval, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "electionTick":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("electionTick"))
			it.ElectionTick, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "heartbeatTick":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("heartbeatTick"))
			it.HeartbeatTick, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxInflightBlocks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxInflightBlocks"))
			it.MaxInflightBlocks, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "snapshotIntervalSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("snapshotIntervalSize"))
			it.SnapshotIntervalSize, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPolicyInput(ctx context.Context, obj interface{}) (models.PolicyInput, error) {
	var it models.PolicyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "type", "rule", "modPolicy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			it.Key, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rule":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rule"))
			it.Rule, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "modPolicy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modPolicy"))
			it.ModPolicy, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRawSignature(ctx context.Context, obj interface{}) (models.RawSignature, error) {
	var it models.RawSignature
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"raw"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "raw":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("raw"))
			it.Raw, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRenewOrdererCertificatesInput(ctx context.Context, obj interface{}) (models.RenewOrdererCertificatesInput, error) {
	var it models.RenewOrdererCertificatesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"namespace", "name", "force"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			it.Namespace, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "force":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("force"))
			it.Force, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRenewPeerCertificatesInput(ctx context.Context, obj interface{}) (models.RenewPeerCertificatesInput, error) {
	var it models.RenewPeerCertificatesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"namespace", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			it.Namespace, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCAInput(ctx context.Context, obj interface{}) (models.UpdateCAInput, error) {
	var it models.UpdateCAInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"yaml"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "yaml":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yaml"))
			it.Yaml, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateChannelInput(ctx context.Context, obj interface{}) (models.UpdateChannelInput, error) {
	var it models.UpdateChannelInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "block", "rawSignatures", "mspSignatures"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "block":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("block"))
			it.Block, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rawSignatures":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawSignatures"))
			it.RawSignatures, err = ec.unmarshalORawSignature2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐRawSignatureᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "mspSignatures":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mspSignatures"))
			it.MspSignatures, err = ec.unmarshalOMSPSignature2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐMSPSignatureᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateeOrdererInput(ctx context.Context, obj interface{}) (models.UpdateeOrdererInput, error) {
	var it models.UpdateeOrdererInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"yaml"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "yaml":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yaml"))
			it.Yaml, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateePeerInput(ctx context.Context, obj interface{}) (models.UpdateePeerInput, error) {
	var it models.UpdateePeerInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"yaml"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "yaml":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yaml"))
			it.Yaml, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var applicationConfigImplementors = []string{"ApplicationConfig"}

func (ec *executionContext) _ApplicationConfig(ctx context.Context, sel ast.SelectionSet, obj *models.ApplicationConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationConfig")
		case "policies":

			out.Values[i] = ec._ApplicationConfig_policies(ctx, field, obj)

		case "acls":

			out.Values[i] = ec._ApplicationConfig_acls(ctx, field, obj)

		case "capabilities":

			out.Values[i] = ec._ApplicationConfig_capabilities(ctx, field, obj)

		case "organizations":

			out.Values[i] = ec._ApplicationConfig_organizations(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationPolicyImplementors = []string{"ApplicationPolicy"}

func (ec *executionContext) _ApplicationPolicy(ctx context.Context, sel ast.SelectionSet, obj *models.ApplicationPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationPolicyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationPolicy")
		case "channelConfigPolicy":

			out.Values[i] = ec._ApplicationPolicy_channelConfigPolicy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "signaturePolicy":

			out.Values[i] = ec._ApplicationPolicy_signaturePolicy(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blockImplementors = []string{"Block"}

func (ec *executionContext) _Block(ctx context.Context, sel ast.SelectionSet, obj *models.Block) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blockImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Block")
		case "blockNumber":

			out.Values[i] = ec._Block_blockNumber(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dataHash":

			out.Values[i] = ec._Block_dataHash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "numTransactions":

			out.Values[i] = ec._Block_numTransactions(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":

			out.Values[i] = ec._Block_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "transactions":

			out.Values[i] = ec._Block_transactions(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blockWithPrivateDataImplementors = []string{"BlockWithPrivateData"}

func (ec *executionContext) _BlockWithPrivateData(ctx context.Context, sel ast.SelectionSet, obj *models.BlockWithPrivateData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blockWithPrivateDataImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlockWithPrivateData")
		case "blockNumber":

			out.Values[i] = ec._BlockWithPrivateData_blockNumber(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dataHash":

			out.Values[i] = ec._BlockWithPrivateData_dataHash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "numTransactions":

			out.Values[i] = ec._BlockWithPrivateData_numTransactions(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":

			out.Values[i] = ec._BlockWithPrivateData_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "transactions":

			out.Values[i] = ec._BlockWithPrivateData_transactions(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blocksResponseImplementors = []string{"BlocksResponse"}

func (ec *executionContext) _BlocksResponse(ctx context.Context, sel ast.SelectionSet, obj *models.BlocksResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blocksResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlocksResponse")
		case "height":

			out.Values[i] = ec._BlocksResponse_height(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "blocks":

			out.Values[i] = ec._BlocksResponse_blocks(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cAImplementors = []string{"CA"}

func (ec *executionContext) _CA(ctx context.Context, sel ast.SelectionSet, obj *models.Ca) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cAImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CA")
		case "name":

			out.Values[i] = ec._CA_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "namespace":

			out.Values[i] = ec._CA_namespace(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "yaml":

			out.Values[i] = ec._CA_yaml(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "storage":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CA_storage(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cAStorageImplementors = []string{"CAStorage"}

func (ec *executionContext) _CAStorage(ctx context.Context, sel ast.SelectionSet, obj *models.CAStorage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cAStorageImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CAStorage")
		case "ca":

			out.Values[i] = ec._CAStorage_ca(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chaincodeApprovalImplementors = []string{"ChaincodeApproval"}

func (ec *executionContext) _ChaincodeApproval(ctx context.Context, sel ast.SelectionSet, obj *models.ChaincodeApproval) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chaincodeApprovalImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChaincodeApproval")
		case "mspID":

			out.Values[i] = ec._ChaincodeApproval_mspID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "approved":

			out.Values[i] = ec._ChaincodeApproval_approved(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelImplementors = []string{"Channel"}

func (ec *executionContext) _Channel(ctx context.Context, sel ast.SelectionSet, obj *models.Channel) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Channel")
		case "name":

			out.Values[i] = ec._Channel_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "rawConfig":

			out.Values[i] = ec._Channel_rawConfig(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "protoConfig":

			out.Values[i] = ec._Channel_protoConfig(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "channelConfig":

			out.Values[i] = ec._Channel_channelConfig(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "application":

			out.Values[i] = ec._Channel_application(ctx, field, obj)

		case "orderer":

			out.Values[i] = ec._Channel_orderer(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "height":

			out.Values[i] = ec._Channel_height(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "chaincodes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Channel_chaincodes(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "peers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Channel_peers(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelACLImplementors = []string{"ChannelACL"}

func (ec *executionContext) _ChannelACL(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelACL) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelACLImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelACL")
		case "key":

			out.Values[i] = ec._ChannelACL_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._ChannelACL_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelAnchorPeerImplementors = []string{"ChannelAnchorPeer"}

func (ec *executionContext) _ChannelAnchorPeer(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelAnchorPeer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelAnchorPeerImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelAnchorPeer")
		case "mspID":

			out.Values[i] = ec._ChannelAnchorPeer_mspID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "host":

			out.Values[i] = ec._ChannelAnchorPeer_host(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "port":

			out.Values[i] = ec._ChannelAnchorPeer_port(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelChaincodeImplementors = []string{"ChannelChaincode"}

func (ec *executionContext) _ChannelChaincode(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelChaincode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelChaincodeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelChaincode")
		case "name":

			out.Values[i] = ec._ChannelChaincode_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":

			out.Values[i] = ec._ChannelChaincode_version(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sequence":

			out.Values[i] = ec._ChannelChaincode_sequence(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "signaturePolicy":

			out.Values[i] = ec._ChannelChaincode_signaturePolicy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "endorsementPlugin":

			out.Values[i] = ec._ChannelChaincode_endorsementPlugin(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "validationPlugin":

			out.Values[i] = ec._ChannelChaincode_validationPlugin(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "configPolicy":

			out.Values[i] = ec._ChannelChaincode_configPolicy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "privateDataCollections":

			out.Values[i] = ec._ChannelChaincode_privateDataCollections(ctx, field, obj)

		case "approvals":

			out.Values[i] = ec._ChannelChaincode_approvals(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelConfigImplementors = []string{"ChannelConfig"}

func (ec *executionContext) _ChannelConfig(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelConfig")
		case "policies":

			out.Values[i] = ec._ChannelConfig_policies(ctx, field, obj)

		case "capabilities":

			out.Values[i] = ec._ChannelConfig_capabilities(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelMSPImplementors = []string{"ChannelMSP"}

func (ec *executionContext) _ChannelMSP(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelMsp) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelMSPImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelMSP")
		case "name":

			out.Values[i] = ec._ChannelMSP_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rootCerts":

			out.Values[i] = ec._ChannelMSP_rootCerts(ctx, field, obj)

		case "intermediateCerts":

			out.Values[i] = ec._ChannelMSP_intermediateCerts(ctx, field, obj)

		case "admins":

			out.Values[i] = ec._ChannelMSP_admins(ctx, field, obj)

		case "revocationList":

			out.Values[i] = ec._ChannelMSP_revocationList(ctx, field, obj)

		case "tlsRootCerts":

			out.Values[i] = ec._ChannelMSP_tlsRootCerts(ctx, field, obj)

		case "tlsIntermediateCerts":

			out.Values[i] = ec._ChannelMSP_tlsIntermediateCerts(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelOrgImplementors = []string{"ChannelOrg"}

func (ec *executionContext) _ChannelOrg(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelOrg) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelOrgImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelOrg")
		case "modPolicy":

			out.Values[i] = ec._ChannelOrg_modPolicy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mspID":

			out.Values[i] = ec._ChannelOrg_mspID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "policies":

			out.Values[i] = ec._ChannelOrg_policies(ctx, field, obj)

		case "msp":

			out.Values[i] = ec._ChannelOrg_msp(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ordererEndpoints":

			out.Values[i] = ec._ChannelOrg_ordererEndpoints(ctx, field, obj)

		case "anchorPeer":

			out.Values[i] = ec._ChannelOrg_anchorPeer(ctx, field, obj)

		case "nodeOUs":

			out.Values[i] = ec._ChannelOrg_nodeOUs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cryptoConfig":

			out.Values[i] = ec._ChannelOrg_cryptoConfig(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ous":

			out.Values[i] = ec._ChannelOrg_ous(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelPeerImplementors = []string{"ChannelPeer"}

func (ec *executionContext) _ChannelPeer(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelPeer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelPeerImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelPeer")
		case "mspID":

			out.Values[i] = ec._ChannelPeer_mspID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":

			out.Values[i] = ec._ChannelPeer_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "height":

			out.Values[i] = ec._ChannelPeer_height(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelPolicyImplementors = []string{"ChannelPolicy"}

func (ec *executionContext) _ChannelPolicy(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelPolicyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelPolicy")
		case "key":

			out.Values[i] = ec._ChannelPolicy_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec._ChannelPolicy_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rule":

			out.Values[i] = ec._ChannelPolicy_rule(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "modPolicy":

			out.Values[i] = ec._ChannelPolicy_modPolicy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cryptoConfigImplementors = []string{"CryptoConfig"}

func (ec *executionContext) _CryptoConfig(ctx context.Context, sel ast.SelectionSet, obj *models.CryptoConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cryptoConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CryptoConfig")
		case "signatureHashFamily":

			out.Values[i] = ec._CryptoConfig_signatureHashFamily(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "identityIdentifierHashFunction":

			out.Values[i] = ec._CryptoConfig_identityIdentifierHashFunction(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errorImplementors = []string{"Error"}

func (ec *executionContext) _Error(ctx context.Context, sel ast.SelectionSet, obj *models.Error) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errorImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Error")
		case "message":

			out.Values[i] = ec._Error_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var getUpdateChannelBlockResponseImplementors = []string{"GetUpdateChannelBlockResponse"}

func (ec *executionContext) _GetUpdateChannelBlockResponse(ctx context.Context, sel ast.SelectionSet, obj *models.GetUpdateChannelBlockResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getUpdateChannelBlockResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetUpdateChannelBlockResponse")
		case "errors":

			out.Values[i] = ec._GetUpdateChannelBlockResponse_errors(ctx, field, obj)

		case "block":

			out.Values[i] = ec._GetUpdateChannelBlockResponse_block(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "configUpdate":

			out.Values[i] = ec._GetUpdateChannelBlockResponse_configUpdate(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var lightChannelImplementors = []string{"LightChannel"}

func (ec *executionContext) _LightChannel(ctx context.Context, sel ast.SelectionSet, obj *models.LightChannel) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lightChannelImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LightChannel")
		case "name":

			out.Values[i] = ec._LightChannel_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mSPPrincipalImplementors = []string{"MSPPrincipal"}

func (ec *executionContext) _MSPPrincipal(ctx context.Context, sel ast.SelectionSet, obj *models.MSPPrincipal) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mSPPrincipalImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MSPPrincipal")
		case "combined":

			out.Values[i] = ec._MSPPrincipal_combined(ctx, field, obj)

		case "role":

			out.Values[i] = ec._MSPPrincipal_role(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mSPPrincipalCombinedImplementors = []string{"MSPPrincipalCombined"}

func (ec *executionContext) _MSPPrincipalCombined(ctx context.Context, sel ast.SelectionSet, obj *models.MSPPrincipalCombined) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mSPPrincipalCombinedImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MSPPrincipalCombined")
		case "classification":

			out.Values[i] = ec._MSPPrincipalCombined_classification(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mspPrincipals":

			out.Values[i] = ec._MSPPrincipalCombined_mspPrincipals(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mSPPrincipalRoleImplementors = []string{"MSPPrincipalRole"}

func (ec *executionContext) _MSPPrincipalRole(ctx context.Context, sel ast.SelectionSet, obj *models.MSPPrincipalRole) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mSPPrincipalRoleImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MSPPrincipalRole")
		case "mspID":

			out.Values[i] = ec._MSPPrincipalRole_mspID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "role":

			out.Values[i] = ec._MSPPrincipalRole_role(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createPeer":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createPeer(ctx, field)
			})

		case "updatePeer":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updatePeer(ctx, field)
			})

		case "createOrderer":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createOrderer(ctx, field)
			})

		case "updateOrderer":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateOrderer(ctx, field)
			})

		case "createCA":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createCA(ctx, field)
			})

		case "updateCA":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateCA(ctx, field)
			})

		case "renewPeerCertificates":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_renewPeerCertificates(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "renewOrdererCertificates":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_renewOrdererCertificates(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateChannel":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateChannel(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "getUpdateChannelBlock":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_getUpdateChannelBlock(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var namespaceImplementors = []string{"Namespace"}

func (ec *executionContext) _Namespace(ctx context.Context, sel ast.SelectionSet, obj *models.Namespace) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, namespaceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Namespace")
		case "name":

			out.Values[i] = ec._Namespace_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var networkAddressImplementors = []string{"NetworkAddress"}

func (ec *executionContext) _NetworkAddress(ctx context.Context, sel ast.SelectionSet, obj *models.NetworkAddress) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, networkAddressImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NetworkAddress")
		case "host":

			out.Values[i] = ec._NetworkAddress_host(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "port":

			out.Values[i] = ec._NetworkAddress_port(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var nodeOUsImplementors = []string{"NodeOUs"}

func (ec *executionContext) _NodeOUs(ctx context.Context, sel ast.SelectionSet, obj *models.NodeOUs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nodeOUsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NodeOUs")
		case "enable":

			out.Values[i] = ec._NodeOUs_enable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clientOUIdentifier":

			out.Values[i] = ec._NodeOUs_clientOUIdentifier(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "peerOUIdentifier":

			out.Values[i] = ec._NodeOUs_peerOUIdentifier(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "adminOUIdentifier":

			out.Values[i] = ec._NodeOUs_adminOUIdentifier(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ordererOUIdentifier":

			out.Values[i] = ec._NodeOUs_ordererOUIdentifier(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var oUIdentifierImplementors = []string{"OUIdentifier"}

func (ec *executionContext) _OUIdentifier(ctx context.Context, sel ast.SelectionSet, obj *models.OUIdentifier) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oUIdentifierImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OUIdentifier")
		case "certificate":

			out.Values[i] = ec._OUIdentifier_certificate(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ouIdentifier":

			out.Values[i] = ec._OUIdentifier_ouIdentifier(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ordererImplementors = []string{"Orderer"}

func (ec *executionContext) _Orderer(ctx context.Context, sel ast.SelectionSet, obj *models.Orderer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ordererImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Orderer")
		case "name":

			out.Values[i] = ec._Orderer_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "namespace":

			out.Values[i] = ec._Orderer_namespace(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "yaml":

			out.Values[i] = ec._Orderer_yaml(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "storage":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Orderer_storage(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ordererConfigImplementors = []string{"OrdererConfig"}

func (ec *executionContext) _OrdererConfig(ctx context.Context, sel ast.SelectionSet, obj *models.OrdererConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ordererConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrdererConfig")
		case "type":

			out.Values[i] = ec._OrdererConfig_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "batchTimeout":

			out.Values[i] = ec._OrdererConfig_batchTimeout(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "batchSize":

			out.Values[i] = ec._OrdererConfig_batchSize(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maxChannels":

			out.Values[i] = ec._OrdererConfig_maxChannels(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "capabilities":

			out.Values[i] = ec._OrdererConfig_capabilities(ctx, field, obj)

		case "state":

			out.Values[i] = ec._OrdererConfig_state(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "policies":

			out.Values[i] = ec._OrdererConfig_policies(ctx, field, obj)

		case "etcdDraft":

			out.Values[i] = ec._OrdererConfig_etcdDraft(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "organizations":

			out.Values[i] = ec._OrdererConfig_organizations(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ordererConfigBatchSizeImplementors = []string{"OrdererConfigBatchSize"}

func (ec *executionContext) _OrdererConfigBatchSize(ctx context.Context, sel ast.SelectionSet, obj *models.OrdererConfigBatchSize) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ordererConfigBatchSizeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrdererConfigBatchSize")
		case "maxMessageCount":

			out.Values[i] = ec._OrdererConfigBatchSize_maxMessageCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "absoluteMaxBytes":

			out.Values[i] = ec._OrdererConfigBatchSize_absoluteMaxBytes(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "preferredMaxBytes":

			out.Values[i] = ec._OrdererConfigBatchSize_preferredMaxBytes(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ordererConfigRaftImplementors = []string{"OrdererConfigRaft"}

func (ec *executionContext) _OrdererConfigRaft(ctx context.Context, sel ast.SelectionSet, obj *models.OrdererConfigRaft) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ordererConfigRaftImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrdererConfigRaft")
		case "consenters":

			out.Values[i] = ec._OrdererConfigRaft_consenters(ctx, field, obj)

		case "options":

			out.Values[i] = ec._OrdererConfigRaft_options(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ordererConfigRaftConsenterImplementors = []string{"OrdererConfigRaftConsenter"}

func (ec *executionContext) _OrdererConfigRaftConsenter(ctx context.Context, sel ast.SelectionSet, obj *models.OrdererConfigRaftConsenter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ordererConfigRaftConsenterImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrdererConfigRaftConsenter")
		case "address":

			out.Values[i] = ec._OrdererConfigRaftConsenter_address(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clientTlsCert":

			out.Values[i] = ec._OrdererConfigRaftConsenter_clientTlsCert(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "serverTlsCert":

			out.Values[i] = ec._OrdererConfigRaftConsenter_serverTlsCert(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ordererConfigRaftOptionsImplementors = []string{"OrdererConfigRaftOptions"}

func (ec *executionContext) _OrdererConfigRaftOptions(ctx context.Context, sel ast.SelectionSet, obj *models.OrdererConfigRaftOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ordererConfigRaftOptionsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrdererConfigRaftOptions")
		case "tickInterval":

			out.Values[i] = ec._OrdererConfigRaftOptions_tickInterval(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "electionTick":

			out.Values[i] = ec._OrdererConfigRaftOptions_electionTick(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "heartbeatTick":

			out.Values[i] = ec._OrdererConfigRaftOptions_heartbeatTick(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maxInflightBlocks":

			out.Values[i] = ec._OrdererConfigRaftOptions_maxInflightBlocks(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "snapshotIntervalSize":

			out.Values[i] = ec._OrdererConfigRaftOptions_snapshotIntervalSize(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ordererStorageImplementors = []string{"OrdererStorage"}

func (ec *executionContext) _OrdererStorage(ctx context.Context, sel ast.SelectionSet, obj *models.OrdererStorage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ordererStorageImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrdererStorage")
		case "orderer":

			out.Values[i] = ec._OrdererStorage_orderer(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pDCReadImplementors = []string{"PDCRead"}

func (ec *executionContext) _PDCRead(ctx context.Context, sel ast.SelectionSet, obj *models.PDCRead) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pDCReadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PDCRead")
		case "collectionName":

			out.Values[i] = ec._PDCRead_collectionName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "key":

			out.Values[i] = ec._PDCRead_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "block":

			out.Values[i] = ec._PDCRead_block(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "txNum":

			out.Values[i] = ec._PDCRead_txNum(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pDCReadHashImplementors = []string{"PDCReadHash"}

func (ec *executionContext) _PDCReadHash(ctx context.Context, sel ast.SelectionSet, obj *models.PDCReadHash) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pDCReadHashImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PDCReadHash")
		case "pdcName":

			out.Values[i] = ec._PDCReadHash_pdcName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "keyHash":

			out.Values[i] = ec._PDCReadHash_keyHash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rwSetHash":

			out.Values[i] = ec._PDCReadHash_rwSetHash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":

			out.Values[i] = ec._PDCReadHash_version(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pDCReadVersionImplementors = []string{"PDCReadVersion"}

func (ec *executionContext) _PDCReadVersion(ctx context.Context, sel ast.SelectionSet, obj *models.PDCReadVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pDCReadVersionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PDCReadVersion")
		case "blockNum":

			out.Values[i] = ec._PDCReadVersion_blockNum(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "txNum":

			out.Values[i] = ec._PDCReadVersion_txNum(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pDCWriteImplementors = []string{"PDCWrite"}

func (ec *executionContext) _PDCWrite(ctx context.Context, sel ast.SelectionSet, obj *models.PDCWrite) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pDCWriteImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PDCWrite")
		case "collectionName":

			out.Values[i] = ec._PDCWrite_collectionName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleted":

			out.Values[i] = ec._PDCWrite_deleted(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "key":

			out.Values[i] = ec._PDCWrite_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._PDCWrite_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pDCWriteHashImplementors = []string{"PDCWriteHash"}

func (ec *executionContext) _PDCWriteHash(ctx context.Context, sel ast.SelectionSet, obj *models.PDCWriteHash) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pDCWriteHashImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PDCWriteHash")
		case "pdcName":

			out.Values[i] = ec._PDCWriteHash_pdcName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "keyHash":

			out.Values[i] = ec._PDCWriteHash_keyHash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rwSetHash":

			out.Values[i] = ec._PDCWriteHash_rwSetHash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "valueHash":

			out.Values[i] = ec._PDCWriteHash_valueHash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDelete":

			out.Values[i] = ec._PDCWriteHash_isDelete(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isPurge":

			out.Values[i] = ec._PDCWriteHash_isPurge(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var peerImplementors = []string{"Peer"}

func (ec *executionContext) _Peer(ctx context.Context, sel ast.SelectionSet, obj *models.Peer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, peerImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Peer")
		case "name":

			out.Values[i] = ec._Peer_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "namespace":

			out.Values[i] = ec._Peer_namespace(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "yaml":

			out.Values[i] = ec._Peer_yaml(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "storage":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Peer_storage(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var peerStorageImplementors = []string{"PeerStorage"}

func (ec *executionContext) _PeerStorage(ctx context.Context, sel ast.SelectionSet, obj *models.PeerStorage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, peerStorageImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PeerStorage")
		case "chaincode":

			out.Values[i] = ec._PeerStorage_chaincode(ctx, field, obj)

		case "couchDB":

			out.Values[i] = ec._PeerStorage_couchDB(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "peer":

			out.Values[i] = ec._PeerStorage_peer(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var privateDataCollectionImplementors = []string{"PrivateDataCollection"}

func (ec *executionContext) _PrivateDataCollection(ctx context.Context, sel ast.SelectionSet, obj *models.PrivateDataCollection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, privateDataCollectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PrivateDataCollection")
		case "name":

			out.Values[i] = ec._PrivateDataCollection_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "requiredPeerCount":

			out.Values[i] = ec._PrivateDataCollection_requiredPeerCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maxPeerCount":

			out.Values[i] = ec._PrivateDataCollection_maxPeerCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "blockToLive":

			out.Values[i] = ec._PrivateDataCollection_blockToLive(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "memberOnlyRead":

			out.Values[i] = ec._PrivateDataCollection_memberOnlyRead(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "memberOnlyWrite":

			out.Values[i] = ec._PrivateDataCollection_memberOnlyWrite(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "endorsementPolicy":

			out.Values[i] = ec._PrivateDataCollection_endorsementPolicy(ctx, field, obj)

		case "memberOrgsPolicy":

			out.Values[i] = ec._PrivateDataCollection_memberOrgsPolicy(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "peers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_peers(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "peer":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_peer(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "orderers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_orderers(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "orderer":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_orderer(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "networkConfigEnabled":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_networkConfigEnabled(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cas":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cas(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "ca":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ca(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "namespaces":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_namespaces(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "storageClasses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_storageClasses(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "channels":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_channels(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "channel":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_channel(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "blocks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_blocks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "block":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_block(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "blockWithPrivateData":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_blockWithPrivateData(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "blockByTXID":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_blockByTXID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var renewOrdererCertificatesResponseImplementors = []string{"RenewOrdererCertificatesResponse"}

func (ec *executionContext) _RenewOrdererCertificatesResponse(ctx context.Context, sel ast.SelectionSet, obj *models.RenewOrdererCertificatesResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, renewOrdererCertificatesResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RenewOrdererCertificatesResponse")
		case "orderer":

			out.Values[i] = ec._RenewOrdererCertificatesResponse_orderer(ctx, field, obj)

		case "errors":

			out.Values[i] = ec._RenewOrdererCertificatesResponse_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var renewPeerCertificatesResponseImplementors = []string{"RenewPeerCertificatesResponse"}

func (ec *executionContext) _RenewPeerCertificatesResponse(ctx context.Context, sel ast.SelectionSet, obj *models.RenewPeerCertificatesResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, renewPeerCertificatesResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RenewPeerCertificatesResponse")
		case "peer":

			out.Values[i] = ec._RenewPeerCertificatesResponse_peer(ctx, field, obj)

		case "errors":

			out.Values[i] = ec._RenewPeerCertificatesResponse_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var signaturePolicyImplementors = []string{"SignaturePolicy"}

func (ec *executionContext) _SignaturePolicy(ctx context.Context, sel ast.SelectionSet, obj *models.SignaturePolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, signaturePolicyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SignaturePolicy")
		case "version":

			out.Values[i] = ec._SignaturePolicy_version(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rule":

			out.Values[i] = ec._SignaturePolicy_rule(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "principals":

			out.Values[i] = ec._SignaturePolicy_principals(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var signaturePolicyNOutOfImplementors = []string{"SignaturePolicyNOutOf"}

func (ec *executionContext) _SignaturePolicyNOutOf(ctx context.Context, sel ast.SelectionSet, obj *models.SignaturePolicyNOutOf) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, signaturePolicyNOutOfImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SignaturePolicyNOutOf")
		case "n":

			out.Values[i] = ec._SignaturePolicyNOutOf_n(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rules":

			out.Values[i] = ec._SignaturePolicyNOutOf_rules(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var signaturePolicyRuleImplementors = []string{"SignaturePolicyRule"}

func (ec *executionContext) _SignaturePolicyRule(ctx context.Context, sel ast.SelectionSet, obj *models.SignaturePolicyRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, signaturePolicyRuleImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SignaturePolicyRule")
		case "type":

			out.Values[i] = ec._SignaturePolicyRule_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "noutOf":

			out.Values[i] = ec._SignaturePolicyRule_noutOf(ctx, field, obj)

		case "signedBy":

			out.Values[i] = ec._SignaturePolicyRule_signedBy(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var signaturePolicySignedByImplementors = []string{"SignaturePolicySignedBy"}

func (ec *executionContext) _SignaturePolicySignedBy(ctx context.Context, sel ast.SelectionSet, obj *models.SignaturePolicySignedBy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, signaturePolicySignedByImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SignaturePolicySignedBy")
		case "signedBy":

			out.Values[i] = ec._SignaturePolicySignedBy_signedBy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var storageClassImplementors = []string{"StorageClass"}

func (ec *executionContext) _StorageClass(ctx context.Context, sel ast.SelectionSet, obj *models.StorageClass) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, storageClassImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StorageClass")
		case "name":

			out.Values[i] = ec._StorageClass_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var storageUsageImplementors = []string{"StorageUsage"}

func (ec *executionContext) _StorageUsage(ctx context.Context, sel ast.SelectionSet, obj *models.StorageUsage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, storageUsageImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StorageUsage")
		case "used":

			out.Values[i] = ec._StorageUsage_used(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "usedGB":

			out.Values[i] = ec._StorageUsage_usedGB(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "free":

			out.Values[i] = ec._StorageUsage_free(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "freeGB":

			out.Values[i] = ec._StorageUsage_freeGB(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "size":

			out.Values[i] = ec._StorageUsage_size(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sizeGB":

			out.Values[i] = ec._StorageUsage_sizeGB(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "percentageUsed":

			out.Values[i] = ec._StorageUsage_percentageUsed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionImplementors = []string{"Transaction"}

func (ec *executionContext) _Transaction(ctx context.Context, sel ast.SelectionSet, obj *models.Transaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transaction")
		case "txID":

			out.Values[i] = ec._Transaction_txID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec._Transaction_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":

			out.Values[i] = ec._Transaction_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":

			out.Values[i] = ec._Transaction_version(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "path":

			out.Values[i] = ec._Transaction_path(ctx, field, obj)

		case "response":

			out.Values[i] = ec._Transaction_response(ctx, field, obj)

		case "request":

			out.Values[i] = ec._Transaction_request(ctx, field, obj)

		case "chaincode":

			out.Values[i] = ec._Transaction_chaincode(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "writes":

			out.Values[i] = ec._Transaction_writes(ctx, field, obj)

		case "reads":

			out.Values[i] = ec._Transaction_reads(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionReadImplementors = []string{"TransactionRead"}

func (ec *executionContext) _TransactionRead(ctx context.Context, sel ast.SelectionSet, obj *models.TransactionRead) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionReadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionRead")
		case "chaincodeID":

			out.Values[i] = ec._TransactionRead_chaincodeID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "key":

			out.Values[i] = ec._TransactionRead_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "blockNumVersion":

			out.Values[i] = ec._TransactionRead_blockNumVersion(ctx, field, obj)

		case "txNumVersion":

			out.Values[i] = ec._TransactionRead_txNumVersion(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionWithPrivateDataImplementors = []string{"TransactionWithPrivateData"}

func (ec *executionContext) _TransactionWithPrivateData(ctx context.Context, sel ast.SelectionSet, obj *models.TransactionWithPrivateData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionWithPrivateDataImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionWithPrivateData")
		case "txID":

			out.Values[i] = ec._TransactionWithPrivateData_txID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec._TransactionWithPrivateData_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":

			out.Values[i] = ec._TransactionWithPrivateData_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":

			out.Values[i] = ec._TransactionWithPrivateData_version(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "path":

			out.Values[i] = ec._TransactionWithPrivateData_path(ctx, field, obj)

		case "response":

			out.Values[i] = ec._TransactionWithPrivateData_response(ctx, field, obj)

		case "request":

			out.Values[i] = ec._TransactionWithPrivateData_request(ctx, field, obj)

		case "chaincode":

			out.Values[i] = ec._TransactionWithPrivateData_chaincode(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "writes":

			out.Values[i] = ec._TransactionWithPrivateData_writes(ctx, field, obj)

		case "reads":

			out.Values[i] = ec._TransactionWithPrivateData_reads(ctx, field, obj)

		case "pdcWrites":

			out.Values[i] = ec._TransactionWithPrivateData_pdcWrites(ctx, field, obj)

		case "pdcReads":

			out.Values[i] = ec._TransactionWithPrivateData_pdcReads(ctx, field, obj)

		case "pdcWriteHashes":

			out.Values[i] = ec._TransactionWithPrivateData_pdcWriteHashes(ctx, field, obj)

		case "pdcReadHashes":

			out.Values[i] = ec._TransactionWithPrivateData_pdcReadHashes(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionWriteImplementors = []string{"TransactionWrite"}

func (ec *executionContext) _TransactionWrite(ctx context.Context, sel ast.SelectionSet, obj *models.TransactionWrite) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionWriteImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionWrite")
		case "chaincodeID":

			out.Values[i] = ec._TransactionWrite_chaincodeID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleted":

			out.Values[i] = ec._TransactionWrite_deleted(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "key":

			out.Values[i] = ec._TransactionWrite_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._TransactionWrite_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateChannelResponseImplementors = []string{"UpdateChannelResponse"}

func (ec *executionContext) _UpdateChannelResponse(ctx context.Context, sel ast.SelectionSet, obj *models.UpdateChannelResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateChannelResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateChannelResponse")
		case "errors":

			out.Values[i] = ec._UpdateChannelResponse_errors(ctx, field, obj)

		case "transactionID":

			out.Values[i] = ec._UpdateChannelResponse_transactionID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNApplicationConfigInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐApplicationConfigInput(ctx context.Context, v interface{}) (*models.ApplicationConfigInput, error) {
	res, err := ec.unmarshalInputApplicationConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBlock2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐBlock(ctx context.Context, sel ast.SelectionSet, v models.Block) graphql.Marshaler {
	return ec._Block(ctx, sel, &v)
}

func (ec *executionContext) marshalNBlock2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐBlock(ctx context.Context, sel ast.SelectionSet, v *models.Block) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Block(ctx, sel, v)
}

func (ec *executionContext) marshalNBlockWithPrivateData2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐBlockWithPrivateData(ctx context.Context, sel ast.SelectionSet, v models.BlockWithPrivateData) graphql.Marshaler {
	return ec._BlockWithPrivateData(ctx, sel, &v)
}

func (ec *executionContext) marshalNBlockWithPrivateData2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐBlockWithPrivateData(ctx context.Context, sel ast.SelectionSet, v *models.BlockWithPrivateData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BlockWithPrivateData(ctx, sel, v)
}

func (ec *executionContext) marshalNBlocksResponse2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐBlocksResponse(ctx context.Context, sel ast.SelectionSet, v models.BlocksResponse) graphql.Marshaler {
	return ec._BlocksResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNBlocksResponse2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐBlocksResponse(ctx context.Context, sel ast.SelectionSet, v *models.BlocksResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BlocksResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCA2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCa(ctx context.Context, sel ast.SelectionSet, v *models.Ca) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CA(ctx, sel, v)
}

func (ec *executionContext) marshalNChaincodeApproval2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChaincodeApproval(ctx context.Context, sel ast.SelectionSet, v *models.ChaincodeApproval) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChaincodeApproval(ctx, sel, v)
}

func (ec *executionContext) marshalNChannel2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannel(ctx context.Context, sel ast.SelectionSet, v models.Channel) graphql.Marshaler {
	return ec._Channel(ctx, sel, &v)
}

func (ec *executionContext) marshalNChannel2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannel(ctx context.Context, sel ast.SelectionSet, v *models.Channel) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Channel(ctx, sel, v)
}

func (ec *executionContext) marshalNChannelACL2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelACL(ctx context.Context, sel ast.SelectionSet, v *models.ChannelACL) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelACL(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChannelACLInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelACLInput(ctx context.Context, v interface{}) (*models.ChannelACLInput, error) {
	res, err := ec.unmarshalInputChannelACLInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChannelChaincode2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelChaincode(ctx context.Context, sel ast.SelectionSet, v *models.ChannelChaincode) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelChaincode(ctx, sel, v)
}

func (ec *executionContext) marshalNChannelConfig2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelConfig(ctx context.Context, sel ast.SelectionSet, v *models.ChannelConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChannelConfigInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelConfigInput(ctx context.Context, v interface{}) (*models.ChannelConfigInput, error) {
	res, err := ec.unmarshalInputChannelConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChannelMSP2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelMsp(ctx context.Context, sel ast.SelectionSet, v *models.ChannelMsp) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelMSP(ctx, sel, v)
}

func (ec *executionContext) marshalNChannelOrg2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelOrg(ctx context.Context, sel ast.SelectionSet, v *models.ChannelOrg) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelOrg(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChannelOrganization2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelOrganization(ctx context.Context, v interface{}) (*models.ChannelOrganization, error) {
	res, err := ec.unmarshalInputChannelOrganization(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChannelPeer2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelPeer(ctx context.Context, sel ast.SelectionSet, v *models.ChannelPeer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelPeer(ctx, sel, v)
}

func (ec *executionContext) marshalNChannelPolicy2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelPolicy(ctx context.Context, sel ast.SelectionSet, v *models.ChannelPolicy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelPolicy(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateCAInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCreateCAInput(ctx context.Context, v interface{}) (models.CreateCAInput, error) {
	res, err := ec.unmarshalInputCreateCAInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateOrdererInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCreateOrdererInput(ctx context.Context, v interface{}) (models.CreateOrdererInput, error) {
	res, err := ec.unmarshalInputCreateOrdererInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreatePeerInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCreatePeerInput(ctx context.Context, v interface{}) (models.CreatePeerInput, error) {
	res, err := ec.unmarshalInputCreatePeerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCryptoConfig2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCryptoConfig(ctx context.Context, sel ast.SelectionSet, v *models.CryptoConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CryptoConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCryptoConfigInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCryptoConfigInput(ctx context.Context, v interface{}) (*models.CryptoConfigInput, error) {
	res, err := ec.unmarshalInputCryptoConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNError2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐError(ctx context.Context, sel ast.SelectionSet, v *models.Error) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Error(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalNGetUpdateChannelBlockInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐGetUpdateChannelBlockInput(ctx context.Context, v interface{}) (models.GetUpdateChannelBlockInput, error) {
	res, err := ec.unmarshalInputGetUpdateChannelBlockInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetUpdateChannelBlockResponse2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐGetUpdateChannelBlockResponse(ctx context.Context, sel ast.SelectionSet, v models.GetUpdateChannelBlockResponse) graphql.Marshaler {
	return ec._GetUpdateChannelBlockResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetUpdateChannelBlockResponse2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐGetUpdateChannelBlockResponse(ctx context.Context, sel ast.SelectionSet, v *models.GetUpdateChannelBlockResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetUpdateChannelBlockResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNLightChannel2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐLightChannel(ctx context.Context, sel ast.SelectionSet, v *models.LightChannel) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LightChannel(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMSPInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐMSPInput(ctx context.Context, v interface{}) (*models.MSPInput, error) {
	res, err := ec.unmarshalInputMSPInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMSPPrincipal2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐMSPPrincipal(ctx context.Context, sel ast.SelectionSet, v *models.MSPPrincipal) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MSPPrincipal(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMSPSignature2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐMSPSignature(ctx context.Context, v interface{}) (*models.MSPSignature, error) {
	res, err := ec.unmarshalInputMSPSignature(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNameAndNamespace2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNameAndNamespace(ctx context.Context, v interface{}) (models.NameAndNamespace, error) {
	res, err := ec.unmarshalInputNameAndNamespace(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNamespace2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNamespace(ctx context.Context, sel ast.SelectionSet, v *models.Namespace) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Namespace(ctx, sel, v)
}

func (ec *executionContext) marshalNNetworkAddress2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNetworkAddress(ctx context.Context, sel ast.SelectionSet, v *models.NetworkAddress) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NetworkAddress(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNetworkAddressInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNetworkAddressInput(ctx context.Context, v interface{}) (*models.NetworkAddressInput, error) {
	res, err := ec.unmarshalInputNetworkAddressInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNodeOUs2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNodeOUs(ctx context.Context, sel ast.SelectionSet, v *models.NodeOUs) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NodeOUs(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNodeOUsInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNodeOUsInput(ctx context.Context, v interface{}) (*models.NodeOUsInput, error) {
	res, err := ec.unmarshalInputNodeOUsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOUIdentifier2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOUIdentifier(ctx context.Context, sel ast.SelectionSet, v *models.OUIdentifier) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OUIdentifier(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOUIdentifierInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOUIdentifierInput(ctx context.Context, v interface{}) (*models.OUIdentifierInput, error) {
	res, err := ec.unmarshalInputOUIdentifierInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderer2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrderer(ctx context.Context, sel ast.SelectionSet, v *models.Orderer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Orderer(ctx, sel, v)
}

func (ec *executionContext) marshalNOrdererConfig2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfig(ctx context.Context, sel ast.SelectionSet, v *models.OrdererConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrdererConfig(ctx, sel, v)
}

func (ec *executionContext) marshalNOrdererConfigBatchSize2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigBatchSize(ctx context.Context, sel ast.SelectionSet, v *models.OrdererConfigBatchSize) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrdererConfigBatchSize(ctx, sel, v)
}

func (ec *executionContext) marshalNOrdererConfigRaft2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigRaft(ctx context.Context, sel ast.SelectionSet, v *models.OrdererConfigRaft) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrdererConfigRaft(ctx, sel, v)
}

func (ec *executionContext) marshalNOrdererConfigRaftConsenter2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigRaftConsenter(ctx context.Context, sel ast.SelectionSet, v *models.OrdererConfigRaftConsenter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrdererConfigRaftConsenter(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOrdererConfigRaftConsenterInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigRaftConsenterInput(ctx context.Context, v interface{}) (*models.OrdererConfigRaftConsenterInput, error) {
	res, err := ec.unmarshalInputOrdererConfigRaftConsenterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrdererConfigRaftOptions2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigRaftOptions(ctx context.Context, sel ast.SelectionSet, v *models.OrdererConfigRaftOptions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrdererConfigRaftOptions(ctx, sel, v)
}

func (ec *executionContext) marshalNPDCRead2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCRead(ctx context.Context, sel ast.SelectionSet, v *models.PDCRead) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PDCRead(ctx, sel, v)
}

func (ec *executionContext) marshalNPDCReadHash2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCReadHash(ctx context.Context, sel ast.SelectionSet, v *models.PDCReadHash) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PDCReadHash(ctx, sel, v)
}

func (ec *executionContext) marshalNPDCWrite2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCWrite(ctx context.Context, sel ast.SelectionSet, v *models.PDCWrite) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PDCWrite(ctx, sel, v)
}

func (ec *executionContext) marshalNPDCWriteHash2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCWriteHash(ctx context.Context, sel ast.SelectionSet, v *models.PDCWriteHash) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PDCWriteHash(ctx, sel, v)
}

func (ec *executionContext) marshalNPeer2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPeer(ctx context.Context, sel ast.SelectionSet, v *models.Peer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Peer(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPolicyInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPolicyInput(ctx context.Context, v interface{}) (*models.PolicyInput, error) {
	res, err := ec.unmarshalInputPolicyInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPrivateDataCollection2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPrivateDataCollection(ctx context.Context, sel ast.SelectionSet, v *models.PrivateDataCollection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PrivateDataCollection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRawSignature2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐRawSignature(ctx context.Context, v interface{}) (*models.RawSignature, error) {
	res, err := ec.unmarshalInputRawSignature(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRenewOrdererCertificatesInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐRenewOrdererCertificatesInput(ctx context.Context, v interface{}) (models.RenewOrdererCertificatesInput, error) {
	res, err := ec.unmarshalInputRenewOrdererCertificatesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRenewOrdererCertificatesResponse2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐRenewOrdererCertificatesResponse(ctx context.Context, sel ast.SelectionSet, v models.RenewOrdererCertificatesResponse) graphql.Marshaler {
	return ec._RenewOrdererCertificatesResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRenewOrdererCertificatesResponse2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐRenewOrdererCertificatesResponse(ctx context.Context, sel ast.SelectionSet, v *models.RenewOrdererCertificatesResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RenewOrdererCertificatesResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRenewPeerCertificatesInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐRenewPeerCertificatesInput(ctx context.Context, v interface{}) (models.RenewPeerCertificatesInput, error) {
	res, err := ec.unmarshalInputRenewPeerCertificatesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRenewPeerCertificatesResponse2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐRenewPeerCertificatesResponse(ctx context.Context, sel ast.SelectionSet, v models.RenewPeerCertificatesResponse) graphql.Marshaler {
	return ec._RenewPeerCertificatesResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRenewPeerCertificatesResponse2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐRenewPeerCertificatesResponse(ctx context.Context, sel ast.SelectionSet, v *models.RenewPeerCertificatesResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RenewPeerCertificatesResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNSignaturePolicy2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐSignaturePolicy(ctx context.Context, sel ast.SelectionSet, v *models.SignaturePolicy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SignaturePolicy(ctx, sel, v)
}

func (ec *executionContext) marshalNSignaturePolicyRule2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐSignaturePolicyRule(ctx context.Context, sel ast.SelectionSet, v *models.SignaturePolicyRule) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SignaturePolicyRule(ctx, sel, v)
}

func (ec *executionContext) marshalNStorageClass2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐStorageClass(ctx context.Context, sel ast.SelectionSet, v *models.StorageClass) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StorageClass(ctx, sel, v)
}

func (ec *executionContext) marshalNStorageUsage2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐStorageUsage(ctx context.Context, sel ast.SelectionSet, v *models.StorageUsage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StorageUsage(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTransaction2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransaction(ctx context.Context, sel ast.SelectionSet, v *models.Transaction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Transaction(ctx, sel, v)
}

func (ec *executionContext) marshalNTransactionRead2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionRead(ctx context.Context, sel ast.SelectionSet, v *models.TransactionRead) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionRead(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTransactionType2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionType(ctx context.Context, v interface{}) (models.TransactionType, error) {
	var res models.TransactionType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTransactionType2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionType(ctx context.Context, sel ast.SelectionSet, v models.TransactionType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTransactionWithPrivateData2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionWithPrivateData(ctx context.Context, sel ast.SelectionSet, v *models.TransactionWithPrivateData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionWithPrivateData(ctx, sel, v)
}

func (ec *executionContext) marshalNTransactionWrite2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionWrite(ctx context.Context, sel ast.SelectionSet, v *models.TransactionWrite) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionWrite(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateCAInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐUpdateCAInput(ctx context.Context, v interface{}) (models.UpdateCAInput, error) {
	res, err := ec.unmarshalInputUpdateCAInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateChannelInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐUpdateChannelInput(ctx context.Context, v interface{}) (models.UpdateChannelInput, error) {
	res, err := ec.unmarshalInputUpdateChannelInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateChannelResponse2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐUpdateChannelResponse(ctx context.Context, sel ast.SelectionSet, v models.UpdateChannelResponse) graphql.Marshaler {
	return ec._UpdateChannelResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateChannelResponse2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐUpdateChannelResponse(ctx context.Context, sel ast.SelectionSet, v *models.UpdateChannelResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateChannelResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateeOrdererInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐUpdateeOrdererInput(ctx context.Context, v interface{}) (models.UpdateeOrdererInput, error) {
	res, err := ec.unmarshalInputUpdateeOrdererInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateePeerInput2githubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐUpdateePeerInput(ctx context.Context, v interface{}) (models.UpdateePeerInput, error) {
	res, err := ec.unmarshalInputUpdateePeerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOApplicationConfig2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐApplicationConfig(ctx context.Context, sel ast.SelectionSet, v *models.ApplicationConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOApplicationPolicy2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐApplicationPolicy(ctx context.Context, sel ast.SelectionSet, v *models.ApplicationPolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationPolicy(ctx, sel, v)
}

func (ec *executionContext) marshalOBlock2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐBlockᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Block) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBlock2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐBlock(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOCA2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCaᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Ca) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCA2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCa(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCA2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCa(ctx context.Context, sel ast.SelectionSet, v *models.Ca) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CA(ctx, sel, v)
}

func (ec *executionContext) marshalOCAStorage2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐCAStorage(ctx context.Context, sel ast.SelectionSet, v *models.CAStorage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CAStorage(ctx, sel, v)
}

func (ec *executionContext) marshalOChaincodeApproval2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChaincodeApprovalᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.ChaincodeApproval) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChaincodeApproval2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChaincodeApproval(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOChannelACL2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelACLᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.ChannelACL) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChannelACL2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelACL(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOChannelACLInput2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelACLInputᚄ(ctx context.Context, v interface{}) ([]*models.ChannelACLInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.ChannelACLInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNChannelACLInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelACLInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOChannelChaincode2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelChaincodeᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.ChannelChaincode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChannelChaincode2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelChaincode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOChannelOrg2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelOrgᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.ChannelOrg) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChannelOrg2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelOrg(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOChannelOrganization2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelOrganization(ctx context.Context, v interface{}) ([]*models.ChannelOrganization, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.ChannelOrganization, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOChannelOrganization2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelOrganization(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOChannelOrganization2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelOrganizationᚄ(ctx context.Context, v interface{}) ([]*models.ChannelOrganization, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.ChannelOrganization, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNChannelOrganization2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelOrganization(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOChannelOrganization2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelOrganization(ctx context.Context, v interface{}) (*models.ChannelOrganization, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputChannelOrganization(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOChannelPeer2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelPeerᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.ChannelPeer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChannelPeer2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelPeer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOChannelPolicy2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelPolicyᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.ChannelPolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChannelPolicy2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐChannelPolicy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOError2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐErrorᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Error) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNError2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOEtcdRaftInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐEtcdRaftInput(ctx context.Context, v interface{}) (*models.EtcdRaftInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEtcdRaftInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOLightChannel2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐLightChannelᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.LightChannel) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLightChannel2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐLightChannel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOMSPPrincipal2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐMSPPrincipalᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.MSPPrincipal) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMSPPrincipal2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐMSPPrincipal(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOMSPPrincipalCombined2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐMSPPrincipalCombined(ctx context.Context, sel ast.SelectionSet, v *models.MSPPrincipalCombined) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MSPPrincipalCombined(ctx, sel, v)
}

func (ec *executionContext) marshalOMSPPrincipalRole2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐMSPPrincipalRole(ctx context.Context, sel ast.SelectionSet, v *models.MSPPrincipalRole) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MSPPrincipalRole(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMSPSignature2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐMSPSignatureᚄ(ctx context.Context, v interface{}) ([]*models.MSPSignature, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.MSPSignature, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMSPSignature2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐMSPSignature(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalONamespace2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNamespaceᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Namespace) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNamespace2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNamespace(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalONetworkAddress2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNetworkAddressᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.NetworkAddress) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNetworkAddress2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNetworkAddress(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalONetworkAddressInput2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNetworkAddressInputᚄ(ctx context.Context, v interface{}) ([]*models.NetworkAddressInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.NetworkAddressInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNNetworkAddressInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐNetworkAddressInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOOUIdentifier2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOUIdentifierᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.OUIdentifier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOUIdentifier2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOUIdentifier(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOOUIdentifierInput2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOUIdentifierInputᚄ(ctx context.Context, v interface{}) ([]*models.OUIdentifierInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.OUIdentifierInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNOUIdentifierInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOUIdentifierInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOOrderer2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Orderer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOrderer2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrderer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOOrderer2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrderer(ctx context.Context, sel ast.SelectionSet, v *models.Orderer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Orderer(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOrdererConfigBatchSizeInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigBatchSizeInput(ctx context.Context, v interface{}) (*models.OrdererConfigBatchSizeInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOrdererConfigBatchSizeInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOOrdererConfigInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigInput(ctx context.Context, v interface{}) (*models.OrdererConfigInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOrdererConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrdererConfigRaftConsenter2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigRaftConsenterᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.OrdererConfigRaftConsenter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOrdererConfigRaftConsenter2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigRaftConsenter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOOrdererConfigRaftConsenterInput2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigRaftConsenterInputᚄ(ctx context.Context, v interface{}) ([]*models.OrdererConfigRaftConsenterInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.OrdererConfigRaftConsenterInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNOrdererConfigRaftConsenterInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigRaftConsenterInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOOrdererConfigRaftOptionsInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererConfigRaftOptionsInput(ctx context.Context, v interface{}) (*models.OrdererConfigRaftOptionsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOrdererConfigRaftOptionsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrdererStorage2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐOrdererStorage(ctx context.Context, sel ast.SelectionSet, v *models.OrdererStorage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OrdererStorage(ctx, sel, v)
}

func (ec *executionContext) marshalOPDCRead2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCReadᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.PDCRead) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPDCRead2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCRead(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPDCReadHash2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCReadHashᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.PDCReadHash) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPDCReadHash2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCReadHash(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPDCReadVersion2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCReadVersion(ctx context.Context, sel ast.SelectionSet, v *models.PDCReadVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PDCReadVersion(ctx, sel, v)
}

func (ec *executionContext) marshalOPDCWrite2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCWriteᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.PDCWrite) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPDCWrite2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCWrite(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPDCWriteHash2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCWriteHashᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.PDCWriteHash) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPDCWriteHash2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPDCWriteHash(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPeer2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPeerᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Peer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPeer2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPeer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPeer2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPeer(ctx context.Context, sel ast.SelectionSet, v *models.Peer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Peer(ctx, sel, v)
}

func (ec *executionContext) marshalOPeerStorage2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPeerStorage(ctx context.Context, sel ast.SelectionSet, v *models.PeerStorage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PeerStorage(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPolicyInput2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPolicyInputᚄ(ctx context.Context, v interface{}) ([]*models.PolicyInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.PolicyInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPolicyInput2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPolicyInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPrivateDataCollection2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPrivateDataCollectionᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.PrivateDataCollection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPrivateDataCollection2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐPrivateDataCollection(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalORawSignature2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐRawSignatureᚄ(ctx context.Context, v interface{}) ([]*models.RawSignature, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.RawSignature, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRawSignature2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐRawSignature(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOSignaturePolicy2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐSignaturePolicy(ctx context.Context, sel ast.SelectionSet, v *models.SignaturePolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SignaturePolicy(ctx, sel, v)
}

func (ec *executionContext) marshalOSignaturePolicyNOutOf2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐSignaturePolicyNOutOf(ctx context.Context, sel ast.SelectionSet, v *models.SignaturePolicyNOutOf) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SignaturePolicyNOutOf(ctx, sel, v)
}

func (ec *executionContext) marshalOSignaturePolicyRule2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐSignaturePolicyRuleᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.SignaturePolicyRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSignaturePolicyRule2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐSignaturePolicyRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOSignaturePolicySignedBy2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐSignaturePolicySignedBy(ctx context.Context, sel ast.SelectionSet, v *models.SignaturePolicySignedBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SignaturePolicySignedBy(ctx, sel, v)
}

func (ec *executionContext) marshalOStorageClass2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐStorageClassᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.StorageClass) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStorageClass2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐStorageClass(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOStorageUsage2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐStorageUsage(ctx context.Context, sel ast.SelectionSet, v *models.StorageUsage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StorageUsage(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTransaction2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Transaction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransaction2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTransactionRead2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionReadᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.TransactionRead) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionRead2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionRead(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTransactionWithPrivateData2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionWithPrivateDataᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.TransactionWithPrivateData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionWithPrivateData2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionWithPrivateData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTransactionWrite2ᚕᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionWriteᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.TransactionWrite) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionWrite2ᚖgithubᚗcomᚋkfsoftwareᚋhlfᚑoperatorᚑuiᚋapiᚋgqlᚋmodelsᚐTransactionWrite(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
