// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/kfsoftware/hlf-operator-ui/api/gql/models"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	CA() CAResolver
	Channel() ChannelResolver
	Mutation() MutationResolver
	Orderer() OrdererResolver
	Peer() PeerResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	RequiresAuth func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	ApplicationConfig struct {
		Acls          func(childComplexity int) int
		Capabilities  func(childComplexity int) int
		Organizations func(childComplexity int) int
		Policies      func(childComplexity int) int
	}

	ApplicationPolicy struct {
		ChannelConfigPolicy func(childComplexity int) int
		SignaturePolicy     func(childComplexity int) int
	}

	Block struct {
		BlockNumber     func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		DataHash        func(childComplexity int) int
		NumTransactions func(childComplexity int) int
		Transactions    func(childComplexity int) int
	}

	BlockWithPrivateData struct {
		BlockNumber     func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		DataHash        func(childComplexity int) int
		NumTransactions func(childComplexity int) int
		Transactions    func(childComplexity int) int
	}

	BlocksResponse struct {
		Blocks func(childComplexity int) int
		Height func(childComplexity int) int
	}

	CA struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
		Storage   func(childComplexity int) int
		Yaml      func(childComplexity int) int
	}

	CAStorage struct {
		Ca func(childComplexity int) int
	}

	ChaincodeApproval struct {
		Approved func(childComplexity int) int
		MspID    func(childComplexity int) int
	}

	Channel struct {
		Application   func(childComplexity int) int
		Chaincodes    func(childComplexity int) int
		ChannelConfig func(childComplexity int) int
		Height        func(childComplexity int) int
		Name          func(childComplexity int) int
		Orderer       func(childComplexity int) int
		Peers         func(childComplexity int) int
		ProtoConfig   func(childComplexity int) int
		RawConfig     func(childComplexity int) int
	}

	ChannelACL struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ChannelAnchorPeer struct {
		Host  func(childComplexity int) int
		MspID func(childComplexity int) int
		Port  func(childComplexity int) int
	}

	ChannelChaincode struct {
		Approvals              func(childComplexity int) int
		ConfigPolicy           func(childComplexity int) int
		EndorsementPlugin      func(childComplexity int) int
		Name                   func(childComplexity int) int
		PrivateDataCollections func(childComplexity int) int
		Sequence               func(childComplexity int) int
		SignaturePolicy        func(childComplexity int) int
		ValidationPlugin       func(childComplexity int) int
		Version                func(childComplexity int) int
	}

	ChannelConfig struct {
		Capabilities func(childComplexity int) int
		Policies     func(childComplexity int) int
	}

	ChannelMSP struct {
		Admins               func(childComplexity int) int
		IntermediateCerts    func(childComplexity int) int
		Name                 func(childComplexity int) int
		RevocationList       func(childComplexity int) int
		RootCerts            func(childComplexity int) int
		TLSIntermediateCerts func(childComplexity int) int
		TLSRootCerts         func(childComplexity int) int
	}

	ChannelOrg struct {
		AnchorPeer       func(childComplexity int) int
		CryptoConfig     func(childComplexity int) int
		ModPolicy        func(childComplexity int) int
		Msp              func(childComplexity int) int
		MspID            func(childComplexity int) int
		NodeOUs          func(childComplexity int) int
		OrdererEndpoints func(childComplexity int) int
		Ous              func(childComplexity int) int
		Policies         func(childComplexity int) int
	}

	ChannelPeer struct {
		Height func(childComplexity int) int
		MspID  func(childComplexity int) int
		URL    func(childComplexity int) int
	}

	ChannelPolicy struct {
		Key       func(childComplexity int) int
		ModPolicy func(childComplexity int) int
		Rule      func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	CryptoConfig struct {
		IdentityIdentifierHashFunction func(childComplexity int) int
		SignatureHashFamily            func(childComplexity int) int
	}

	Error struct {
		Message func(childComplexity int) int
	}

	GetUpdateChannelBlockResponse struct {
		Block        func(childComplexity int) int
		ConfigUpdate func(childComplexity int) int
		Errors       func(childComplexity int) int
	}

	LightChannel struct {
		Name func(childComplexity int) int
	}

	MSPPrincipal struct {
		Combined func(childComplexity int) int
		Role     func(childComplexity int) int
	}

	MSPPrincipalCombined struct {
		Classification func(childComplexity int) int
		MspPrincipals  func(childComplexity int) int
	}

	MSPPrincipalRole struct {
		MspID func(childComplexity int) int
		Role  func(childComplexity int) int
	}

	Mutation struct {
		CreateCa                 func(childComplexity int, input models.CreateCAInput) int
		CreateOrderer            func(childComplexity int, input models.CreateOrdererInput) int
		CreatePeer               func(childComplexity int, input models.CreatePeerInput) int
		GetUpdateChannelBlock    func(childComplexity int, input models.GetUpdateChannelBlockInput) int
		RenewOrdererCertificates func(childComplexity int, input models.RenewOrdererCertificatesInput) int
		RenewPeerCertificates    func(childComplexity int, input models.RenewPeerCertificatesInput) int
		UpdateCa                 func(childComplexity int, filter models.NameAndNamespace, input models.UpdateCAInput) int
		UpdateChannel            func(childComplexity int, input models.UpdateChannelInput) int
		UpdateOrderer            func(childComplexity int, filter models.NameAndNamespace, input models.UpdateeOrdererInput) int
		UpdatePeer               func(childComplexity int, filter models.NameAndNamespace, input models.UpdateePeerInput) int
	}

	Namespace struct {
		Name func(childComplexity int) int
	}

	NetworkAddress struct {
		Host func(childComplexity int) int
		Port func(childComplexity int) int
	}

	NodeOUs struct {
		AdminOUIdentifier   func(childComplexity int) int
		ClientOUIdentifier  func(childComplexity int) int
		Enable              func(childComplexity int) int
		OrdererOUIdentifier func(childComplexity int) int
		PeerOUIdentifier    func(childComplexity int) int
	}

	OUIdentifier struct {
		Certificate  func(childComplexity int) int
		OuIdentifier func(childComplexity int) int
	}

	Orderer struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
		Storage   func(childComplexity int) int
		Yaml      func(childComplexity int) int
	}

	OrdererConfig struct {
		BatchSize     func(childComplexity int) int
		BatchTimeout  func(childComplexity int) int
		Capabilities  func(childComplexity int) int
		EtcdDraft     func(childComplexity int) int
		MaxChannels   func(childComplexity int) int
		Organizations func(childComplexity int) int
		Policies      func(childComplexity int) int
		State         func(childComplexity int) int
		Type          func(childComplexity int) int
	}

	OrdererConfigBatchSize struct {
		AbsoluteMaxBytes  func(childComplexity int) int
		MaxMessageCount   func(childComplexity int) int
		PreferredMaxBytes func(childComplexity int) int
	}

	OrdererConfigRaft struct {
		Consenters func(childComplexity int) int
		Options    func(childComplexity int) int
	}

	OrdererConfigRaftConsenter struct {
		Address       func(childComplexity int) int
		ClientTLSCert func(childComplexity int) int
		ServerTLSCert func(childComplexity int) int
	}

	OrdererConfigRaftOptions struct {
		ElectionTick         func(childComplexity int) int
		HeartbeatTick        func(childComplexity int) int
		MaxInflightBlocks    func(childComplexity int) int
		SnapshotIntervalSize func(childComplexity int) int
		TickInterval         func(childComplexity int) int
	}

	OrdererStorage struct {
		Orderer func(childComplexity int) int
	}

	PDCRead struct {
		Block          func(childComplexity int) int
		CollectionName func(childComplexity int) int
		Key            func(childComplexity int) int
		TxNum          func(childComplexity int) int
	}

	PDCReadHash struct {
		KeyHash   func(childComplexity int) int
		PdcName   func(childComplexity int) int
		RwSetHash func(childComplexity int) int
		Version   func(childComplexity int) int
	}

	PDCReadVersion struct {
		BlockNum func(childComplexity int) int
		TxNum    func(childComplexity int) int
	}

	PDCWrite struct {
		CollectionName func(childComplexity int) int
		Deleted        func(childComplexity int) int
		Key            func(childComplexity int) int
		Value          func(childComplexity int) int
	}

	PDCWriteHash struct {
		IsDelete  func(childComplexity int) int
		IsPurge   func(childComplexity int) int
		KeyHash   func(childComplexity int) int
		PdcName   func(childComplexity int) int
		RwSetHash func(childComplexity int) int
		ValueHash func(childComplexity int) int
	}

	Peer struct {
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
		Storage   func(childComplexity int) int
		Yaml      func(childComplexity int) int
	}

	PeerStorage struct {
		Chaincode func(childComplexity int) int
		CouchDb   func(childComplexity int) int
		Peer      func(childComplexity int) int
	}

	PrivateDataCollection struct {
		BlockToLive       func(childComplexity int) int
		EndorsementPolicy func(childComplexity int) int
		MaxPeerCount      func(childComplexity int) int
		MemberOnlyRead    func(childComplexity int) int
		MemberOnlyWrite   func(childComplexity int) int
		MemberOrgsPolicy  func(childComplexity int) int
		Name              func(childComplexity int) int
		RequiredPeerCount func(childComplexity int) int
	}

	Query struct {
		Block                func(childComplexity int, channelID string, blockNumber int) int
		BlockByTxid          func(childComplexity int, channelID string, transactionID string) int
		BlockWithPrivateData func(childComplexity int, channelID string, blockNumber int) int
		Blocks               func(childComplexity int, channelID string, from int, to int, reverse bool) int
		Ca                   func(childComplexity int, input models.NameAndNamespace) int
		Cas                  func(childComplexity int) int
		Channel              func(childComplexity int, channelID string) int
		Channels             func(childComplexity int) int
		Namespaces           func(childComplexity int) int
		NetworkConfigEnabled func(childComplexity int) int
		Orderer              func(childComplexity int, input models.NameAndNamespace) int
		Orderers             func(childComplexity int) int
		Peer                 func(childComplexity int, input models.NameAndNamespace) int
		Peers                func(childComplexity int) int
		StorageClasses       func(childComplexity int) int
	}

	RenewOrdererCertificatesResponse struct {
		Errors  func(childComplexity int) int
		Orderer func(childComplexity int) int
	}

	RenewPeerCertificatesResponse struct {
		Errors func(childComplexity int) int
		Peer   func(childComplexity int) int
	}

	SignaturePolicy struct {
		Principals func(childComplexity int) int
		Rule       func(childComplexity int) int
		Version    func(childComplexity int) int
	}

	SignaturePolicyNOutOf struct {
		N     func(childComplexity int) int
		Rules func(childComplexity int) int
	}

	SignaturePolicyRule struct {
		NoutOf   func(childComplexity int) int
		SignedBy func(childComplexity int) int
		Type     func(childComplexity int) int
	}

	SignaturePolicySignedBy struct {
		SignedBy func(childComplexity int) int
	}

	StorageClass struct {
		Name func(childComplexity int) int
	}

	StorageUsage struct {
		Free           func(childComplexity int) int
		FreeGb         func(childComplexity int) int
		PercentageUsed func(childComplexity int) int
		Size           func(childComplexity int) int
		SizeGb         func(childComplexity int) int
		Used           func(childComplexity int) int
		UsedGb         func(childComplexity int) int
	}

	Transaction struct {
		Chaincode func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		Path      func(childComplexity int) int
		Reads     func(childComplexity int) int
		Request   func(childComplexity int) int
		Response  func(childComplexity int) int
		TxID      func(childComplexity int) int
		Type      func(childComplexity int) int
		Version   func(childComplexity int) int
		Writes    func(childComplexity int) int
	}

	TransactionRead struct {
		BlockNumVersion func(childComplexity int) int
		ChaincodeID     func(childComplexity int) int
		Key             func(childComplexity int) int
		TxNumVersion    func(childComplexity int) int
	}

	TransactionWithPrivateData struct {
		Chaincode      func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Path           func(childComplexity int) int
		PdcReadHashes  func(childComplexity int) int
		PdcReads       func(childComplexity int) int
		PdcWriteHashes func(childComplexity int) int
		PdcWrites      func(childComplexity int) int
		Reads          func(childComplexity int) int
		Request        func(childComplexity int) int
		Response       func(childComplexity int) int
		TxID           func(childComplexity int) int
		Type           func(childComplexity int) int
		Version        func(childComplexity int) int
		Writes         func(childComplexity int) int
	}

	TransactionWrite struct {
		ChaincodeID func(childComplexity int) int
		Deleted     func(childComplexity int) int
		Key         func(childComplexity int) int
		Value       func(childComplexity int) int
	}

	UpdateChannelResponse struct {
		Errors        func(childComplexity int) int
		TransactionID func(childComplexity int) int
	}
}

type CAResolver interface {
	Storage(ctx context.Context, obj *models.Ca) (*models.CAStorage, error)
}
type ChannelResolver interface {
	Chaincodes(ctx context.Context, obj *models.Channel) ([]*models.ChannelChaincode, error)
	Peers(ctx context.Context, obj *models.Channel) ([]*models.ChannelPeer, error)
}
type MutationResolver interface {
	CreatePeer(ctx context.Context, input models.CreatePeerInput) (*models.Peer, error)
	UpdatePeer(ctx context.Context, filter models.NameAndNamespace, input models.UpdateePeerInput) (*models.Peer, error)
	CreateOrderer(ctx context.Context, input models.CreateOrdererInput) (*models.Orderer, error)
	UpdateOrderer(ctx context.Context, filter models.NameAndNamespace, input models.UpdateeOrdererInput) (*models.Orderer, error)
	CreateCa(ctx context.Context, input models.CreateCAInput) (*models.Ca, error)
	UpdateCa(ctx context.Context, filter models.NameAndNamespace, input models.UpdateCAInput) (*models.Ca, error)
	RenewPeerCertificates(ctx context.Context, input models.RenewPeerCertificatesInput) (*models.RenewPeerCertificatesResponse, error)
	RenewOrdererCertificates(ctx context.Context, input models.RenewOrdererCertificatesInput) (*models.RenewOrdererCertificatesResponse, error)
	UpdateChannel(ctx context.Context, input models.UpdateChannelInput) (*models.UpdateChannelResponse, error)
	GetUpdateChannelBlock(ctx context.Context, input models.GetUpdateChannelBlockInput) (*models.GetUpdateChannelBlockResponse, error)
}
type OrdererResolver interface {
	Storage(ctx context.Context, obj *models.Orderer) (*models.OrdererStorage, error)
}
type PeerResolver interface {
	Storage(ctx context.Context, obj *models.Peer) (*models.PeerStorage, error)
}
type QueryResolver interface {
	Peers(ctx context.Context) ([]*models.Peer, error)
	Peer(ctx context.Context, input models.NameAndNamespace) (*models.Peer, error)
	Orderers(ctx context.Context) ([]*models.Orderer, error)
	Orderer(ctx context.Context, input models.NameAndNamespace) (*models.Orderer, error)
	NetworkConfigEnabled(ctx context.Context) (bool, error)
	Cas(ctx context.Context) ([]*models.Ca, error)
	Ca(ctx context.Context, input models.NameAndNamespace) (*models.Ca, error)
	Namespaces(ctx context.Context) ([]*models.Namespace, error)
	StorageClasses(ctx context.Context) ([]*models.StorageClass, error)
	Channels(ctx context.Context) ([]*models.LightChannel, error)
	Channel(ctx context.Context, channelID string) (*models.Channel, error)
	Blocks(ctx context.Context, channelID string, from int, to int, reverse bool) (*models.BlocksResponse, error)
	Block(ctx context.Context, channelID string, blockNumber int) (*models.Block, error)
	BlockWithPrivateData(ctx context.Context, channelID string, blockNumber int) (*models.BlockWithPrivateData, error)
	BlockByTxid(ctx context.Context, channelID string, transactionID string) (*models.Block, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "ApplicationConfig.acls":
		if e.complexity.ApplicationConfig.Acls == nil {
			break
		}

		return e.complexity.ApplicationConfig.Acls(childComplexity), true

	case "ApplicationConfig.capabilities":
		if e.complexity.ApplicationConfig.Capabilities == nil {
			break
		}

		return e.complexity.ApplicationConfig.Capabilities(childComplexity), true

	case "ApplicationConfig.organizations":
		if e.complexity.ApplicationConfig.Organizations == nil {
			break
		}

		return e.complexity.ApplicationConfig.Organizations(childComplexity), true

	case "ApplicationConfig.policies":
		if e.complexity.ApplicationConfig.Policies == nil {
			break
		}

		return e.complexity.ApplicationConfig.Policies(childComplexity), true

	case "ApplicationPolicy.channelConfigPolicy":
		if e.complexity.ApplicationPolicy.ChannelConfigPolicy == nil {
			break
		}

		return e.complexity.ApplicationPolicy.ChannelConfigPolicy(childComplexity), true

	case "ApplicationPolicy.signaturePolicy":
		if e.complexity.ApplicationPolicy.SignaturePolicy == nil {
			break
		}

		return e.complexity.ApplicationPolicy.SignaturePolicy(childComplexity), true

	case "Block.blockNumber":
		if e.complexity.Block.BlockNumber == nil {
			break
		}

		return e.complexity.Block.BlockNumber(childComplexity), true

	case "Block.createdAt":
		if e.complexity.Block.CreatedAt == nil {
			break
		}

		return e.complexity.Block.CreatedAt(childComplexity), true

	case "Block.dataHash":
		if e.complexity.Block.DataHash == nil {
			break
		}

		return e.complexity.Block.DataHash(childComplexity), true

	case "Block.numTransactions":
		if e.complexity.Block.NumTransactions == nil {
			break
		}

		return e.complexity.Block.NumTransactions(childComplexity), true

	case "Block.transactions":
		if e.complexity.Block.Transactions == nil {
			break
		}

		return e.complexity.Block.Transactions(childComplexity), true

	case "BlockWithPrivateData.blockNumber":
		if e.complexity.BlockWithPrivateData.BlockNumber == nil {
			break
		}

		return e.complexity.BlockWithPrivateData.BlockNumber(childComplexity), true

	case "BlockWithPrivateData.createdAt":
		if e.complexity.BlockWithPrivateData.CreatedAt == nil {
			break
		}

		return e.complexity.BlockWithPrivateData.CreatedAt(childComplexity), true

	case "BlockWithPrivateData.dataHash":
		if e.complexity.BlockWithPrivateData.DataHash == nil {
			break
		}

		return e.complexity.BlockWithPrivateData.DataHash(childComplexity), true

	case "BlockWithPrivateData.numTransactions":
		if e.complexity.BlockWithPrivateData.NumTransactions == nil {
			break
		}

		return e.complexity.BlockWithPrivateData.NumTransactions(childComplexity), true

	case "BlockWithPrivateData.transactions":
		if e.complexity.BlockWithPrivateData.Transactions == nil {
			break
		}

		return e.complexity.BlockWithPrivateData.Transactions(childComplexity), true

	case "BlocksResponse.blocks":
		if e.complexity.BlocksResponse.Blocks == nil {
			break
		}

		return e.complexity.BlocksResponse.Blocks(childComplexity), true

	case "BlocksResponse.height":
		if e.complexity.BlocksResponse.Height == nil {
			break
		}

		return e.complexity.BlocksResponse.Height(childComplexity), true

	case "CA.name":
		if e.complexity.CA.Name == nil {
			break
		}

		return e.complexity.CA.Name(childComplexity), true

	case "CA.namespace":
		if e.complexity.CA.Namespace == nil {
			break
		}

		return e.complexity.CA.Namespace(childComplexity), true

	case "CA.storage":
		if e.complexity.CA.Storage == nil {
			break
		}

		return e.complexity.CA.Storage(childComplexity), true

	case "CA.yaml":
		if e.complexity.CA.Yaml == nil {
			break
		}

		return e.complexity.CA.Yaml(childComplexity), true

	case "CAStorage.ca":
		if e.complexity.CAStorage.Ca == nil {
			break
		}

		return e.complexity.CAStorage.Ca(childComplexity), true

	case "ChaincodeApproval.approved":
		if e.complexity.ChaincodeApproval.Approved == nil {
			break
		}

		return e.complexity.ChaincodeApproval.Approved(childComplexity), true

	case "ChaincodeApproval.mspID":
		if e.complexity.ChaincodeApproval.MspID == nil {
			break
		}

		return e.complexity.ChaincodeApproval.MspID(childComplexity), true

	case "Channel.application":
		if e.complexity.Channel.Application == nil {
			break
		}

		return e.complexity.Channel.Application(childComplexity), true

	case "Channel.chaincodes":
		if e.complexity.Channel.Chaincodes == nil {
			break
		}

		return e.complexity.Channel.Chaincodes(childComplexity), true

	case "Channel.channelConfig":
		if e.complexity.Channel.ChannelConfig == nil {
			break
		}

		return e.complexity.Channel.ChannelConfig(childComplexity), true

	case "Channel.height":
		if e.complexity.Channel.Height == nil {
			break
		}

		return e.complexity.Channel.Height(childComplexity), true

	case "Channel.name":
		if e.complexity.Channel.Name == nil {
			break
		}

		return e.complexity.Channel.Name(childComplexity), true

	case "Channel.orderer":
		if e.complexity.Channel.Orderer == nil {
			break
		}

		return e.complexity.Channel.Orderer(childComplexity), true

	case "Channel.peers":
		if e.complexity.Channel.Peers == nil {
			break
		}

		return e.complexity.Channel.Peers(childComplexity), true

	case "Channel.protoConfig":
		if e.complexity.Channel.ProtoConfig == nil {
			break
		}

		return e.complexity.Channel.ProtoConfig(childComplexity), true

	case "Channel.rawConfig":
		if e.complexity.Channel.RawConfig == nil {
			break
		}

		return e.complexity.Channel.RawConfig(childComplexity), true

	case "ChannelACL.key":
		if e.complexity.ChannelACL.Key == nil {
			break
		}

		return e.complexity.ChannelACL.Key(childComplexity), true

	case "ChannelACL.value":
		if e.complexity.ChannelACL.Value == nil {
			break
		}

		return e.complexity.ChannelACL.Value(childComplexity), true

	case "ChannelAnchorPeer.host":
		if e.complexity.ChannelAnchorPeer.Host == nil {
			break
		}

		return e.complexity.ChannelAnchorPeer.Host(childComplexity), true

	case "ChannelAnchorPeer.mspID":
		if e.complexity.ChannelAnchorPeer.MspID == nil {
			break
		}

		return e.complexity.ChannelAnchorPeer.MspID(childComplexity), true

	case "ChannelAnchorPeer.port":
		if e.complexity.ChannelAnchorPeer.Port == nil {
			break
		}

		return e.complexity.ChannelAnchorPeer.Port(childComplexity), true

	case "ChannelChaincode.approvals":
		if e.complexity.ChannelChaincode.Approvals == nil {
			break
		}

		return e.complexity.ChannelChaincode.Approvals(childComplexity), true

	case "ChannelChaincode.configPolicy":
		if e.complexity.ChannelChaincode.ConfigPolicy == nil {
			break
		}

		return e.complexity.ChannelChaincode.ConfigPolicy(childComplexity), true

	case "ChannelChaincode.endorsementPlugin":
		if e.complexity.ChannelChaincode.EndorsementPlugin == nil {
			break
		}

		return e.complexity.ChannelChaincode.EndorsementPlugin(childComplexity), true

	case "ChannelChaincode.name":
		if e.complexity.ChannelChaincode.Name == nil {
			break
		}

		return e.complexity.ChannelChaincode.Name(childComplexity), true

	case "ChannelChaincode.privateDataCollections":
		if e.complexity.ChannelChaincode.PrivateDataCollections == nil {
			break
		}

		return e.complexity.ChannelChaincode.PrivateDataCollections(childComplexity), true

	case "ChannelChaincode.sequence":
		if e.complexity.ChannelChaincode.Sequence == nil {
			break
		}

		return e.complexity.ChannelChaincode.Sequence(childComplexity), true

	case "ChannelChaincode.signaturePolicy":
		if e.complexity.ChannelChaincode.SignaturePolicy == nil {
			break
		}

		return e.complexity.ChannelChaincode.SignaturePolicy(childComplexity), true

	case "ChannelChaincode.validationPlugin":
		if e.complexity.ChannelChaincode.ValidationPlugin == nil {
			break
		}

		return e.complexity.ChannelChaincode.ValidationPlugin(childComplexity), true

	case "ChannelChaincode.version":
		if e.complexity.ChannelChaincode.Version == nil {
			break
		}

		return e.complexity.ChannelChaincode.Version(childComplexity), true

	case "ChannelConfig.capabilities":
		if e.complexity.ChannelConfig.Capabilities == nil {
			break
		}

		return e.complexity.ChannelConfig.Capabilities(childComplexity), true

	case "ChannelConfig.policies":
		if e.complexity.ChannelConfig.Policies == nil {
			break
		}

		return e.complexity.ChannelConfig.Policies(childComplexity), true

	case "ChannelMSP.admins":
		if e.complexity.ChannelMSP.Admins == nil {
			break
		}

		return e.complexity.ChannelMSP.Admins(childComplexity), true

	case "ChannelMSP.intermediateCerts":
		if e.complexity.ChannelMSP.IntermediateCerts == nil {
			break
		}

		return e.complexity.ChannelMSP.IntermediateCerts(childComplexity), true

	case "ChannelMSP.name":
		if e.complexity.ChannelMSP.Name == nil {
			break
		}

		return e.complexity.ChannelMSP.Name(childComplexity), true

	case "ChannelMSP.revocationList":
		if e.complexity.ChannelMSP.RevocationList == nil {
			break
		}

		return e.complexity.ChannelMSP.RevocationList(childComplexity), true

	case "ChannelMSP.rootCerts":
		if e.complexity.ChannelMSP.RootCerts == nil {
			break
		}

		return e.complexity.ChannelMSP.RootCerts(childComplexity), true

	case "ChannelMSP.tlsIntermediateCerts":
		if e.complexity.ChannelMSP.TLSIntermediateCerts == nil {
			break
		}

		return e.complexity.ChannelMSP.TLSIntermediateCerts(childComplexity), true

	case "ChannelMSP.tlsRootCerts":
		if e.complexity.ChannelMSP.TLSRootCerts == nil {
			break
		}

		return e.complexity.ChannelMSP.TLSRootCerts(childComplexity), true

	case "ChannelOrg.anchorPeer":
		if e.complexity.ChannelOrg.AnchorPeer == nil {
			break
		}

		return e.complexity.ChannelOrg.AnchorPeer(childComplexity), true

	case "ChannelOrg.cryptoConfig":
		if e.complexity.ChannelOrg.CryptoConfig == nil {
			break
		}

		return e.complexity.ChannelOrg.CryptoConfig(childComplexity), true

	case "ChannelOrg.modPolicy":
		if e.complexity.ChannelOrg.ModPolicy == nil {
			break
		}

		return e.complexity.ChannelOrg.ModPolicy(childComplexity), true

	case "ChannelOrg.msp":
		if e.complexity.ChannelOrg.Msp == nil {
			break
		}

		return e.complexity.ChannelOrg.Msp(childComplexity), true

	case "ChannelOrg.mspID":
		if e.complexity.ChannelOrg.MspID == nil {
			break
		}

		return e.complexity.ChannelOrg.MspID(childComplexity), true

	case "ChannelOrg.nodeOUs":
		if e.complexity.ChannelOrg.NodeOUs == nil {
			break
		}

		return e.complexity.ChannelOrg.NodeOUs(childComplexity), true

	case "ChannelOrg.ordererEndpoints":
		if e.complexity.ChannelOrg.OrdererEndpoints == nil {
			break
		}

		return e.complexity.ChannelOrg.OrdererEndpoints(childComplexity), true

	case "ChannelOrg.ous":
		if e.complexity.ChannelOrg.Ous == nil {
			break
		}

		return e.complexity.ChannelOrg.Ous(childComplexity), true

	case "ChannelOrg.policies":
		if e.complexity.ChannelOrg.Policies == nil {
			break
		}

		return e.complexity.ChannelOrg.Policies(childComplexity), true

	case "ChannelPeer.height":
		if e.complexity.ChannelPeer.Height == nil {
			break
		}

		return e.complexity.ChannelPeer.Height(childComplexity), true

	case "ChannelPeer.mspID":
		if e.complexity.ChannelPeer.MspID == nil {
			break
		}

		return e.complexity.ChannelPeer.MspID(childComplexity), true

	case "ChannelPeer.url":
		if e.complexity.ChannelPeer.URL == nil {
			break
		}

		return e.complexity.ChannelPeer.URL(childComplexity), true

	case "ChannelPolicy.key":
		if e.complexity.ChannelPolicy.Key == nil {
			break
		}

		return e.complexity.ChannelPolicy.Key(childComplexity), true

	case "ChannelPolicy.modPolicy":
		if e.complexity.ChannelPolicy.ModPolicy == nil {
			break
		}

		return e.complexity.ChannelPolicy.ModPolicy(childComplexity), true

	case "ChannelPolicy.rule":
		if e.complexity.ChannelPolicy.Rule == nil {
			break
		}

		return e.complexity.ChannelPolicy.Rule(childComplexity), true

	case "ChannelPolicy.type":
		if e.complexity.ChannelPolicy.Type == nil {
			break
		}

		return e.complexity.ChannelPolicy.Type(childComplexity), true

	case "CryptoConfig.identityIdentifierHashFunction":
		if e.complexity.CryptoConfig.IdentityIdentifierHashFunction == nil {
			break
		}

		return e.complexity.CryptoConfig.IdentityIdentifierHashFunction(childComplexity), true

	case "CryptoConfig.signatureHashFamily":
		if e.complexity.CryptoConfig.SignatureHashFamily == nil {
			break
		}

		return e.complexity.CryptoConfig.SignatureHashFamily(childComplexity), true

	case "Error.message":
		if e.complexity.Error.Message == nil {
			break
		}

		return e.complexity.Error.Message(childComplexity), true

	case "GetUpdateChannelBlockResponse.block":
		if e.complexity.GetUpdateChannelBlockResponse.Block == nil {
			break
		}

		return e.complexity.GetUpdateChannelBlockResponse.Block(childComplexity), true

	case "GetUpdateChannelBlockResponse.configUpdate":
		if e.complexity.GetUpdateChannelBlockResponse.ConfigUpdate == nil {
			break
		}

		return e.complexity.GetUpdateChannelBlockResponse.ConfigUpdate(childComplexity), true

	case "GetUpdateChannelBlockResponse.errors":
		if e.complexity.GetUpdateChannelBlockResponse.Errors == nil {
			break
		}

		return e.complexity.GetUpdateChannelBlockResponse.Errors(childComplexity), true

	case "LightChannel.name":
		if e.complexity.LightChannel.Name == nil {
			break
		}

		return e.complexity.LightChannel.Name(childComplexity), true

	case "MSPPrincipal.combined":
		if e.complexity.MSPPrincipal.Combined == nil {
			break
		}

		return e.complexity.MSPPrincipal.Combined(childComplexity), true

	case "MSPPrincipal.role":
		if e.complexity.MSPPrincipal.Role == nil {
			break
		}

		return e.complexity.MSPPrincipal.Role(childComplexity), true

	case "MSPPrincipalCombined.classification":
		if e.complexity.MSPPrincipalCombined.Classification == nil {
			break
		}

		return e.complexity.MSPPrincipalCombined.Classification(childComplexity), true

	case "MSPPrincipalCombined.mspPrincipals":
		if e.complexity.MSPPrincipalCombined.MspPrincipals == nil {
			break
		}

		return e.complexity.MSPPrincipalCombined.MspPrincipals(childComplexity), true

	case "MSPPrincipalRole.mspID":
		if e.complexity.MSPPrincipalRole.MspID == nil {
			break
		}

		return e.complexity.MSPPrincipalRole.MspID(childComplexity), true

	case "MSPPrincipalRole.role":
		if e.complexity.MSPPrincipalRole.Role == nil {
			break
		}

		return e.complexity.MSPPrincipalRole.Role(childComplexity), true

	case "Mutation.createCA":
		if e.complexity.Mutation.CreateCa == nil {
			break
		}

		args, err := ec.field_Mutation_createCA_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCa(childComplexity, args["input"].(models.CreateCAInput)), true

	case "Mutation.createOrderer":
		if e.complexity.Mutation.CreateOrderer == nil {
			break
		}

		args, err := ec.field_Mutation_createOrderer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateOrderer(childComplexity, args["input"].(models.CreateOrdererInput)), true

	case "Mutation.createPeer":
		if e.complexity.Mutation.CreatePeer == nil {
			break
		}

		args, err := ec.field_Mutation_createPeer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePeer(childComplexity, args["input"].(models.CreatePeerInput)), true

	case "Mutation.getUpdateChannelBlock":
		if e.complexity.Mutation.GetUpdateChannelBlock == nil {
			break
		}

		args, err := ec.field_Mutation_getUpdateChannelBlock_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GetUpdateChannelBlock(childComplexity, args["input"].(models.GetUpdateChannelBlockInput)), true

	case "Mutation.renewOrdererCertificates":
		if e.complexity.Mutation.RenewOrdererCertificates == nil {
			break
		}

		args, err := ec.field_Mutation_renewOrdererCertificates_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RenewOrdererCertificates(childComplexity, args["input"].(models.RenewOrdererCertificatesInput)), true

	case "Mutation.renewPeerCertificates":
		if e.complexity.Mutation.RenewPeerCertificates == nil {
			break
		}

		args, err := ec.field_Mutation_renewPeerCertificates_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RenewPeerCertificates(childComplexity, args["input"].(models.RenewPeerCertificatesInput)), true

	case "Mutation.updateCA":
		if e.complexity.Mutation.UpdateCa == nil {
			break
		}

		args, err := ec.field_Mutation_updateCA_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCa(childComplexity, args["filter"].(models.NameAndNamespace), args["input"].(models.UpdateCAInput)), true

	case "Mutation.updateChannel":
		if e.complexity.Mutation.UpdateChannel == nil {
			break
		}

		args, err := ec.field_Mutation_updateChannel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateChannel(childComplexity, args["input"].(models.UpdateChannelInput)), true

	case "Mutation.updateOrderer":
		if e.complexity.Mutation.UpdateOrderer == nil {
			break
		}

		args, err := ec.field_Mutation_updateOrderer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateOrderer(childComplexity, args["filter"].(models.NameAndNamespace), args["input"].(models.UpdateeOrdererInput)), true

	case "Mutation.updatePeer":
		if e.complexity.Mutation.UpdatePeer == nil {
			break
		}

		args, err := ec.field_Mutation_updatePeer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePeer(childComplexity, args["filter"].(models.NameAndNamespace), args["input"].(models.UpdateePeerInput)), true

	case "Namespace.name":
		if e.complexity.Namespace.Name == nil {
			break
		}

		return e.complexity.Namespace.Name(childComplexity), true

	case "NetworkAddress.host":
		if e.complexity.NetworkAddress.Host == nil {
			break
		}

		return e.complexity.NetworkAddress.Host(childComplexity), true

	case "NetworkAddress.port":
		if e.complexity.NetworkAddress.Port == nil {
			break
		}

		return e.complexity.NetworkAddress.Port(childComplexity), true

	case "NodeOUs.adminOUIdentifier":
		if e.complexity.NodeOUs.AdminOUIdentifier == nil {
			break
		}

		return e.complexity.NodeOUs.AdminOUIdentifier(childComplexity), true

	case "NodeOUs.clientOUIdentifier":
		if e.complexity.NodeOUs.ClientOUIdentifier == nil {
			break
		}

		return e.complexity.NodeOUs.ClientOUIdentifier(childComplexity), true

	case "NodeOUs.enable":
		if e.complexity.NodeOUs.Enable == nil {
			break
		}

		return e.complexity.NodeOUs.Enable(childComplexity), true

	case "NodeOUs.ordererOUIdentifier":
		if e.complexity.NodeOUs.OrdererOUIdentifier == nil {
			break
		}

		return e.complexity.NodeOUs.OrdererOUIdentifier(childComplexity), true

	case "NodeOUs.peerOUIdentifier":
		if e.complexity.NodeOUs.PeerOUIdentifier == nil {
			break
		}

		return e.complexity.NodeOUs.PeerOUIdentifier(childComplexity), true

	case "OUIdentifier.certificate":
		if e.complexity.OUIdentifier.Certificate == nil {
			break
		}

		return e.complexity.OUIdentifier.Certificate(childComplexity), true

	case "OUIdentifier.ouIdentifier":
		if e.complexity.OUIdentifier.OuIdentifier == nil {
			break
		}

		return e.complexity.OUIdentifier.OuIdentifier(childComplexity), true

	case "Orderer.name":
		if e.complexity.Orderer.Name == nil {
			break
		}

		return e.complexity.Orderer.Name(childComplexity), true

	case "Orderer.namespace":
		if e.complexity.Orderer.Namespace == nil {
			break
		}

		return e.complexity.Orderer.Namespace(childComplexity), true

	case "Orderer.storage":
		if e.complexity.Orderer.Storage == nil {
			break
		}

		return e.complexity.Orderer.Storage(childComplexity), true

	case "Orderer.yaml":
		if e.complexity.Orderer.Yaml == nil {
			break
		}

		return e.complexity.Orderer.Yaml(childComplexity), true

	case "OrdererConfig.batchSize":
		if e.complexity.OrdererConfig.BatchSize == nil {
			break
		}

		return e.complexity.OrdererConfig.BatchSize(childComplexity), true

	case "OrdererConfig.batchTimeout":
		if e.complexity.OrdererConfig.BatchTimeout == nil {
			break
		}

		return e.complexity.OrdererConfig.BatchTimeout(childComplexity), true

	case "OrdererConfig.capabilities":
		if e.complexity.OrdererConfig.Capabilities == nil {
			break
		}

		return e.complexity.OrdererConfig.Capabilities(childComplexity), true

	case "OrdererConfig.etcdDraft":
		if e.complexity.OrdererConfig.EtcdDraft == nil {
			break
		}

		return e.complexity.OrdererConfig.EtcdDraft(childComplexity), true

	case "OrdererConfig.maxChannels":
		if e.complexity.OrdererConfig.MaxChannels == nil {
			break
		}

		return e.complexity.OrdererConfig.MaxChannels(childComplexity), true

	case "OrdererConfig.organizations":
		if e.complexity.OrdererConfig.Organizations == nil {
			break
		}

		return e.complexity.OrdererConfig.Organizations(childComplexity), true

	case "OrdererConfig.policies":
		if e.complexity.OrdererConfig.Policies == nil {
			break
		}

		return e.complexity.OrdererConfig.Policies(childComplexity), true

	case "OrdererConfig.state":
		if e.complexity.OrdererConfig.State == nil {
			break
		}

		return e.complexity.OrdererConfig.State(childComplexity), true

	case "OrdererConfig.type":
		if e.complexity.OrdererConfig.Type == nil {
			break
		}

		return e.complexity.OrdererConfig.Type(childComplexity), true

	case "OrdererConfigBatchSize.absoluteMaxBytes":
		if e.complexity.OrdererConfigBatchSize.AbsoluteMaxBytes == nil {
			break
		}

		return e.complexity.OrdererConfigBatchSize.AbsoluteMaxBytes(childComplexity), true

	case "OrdererConfigBatchSize.maxMessageCount":
		if e.complexity.OrdererConfigBatchSize.MaxMessageCount == nil {
			break
		}

		return e.complexity.OrdererConfigBatchSize.MaxMessageCount(childComplexity), true

	case "OrdererConfigBatchSize.preferredMaxBytes":
		if e.complexity.OrdererConfigBatchSize.PreferredMaxBytes == nil {
			break
		}

		return e.complexity.OrdererConfigBatchSize.PreferredMaxBytes(childComplexity), true

	case "OrdererConfigRaft.consenters":
		if e.complexity.OrdererConfigRaft.Consenters == nil {
			break
		}

		return e.complexity.OrdererConfigRaft.Consenters(childComplexity), true

	case "OrdererConfigRaft.options":
		if e.complexity.OrdererConfigRaft.Options == nil {
			break
		}

		return e.complexity.OrdererConfigRaft.Options(childComplexity), true

	case "OrdererConfigRaftConsenter.address":
		if e.complexity.OrdererConfigRaftConsenter.Address == nil {
			break
		}

		return e.complexity.OrdererConfigRaftConsenter.Address(childComplexity), true

	case "OrdererConfigRaftConsenter.clientTlsCert":
		if e.complexity.OrdererConfigRaftConsenter.ClientTLSCert == nil {
			break
		}

		return e.complexity.OrdererConfigRaftConsenter.ClientTLSCert(childComplexity), true

	case "OrdererConfigRaftConsenter.serverTlsCert":
		if e.complexity.OrdererConfigRaftConsenter.ServerTLSCert == nil {
			break
		}

		return e.complexity.OrdererConfigRaftConsenter.ServerTLSCert(childComplexity), true

	case "OrdererConfigRaftOptions.electionTick":
		if e.complexity.OrdererConfigRaftOptions.ElectionTick == nil {
			break
		}

		return e.complexity.OrdererConfigRaftOptions.ElectionTick(childComplexity), true

	case "OrdererConfigRaftOptions.heartbeatTick":
		if e.complexity.OrdererConfigRaftOptions.HeartbeatTick == nil {
			break
		}

		return e.complexity.OrdererConfigRaftOptions.HeartbeatTick(childComplexity), true

	case "OrdererConfigRaftOptions.maxInflightBlocks":
		if e.complexity.OrdererConfigRaftOptions.MaxInflightBlocks == nil {
			break
		}

		return e.complexity.OrdererConfigRaftOptions.MaxInflightBlocks(childComplexity), true

	case "OrdererConfigRaftOptions.snapshotIntervalSize":
		if e.complexity.OrdererConfigRaftOptions.SnapshotIntervalSize == nil {
			break
		}

		return e.complexity.OrdererConfigRaftOptions.SnapshotIntervalSize(childComplexity), true

	case "OrdererConfigRaftOptions.tickInterval":
		if e.complexity.OrdererConfigRaftOptions.TickInterval == nil {
			break
		}

		return e.complexity.OrdererConfigRaftOptions.TickInterval(childComplexity), true

	case "OrdererStorage.orderer":
		if e.complexity.OrdererStorage.Orderer == nil {
			break
		}

		return e.complexity.OrdererStorage.Orderer(childComplexity), true

	case "PDCRead.block":
		if e.complexity.PDCRead.Block == nil {
			break
		}

		return e.complexity.PDCRead.Block(childComplexity), true

	case "PDCRead.collectionName":
		if e.complexity.PDCRead.CollectionName == nil {
			break
		}

		return e.complexity.PDCRead.CollectionName(childComplexity), true

	case "PDCRead.key":
		if e.complexity.PDCRead.Key == nil {
			break
		}

		return e.complexity.PDCRead.Key(childComplexity), true

	case "PDCRead.txNum":
		if e.complexity.PDCRead.TxNum == nil {
			break
		}

		return e.complexity.PDCRead.TxNum(childComplexity), true

	case "PDCReadHash.keyHash":
		if e.complexity.PDCReadHash.KeyHash == nil {
			break
		}

		return e.complexity.PDCReadHash.KeyHash(childComplexity), true

	case "PDCReadHash.pdcName":
		if e.complexity.PDCReadHash.PdcName == nil {
			break
		}

		return e.complexity.PDCReadHash.PdcName(childComplexity), true

	case "PDCReadHash.rwSetHash":
		if e.complexity.PDCReadHash.RwSetHash == nil {
			break
		}

		return e.complexity.PDCReadHash.RwSetHash(childComplexity), true

	case "PDCReadHash.version":
		if e.complexity.PDCReadHash.Version == nil {
			break
		}

		return e.complexity.PDCReadHash.Version(childComplexity), true

	case "PDCReadVersion.blockNum":
		if e.complexity.PDCReadVersion.BlockNum == nil {
			break
		}

		return e.complexity.PDCReadVersion.BlockNum(childComplexity), true

	case "PDCReadVersion.txNum":
		if e.complexity.PDCReadVersion.TxNum == nil {
			break
		}

		return e.complexity.PDCReadVersion.TxNum(childComplexity), true

	case "PDCWrite.collectionName":
		if e.complexity.PDCWrite.CollectionName == nil {
			break
		}

		return e.complexity.PDCWrite.CollectionName(childComplexity), true

	case "PDCWrite.deleted":
		if e.complexity.PDCWrite.Deleted == nil {
			break
		}

		return e.complexity.PDCWrite.Deleted(childComplexity), true

	case "PDCWrite.key":
		if e.complexity.PDCWrite.Key == nil {
			break
		}

		return e.complexity.PDCWrite.Key(childComplexity), true

	case "PDCWrite.value":
		if e.complexity.PDCWrite.Value == nil {
			break
		}

		return e.complexity.PDCWrite.Value(childComplexity), true

	case "PDCWriteHash.isDelete":
		if e.complexity.PDCWriteHash.IsDelete == nil {
			break
		}

		return e.complexity.PDCWriteHash.IsDelete(childComplexity), true

	case "PDCWriteHash.isPurge":
		if e.complexity.PDCWriteHash.IsPurge == nil {
			break
		}

		return e.complexity.PDCWriteHash.IsPurge(childComplexity), true

	case "PDCWriteHash.keyHash":
		if e.complexity.PDCWriteHash.KeyHash == nil {
			break
		}

		return e.complexity.PDCWriteHash.KeyHash(childComplexity), true

	case "PDCWriteHash.pdcName":
		if e.complexity.PDCWriteHash.PdcName == nil {
			break
		}

		return e.complexity.PDCWriteHash.PdcName(childComplexity), true

	case "PDCWriteHash.rwSetHash":
		if e.complexity.PDCWriteHash.RwSetHash == nil {
			break
		}

		return e.complexity.PDCWriteHash.RwSetHash(childComplexity), true

	case "PDCWriteHash.valueHash":
		if e.complexity.PDCWriteHash.ValueHash == nil {
			break
		}

		return e.complexity.PDCWriteHash.ValueHash(childComplexity), true

	case "Peer.name":
		if e.complexity.Peer.Name == nil {
			break
		}

		return e.complexity.Peer.Name(childComplexity), true

	case "Peer.namespace":
		if e.complexity.Peer.Namespace == nil {
			break
		}

		return e.complexity.Peer.Namespace(childComplexity), true

	case "Peer.storage":
		if e.complexity.Peer.Storage == nil {
			break
		}

		return e.complexity.Peer.Storage(childComplexity), true

	case "Peer.yaml":
		if e.complexity.Peer.Yaml == nil {
			break
		}

		return e.complexity.Peer.Yaml(childComplexity), true

	case "PeerStorage.chaincode":
		if e.complexity.PeerStorage.Chaincode == nil {
			break
		}

		return e.complexity.PeerStorage.Chaincode(childComplexity), true

	case "PeerStorage.couchDB":
		if e.complexity.PeerStorage.CouchDb == nil {
			break
		}

		return e.complexity.PeerStorage.CouchDb(childComplexity), true

	case "PeerStorage.peer":
		if e.complexity.PeerStorage.Peer == nil {
			break
		}

		return e.complexity.PeerStorage.Peer(childComplexity), true

	case "PrivateDataCollection.blockToLive":
		if e.complexity.PrivateDataCollection.BlockToLive == nil {
			break
		}

		return e.complexity.PrivateDataCollection.BlockToLive(childComplexity), true

	case "PrivateDataCollection.endorsementPolicy":
		if e.complexity.PrivateDataCollection.EndorsementPolicy == nil {
			break
		}

		return e.complexity.PrivateDataCollection.EndorsementPolicy(childComplexity), true

	case "PrivateDataCollection.maxPeerCount":
		if e.complexity.PrivateDataCollection.MaxPeerCount == nil {
			break
		}

		return e.complexity.PrivateDataCollection.MaxPeerCount(childComplexity), true

	case "PrivateDataCollection.memberOnlyRead":
		if e.complexity.PrivateDataCollection.MemberOnlyRead == nil {
			break
		}

		return e.complexity.PrivateDataCollection.MemberOnlyRead(childComplexity), true

	case "PrivateDataCollection.memberOnlyWrite":
		if e.complexity.PrivateDataCollection.MemberOnlyWrite == nil {
			break
		}

		return e.complexity.PrivateDataCollection.MemberOnlyWrite(childComplexity), true

	case "PrivateDataCollection.memberOrgsPolicy":
		if e.complexity.PrivateDataCollection.MemberOrgsPolicy == nil {
			break
		}

		return e.complexity.PrivateDataCollection.MemberOrgsPolicy(childComplexity), true

	case "PrivateDataCollection.name":
		if e.complexity.PrivateDataCollection.Name == nil {
			break
		}

		return e.complexity.PrivateDataCollection.Name(childComplexity), true

	case "PrivateDataCollection.requiredPeerCount":
		if e.complexity.PrivateDataCollection.RequiredPeerCount == nil {
			break
		}

		return e.complexity.PrivateDataCollection.RequiredPeerCount(childComplexity), true

	case "Query.block":
		if e.complexity.Query.Block == nil {
			break
		}

		args, err := ec.field_Query_block_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Block(childComplexity, args["channelID"].(string), args["blockNumber"].(int)), true

	case "Query.blockByTXID":
		if e.complexity.Query.BlockByTxid == nil {
			break
		}

		args, err := ec.field_Query_blockByTXID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BlockByTxid(childComplexity, args["channelID"].(string), args["transactionID"].(string)), true

	case "Query.blockWithPrivateData":
		if e.complexity.Query.BlockWithPrivateData == nil {
			break
		}

		args, err := ec.field_Query_blockWithPrivateData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BlockWithPrivateData(childComplexity, args["channelID"].(string), args["blockNumber"].(int)), true

	case "Query.blocks":
		if e.complexity.Query.Blocks == nil {
			break
		}

		args, err := ec.field_Query_blocks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Blocks(childComplexity, args["channelID"].(string), args["from"].(int), args["to"].(int), args["reverse"].(bool)), true

	case "Query.ca":
		if e.complexity.Query.Ca == nil {
			break
		}

		args, err := ec.field_Query_ca_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Ca(childComplexity, args["input"].(models.NameAndNamespace)), true

	case "Query.cas":
		if e.complexity.Query.Cas == nil {
			break
		}

		return e.complexity.Query.Cas(childComplexity), true

	case "Query.channel":
		if e.complexity.Query.Channel == nil {
			break
		}

		args, err := ec.field_Query_channel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Channel(childComplexity, args["channelID"].(string)), true

	case "Query.channels":
		if e.complexity.Query.Channels == nil {
			break
		}

		return e.complexity.Query.Channels(childComplexity), true

	case "Query.namespaces":
		if e.complexity.Query.Namespaces == nil {
			break
		}

		return e.complexity.Query.Namespaces(childComplexity), true

	case "Query.networkConfigEnabled":
		if e.complexity.Query.NetworkConfigEnabled == nil {
			break
		}

		return e.complexity.Query.NetworkConfigEnabled(childComplexity), true

	case "Query.orderer":
		if e.complexity.Query.Orderer == nil {
			break
		}

		args, err := ec.field_Query_orderer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Orderer(childComplexity, args["input"].(models.NameAndNamespace)), true

	case "Query.orderers":
		if e.complexity.Query.Orderers == nil {
			break
		}

		return e.complexity.Query.Orderers(childComplexity), true

	case "Query.peer":
		if e.complexity.Query.Peer == nil {
			break
		}

		args, err := ec.field_Query_peer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Peer(childComplexity, args["input"].(models.NameAndNamespace)), true

	case "Query.peers":
		if e.complexity.Query.Peers == nil {
			break
		}

		return e.complexity.Query.Peers(childComplexity), true

	case "Query.storageClasses":
		if e.complexity.Query.StorageClasses == nil {
			break
		}

		return e.complexity.Query.StorageClasses(childComplexity), true

	case "RenewOrdererCertificatesResponse.errors":
		if e.complexity.RenewOrdererCertificatesResponse.Errors == nil {
			break
		}

		return e.complexity.RenewOrdererCertificatesResponse.Errors(childComplexity), true

	case "RenewOrdererCertificatesResponse.orderer":
		if e.complexity.RenewOrdererCertificatesResponse.Orderer == nil {
			break
		}

		return e.complexity.RenewOrdererCertificatesResponse.Orderer(childComplexity), true

	case "RenewPeerCertificatesResponse.errors":
		if e.complexity.RenewPeerCertificatesResponse.Errors == nil {
			break
		}

		return e.complexity.RenewPeerCertificatesResponse.Errors(childComplexity), true

	case "RenewPeerCertificatesResponse.peer":
		if e.complexity.RenewPeerCertificatesResponse.Peer == nil {
			break
		}

		return e.complexity.RenewPeerCertificatesResponse.Peer(childComplexity), true

	case "SignaturePolicy.principals":
		if e.complexity.SignaturePolicy.Principals == nil {
			break
		}

		return e.complexity.SignaturePolicy.Principals(childComplexity), true

	case "SignaturePolicy.rule":
		if e.complexity.SignaturePolicy.Rule == nil {
			break
		}

		return e.complexity.SignaturePolicy.Rule(childComplexity), true

	case "SignaturePolicy.version":
		if e.complexity.SignaturePolicy.Version == nil {
			break
		}

		return e.complexity.SignaturePolicy.Version(childComplexity), true

	case "SignaturePolicyNOutOf.n":
		if e.complexity.SignaturePolicyNOutOf.N == nil {
			break
		}

		return e.complexity.SignaturePolicyNOutOf.N(childComplexity), true

	case "SignaturePolicyNOutOf.rules":
		if e.complexity.SignaturePolicyNOutOf.Rules == nil {
			break
		}

		return e.complexity.SignaturePolicyNOutOf.Rules(childComplexity), true

	case "SignaturePolicyRule.noutOf":
		if e.complexity.SignaturePolicyRule.NoutOf == nil {
			break
		}

		return e.complexity.SignaturePolicyRule.NoutOf(childComplexity), true

	case "SignaturePolicyRule.signedBy":
		if e.complexity.SignaturePolicyRule.SignedBy == nil {
			break
		}

		return e.complexity.SignaturePolicyRule.SignedBy(childComplexity), true

	case "SignaturePolicyRule.type":
		if e.complexity.SignaturePolicyRule.Type == nil {
			break
		}

		return e.complexity.SignaturePolicyRule.Type(childComplexity), true

	case "SignaturePolicySignedBy.signedBy":
		if e.complexity.SignaturePolicySignedBy.SignedBy == nil {
			break
		}

		return e.complexity.SignaturePolicySignedBy.SignedBy(childComplexity), true

	case "StorageClass.name":
		if e.complexity.StorageClass.Name == nil {
			break
		}

		return e.complexity.StorageClass.Name(childComplexity), true

	case "StorageUsage.free":
		if e.complexity.StorageUsage.Free == nil {
			break
		}

		return e.complexity.StorageUsage.Free(childComplexity), true

	case "StorageUsage.freeGB":
		if e.complexity.StorageUsage.FreeGb == nil {
			break
		}

		return e.complexity.StorageUsage.FreeGb(childComplexity), true

	case "StorageUsage.percentageUsed":
		if e.complexity.StorageUsage.PercentageUsed == nil {
			break
		}

		return e.complexity.StorageUsage.PercentageUsed(childComplexity), true

	case "StorageUsage.size":
		if e.complexity.StorageUsage.Size == nil {
			break
		}

		return e.complexity.StorageUsage.Size(childComplexity), true

	case "StorageUsage.sizeGB":
		if e.complexity.StorageUsage.SizeGb == nil {
			break
		}

		return e.complexity.StorageUsage.SizeGb(childComplexity), true

	case "StorageUsage.used":
		if e.complexity.StorageUsage.Used == nil {
			break
		}

		return e.complexity.StorageUsage.Used(childComplexity), true

	case "StorageUsage.usedGB":
		if e.complexity.StorageUsage.UsedGb == nil {
			break
		}

		return e.complexity.StorageUsage.UsedGb(childComplexity), true

	case "Transaction.chaincode":
		if e.complexity.Transaction.Chaincode == nil {
			break
		}

		return e.complexity.Transaction.Chaincode(childComplexity), true

	case "Transaction.createdAt":
		if e.complexity.Transaction.CreatedAt == nil {
			break
		}

		return e.complexity.Transaction.CreatedAt(childComplexity), true

	case "Transaction.path":
		if e.complexity.Transaction.Path == nil {
			break
		}

		return e.complexity.Transaction.Path(childComplexity), true

	case "Transaction.reads":
		if e.complexity.Transaction.Reads == nil {
			break
		}

		return e.complexity.Transaction.Reads(childComplexity), true

	case "Transaction.request":
		if e.complexity.Transaction.Request == nil {
			break
		}

		return e.complexity.Transaction.Request(childComplexity), true

	case "Transaction.response":
		if e.complexity.Transaction.Response == nil {
			break
		}

		return e.complexity.Transaction.Response(childComplexity), true

	case "Transaction.txID":
		if e.complexity.Transaction.TxID == nil {
			break
		}

		return e.complexity.Transaction.TxID(childComplexity), true

	case "Transaction.type":
		if e.complexity.Transaction.Type == nil {
			break
		}

		return e.complexity.Transaction.Type(childComplexity), true

	case "Transaction.version":
		if e.complexity.Transaction.Version == nil {
			break
		}

		return e.complexity.Transaction.Version(childComplexity), true

	case "Transaction.writes":
		if e.complexity.Transaction.Writes == nil {
			break
		}

		return e.complexity.Transaction.Writes(childComplexity), true

	case "TransactionRead.blockNumVersion":
		if e.complexity.TransactionRead.BlockNumVersion == nil {
			break
		}

		return e.complexity.TransactionRead.BlockNumVersion(childComplexity), true

	case "TransactionRead.chaincodeID":
		if e.complexity.TransactionRead.ChaincodeID == nil {
			break
		}

		return e.complexity.TransactionRead.ChaincodeID(childComplexity), true

	case "TransactionRead.key":
		if e.complexity.TransactionRead.Key == nil {
			break
		}

		return e.complexity.TransactionRead.Key(childComplexity), true

	case "TransactionRead.txNumVersion":
		if e.complexity.TransactionRead.TxNumVersion == nil {
			break
		}

		return e.complexity.TransactionRead.TxNumVersion(childComplexity), true

	case "TransactionWithPrivateData.chaincode":
		if e.complexity.TransactionWithPrivateData.Chaincode == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.Chaincode(childComplexity), true

	case "TransactionWithPrivateData.createdAt":
		if e.complexity.TransactionWithPrivateData.CreatedAt == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.CreatedAt(childComplexity), true

	case "TransactionWithPrivateData.path":
		if e.complexity.TransactionWithPrivateData.Path == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.Path(childComplexity), true

	case "TransactionWithPrivateData.pdcReadHashes":
		if e.complexity.TransactionWithPrivateData.PdcReadHashes == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.PdcReadHashes(childComplexity), true

	case "TransactionWithPrivateData.pdcReads":
		if e.complexity.TransactionWithPrivateData.PdcReads == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.PdcReads(childComplexity), true

	case "TransactionWithPrivateData.pdcWriteHashes":
		if e.complexity.TransactionWithPrivateData.PdcWriteHashes == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.PdcWriteHashes(childComplexity), true

	case "TransactionWithPrivateData.pdcWrites":
		if e.complexity.TransactionWithPrivateData.PdcWrites == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.PdcWrites(childComplexity), true

	case "TransactionWithPrivateData.reads":
		if e.complexity.TransactionWithPrivateData.Reads == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.Reads(childComplexity), true

	case "TransactionWithPrivateData.request":
		if e.complexity.TransactionWithPrivateData.Request == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.Request(childComplexity), true

	case "TransactionWithPrivateData.response":
		if e.complexity.TransactionWithPrivateData.Response == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.Response(childComplexity), true

	case "TransactionWithPrivateData.txID":
		if e.complexity.TransactionWithPrivateData.TxID == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.TxID(childComplexity), true

	case "TransactionWithPrivateData.type":
		if e.complexity.TransactionWithPrivateData.Type == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.Type(childComplexity), true

	case "TransactionWithPrivateData.version":
		if e.complexity.TransactionWithPrivateData.Version == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.Version(childComplexity), true

	case "TransactionWithPrivateData.writes":
		if e.complexity.TransactionWithPrivateData.Writes == nil {
			break
		}

		return e.complexity.TransactionWithPrivateData.Writes(childComplexity), true

	case "TransactionWrite.chaincodeID":
		if e.complexity.TransactionWrite.ChaincodeID == nil {
			break
		}

		return e.complexity.TransactionWrite.ChaincodeID(childComplexity), true

	case "TransactionWrite.deleted":
		if e.complexity.TransactionWrite.Deleted == nil {
			break
		}

		return e.complexity.TransactionWrite.Deleted(childComplexity), true

	case "TransactionWrite.key":
		if e.complexity.TransactionWrite.Key == nil {
			break
		}

		return e.complexity.TransactionWrite.Key(childComplexity), true

	case "TransactionWrite.value":
		if e.complexity.TransactionWrite.Value == nil {
			break
		}

		return e.complexity.TransactionWrite.Value(childComplexity), true

	case "UpdateChannelResponse.errors":
		if e.complexity.UpdateChannelResponse.Errors == nil {
			break
		}

		return e.complexity.UpdateChannelResponse.Errors(childComplexity), true

	case "UpdateChannelResponse.transactionID":
		if e.complexity.UpdateChannelResponse.TransactionID == nil {
			break
		}

		return e.complexity.UpdateChannelResponse.TransactionID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputApplicationConfigInput,
		ec.unmarshalInputChannelACLInput,
		ec.unmarshalInputChannelConfigInput,
		ec.unmarshalInputChannelOrganization,
		ec.unmarshalInputCreateCAInput,
		ec.unmarshalInputCreateOrdererInput,
		ec.unmarshalInputCreatePeerInput,
		ec.unmarshalInputCryptoConfigInput,
		ec.unmarshalInputEtcdRaftInput,
		ec.unmarshalInputGetUpdateChannelBlockInput,
		ec.unmarshalInputMSPInput,
		ec.unmarshalInputMSPSignature,
		ec.unmarshalInputNameAndNamespace,
		ec.unmarshalInputNetworkAddressInput,
		ec.unmarshalInputNodeOUsInput,
		ec.unmarshalInputOUIdentifierInput,
		ec.unmarshalInputOrdererConfigBatchSizeInput,
		ec.unmarshalInputOrdererConfigInput,
		ec.unmarshalInputOrdererConfigRaftConsenterInput,
		ec.unmarshalInputOrdererConfigRaftOptionsInput,
		ec.unmarshalInputPolicyInput,
		ec.unmarshalInputRawSignature,
		ec.unmarshalInputRenewOrdererCertificatesInput,
		ec.unmarshalInputRenewPeerCertificatesInput,
		ec.unmarshalInputUpdateCAInput,
		ec.unmarshalInputUpdateChannelInput,
		ec.unmarshalInputUpdateeOrdererInput,
		ec.unmarshalInputUpdateePeerInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schemas/mutation.graphql", Input: `type Mutation {
    createPeer(input: CreatePeerInput!): Peer
    updatePeer(filter: NameAndNamespace!, input: UpdateePeerInput!): Peer

    createOrderer(input: CreateOrdererInput!): Orderer
    updateOrderer(filter: NameAndNamespace!, input: UpdateeOrdererInput!): Orderer

    createCA(input: CreateCAInput!): CA
    updateCA(filter: NameAndNamespace!, input: UpdateCAInput!): CA

    renewPeerCertificates(input: RenewPeerCertificatesInput!): RenewPeerCertificatesResponse!
    renewOrdererCertificates(input: RenewOrdererCertificatesInput!): RenewOrdererCertificatesResponse!

    updateChannel(input: UpdateChannelInput!): UpdateChannelResponse!
    getUpdateChannelBlock(input: GetUpdateChannelBlockInput!): GetUpdateChannelBlockResponse!
}
type GetUpdateChannelBlockResponse {
    errors: [Error!]
    block: String!
    configUpdate: String!
}

input UpdateChannelInput {
    name: String!
    block: String!
    rawSignatures: [RawSignature!]
    mspSignatures: [MSPSignature!]
}
type UpdateChannelResponse {
    errors: [Error!]
    transactionID: String!
}
input RawSignature {
    raw: String!
}
input MSPSignature {
    mspID: String!
}

input GetUpdateChannelBlockInput {
    channelID: String!
    application: ApplicationConfigInput!
    orderer: OrdererConfigInput
    channel: ChannelConfigInput!
}

input OrdererConfigInput {
    batchTimeout: Int
    state: String
    etcdRaft: EtcdRaftInput
    addPolicies: [PolicyInput!]
    addCapabilities: [String!]
    addOrganizations: [ChannelOrganization]
    delOrganizations: [String!]
    batchSize: OrdererConfigBatchSizeInput
}
input ChannelOrganization {
    mspID: String!
    modPolicy: String!
    policies: [PolicyInput!]
    msp: MSPInput!
    anchorPeers: [NetworkAddressInput!]
    ordererEndpoints: [String!]
}
input OrdererConfigBatchSizeInput {
    maxMessageCount: Int!
    absoluteMaxBytes: Int!
    preferredMaxBytes: Int!
}
input MSPInput {
    name: String!
    rootCerts: [String!]
    intermediateCerts: [String!]
    admins: [String!]
    revocationList: [String!]
    ous: [OUIdentifierInput!]
    tlsRootCerts: [String!]
    tlsIntermediateCerts: [String!]
    nodeOUs: NodeOUsInput!
    cryptoConfig: CryptoConfigInput!
}

input NodeOUsInput {
    enable: Boolean!
    clientOUIdentifier: OUIdentifierInput!
    peerOUIdentifier: OUIdentifierInput!
    adminOUIdentifier: OUIdentifierInput!
    ordererOUIdentifier: OUIdentifierInput!
}
input CryptoConfigInput {
    signatureHashFamily: String! = "SHA2"
    identityIdentifierHashFunction: String! = "SHA256"
}
input OUIdentifierInput {
    certificate: String!
    ouIdentifier: String!
}
input EtcdRaftInput {
    addConsenters: [OrdererConfigRaftConsenterInput!]
    delConsenters: [OrdererConfigRaftConsenterInput!]
    options: OrdererConfigRaftOptionsInput
}
input OrdererConfigRaftOptionsInput {
    tickInterval: String!
    electionTick: Int!
    heartbeatTick: Int!
    maxInflightBlocks: Int!
    snapshotIntervalSize: Int!
}
input NetworkAddressInput {
    host: String!
    port: Int!
}
input OrdererConfigRaftConsenterInput {
    address: NetworkAddressInput!
    clientTlsCert: String!
    serverTlsCert: String!
}
input ApplicationConfigInput {
    policies: [PolicyInput!]
    acls: [ChannelACLInput!]
    capabilities: [String!]
    addOrgs: [ChannelOrganization!]
    delOrgs: [String!]
}

input ChannelACLInput {
    key: String!
    value: String!
}
input ChannelConfigInput {
    policies: [PolicyInput!]
    capabilities: [String!]
}
input PolicyInput {
    key: String!
    type: String!
    rule: String!
    modPolicy: String!
}




input RenewOrdererCertificatesInput {
    namespace: String!
    name: String!
    force: Boolean
}
type RenewOrdererCertificatesResponse {
    orderer: Orderer
    errors: [Error!]
}

input RenewPeerCertificatesInput {
    namespace: String!
    name: String!
}
type RenewPeerCertificatesResponse {
    peer: Peer
    errors: [Error!]
}
type Error {
    message: String!
}


input CreatePeerInput {
    yaml: String!
}

input UpdateePeerInput {
    yaml: String!
}

input CreateOrdererInput {
    yaml: String!
}

input UpdateeOrdererInput {
    yaml: String!
}

input CreateCAInput {
    yaml: String!
}

input UpdateCAInput {
    yaml: String!
}


`, BuiltIn: false},
	{Name: "../schemas/query.graphql", Input: `type Query {
    peers: [Peer!] @requiresAuth
    peer(input: NameAndNamespace!): Peer @requiresAuth

    orderers: [Orderer!] @requiresAuth
    orderer(input: NameAndNamespace!): Orderer @requiresAuth

    networkConfigEnabled: Boolean!

    cas: [CA!] @requiresAuth
    ca(input: NameAndNamespace!): CA @requiresAuth
    namespaces: [Namespace!] @requiresAuth
    storageClasses: [StorageClass!] @requiresAuth
    channels: [LightChannel!] @requiresAuth
    channel(channelID: String!): Channel! @requiresAuth
    blocks(
        channelID: String!
        from: Int!
        to: Int!
        reverse: Boolean!
    ): BlocksResponse! @requiresAuth
    block(channelID: String!, blockNumber: Int!): Block! @requiresAuth
    blockWithPrivateData(channelID: String!, blockNumber: Int!): BlockWithPrivateData! @requiresAuth
    blockByTXID(channelID: String!, transactionID: String!): Block! @requiresAuth
}
type StorageClass {
    name: String!
}
type LightChannel {
    name: String!
}
type BlocksResponse {
    height: Int!
    blocks: [Block!]
}

type Block {
    blockNumber: Int!
    dataHash: String!
    numTransactions: Int!
    createdAt: Time!
    transactions: [Transaction!]
}

type BlockWithPrivateData {
    blockNumber: Int!
    dataHash: String!
    numTransactions: Int!
    createdAt: Time!
    transactions: [TransactionWithPrivateData!]
}

enum TransactionType {
    MESSAGE
    CONFIG
    CONFIG_UPDATE
    ENDORSER_TRANSACTION
    ORDERER_TRANSACTION
    DELIVER_SEEK_INFO
    CHAINCODE_PACKAGE
}

type Transaction {
    txID: String!
    type: TransactionType!
    createdAt: Time!
    version: String!
    path: String
    response: String
    request: String
    chaincode: String!
    writes: [TransactionWrite!]
    reads: [TransactionRead!]
}
type PDCReadHash {
    pdcName: String!
    keyHash: String!
    rwSetHash: String!
    version: PDCReadVersion
}
type PDCReadVersion {
    blockNum: Int!
    txNum: Int!
}

type PDCWriteHash {
    pdcName: String!
    keyHash: String!
    rwSetHash: String!
    valueHash: String!
    isDelete: Boolean!
    isPurge: Boolean!
}

type TransactionWithPrivateData {
    txID: String!
    type: TransactionType!
    createdAt: Time!
    version: String!
    path: String
    response: String
    request: String
    chaincode: String!
    writes: [TransactionWrite!]
    reads: [TransactionRead!]

    pdcWrites: [PDCWrite!]
    pdcReads: [PDCRead!]

    pdcWriteHashes: [PDCWriteHash!]
    pdcReadHashes: [PDCReadHash!]
}
type PDCRead {
    collectionName: String!
    key: String!
    block: Int!
    txNum: Int!
}
type PDCWrite {
    collectionName: String!
    deleted: Boolean!
    key: String!
    value: String!
}
type TransactionWrite {
    chaincodeID: String!
    deleted: Boolean!
    key: String!
    value: String!
}
type TransactionRead {
    chaincodeID: String!
    key: String!
    blockNumVersion: Int
    txNumVersion: Int
}

type Namespace {
    name: String!
}
input NameAndNamespace {
    name: String!
    namespace: String!
}

type Peer {
    name: String!
    namespace: String!
    yaml: String!
    storage: PeerStorage
}

type Orderer {
    name: String!
    namespace: String!
    yaml: String!
    storage: OrdererStorage
}

type CA {
    name: String!
    namespace: String!
    yaml: String!
    storage: CAStorage
}

type PeerStorage {
    chaincode: StorageUsage
    couchDB: StorageUsage!
    peer: StorageUsage!
}
type CAStorage {
    ca: StorageUsage!
}
type OrdererStorage {
    orderer: StorageUsage!
}
type StorageUsage {
    used: Int!
    usedGB: String!
    free: Int!
    freeGB: String!
    size: Int!
    sizeGB: String!
    percentageUsed: Float!
}

type Channel {
    name: String!
    rawConfig: String!
    protoConfig: String!
    channelConfig: ChannelConfig!
    application: ApplicationConfig
    orderer: OrdererConfig!
    height: Int!
    chaincodes: [ChannelChaincode!]
    peers: [ChannelPeer!]
}
type ChannelPeer {
    mspID: String!
    url: String!
    height: Int!
}
type ChannelChaincode {
    name: String!
    version: String!
    sequence: Int!
    signaturePolicy: SignaturePolicy!
    endorsementPlugin: String!
    validationPlugin: String!
    configPolicy: String!
    privateDataCollections: [PrivateDataCollection!]
    approvals: [ChaincodeApproval!]
}
type ChaincodeApproval {
    mspID: String!
    approved: Boolean!
}
type PrivateDataCollection {
    name: String!
    requiredPeerCount: Int!
    maxPeerCount: Int!
    blockToLive: Int!
    memberOnlyRead: Boolean!
    memberOnlyWrite: Boolean!
    endorsementPolicy: ApplicationPolicy
    memberOrgsPolicy: SignaturePolicy
}
type SignaturePolicy {
    version: Int!
    rule: SignaturePolicyRule!
    principals: [MSPPrincipal!]
}
type MSPPrincipal {
    combined: MSPPrincipalCombined
    role: MSPPrincipalRole
}
type MSPPrincipalRole {
    mspID: String!
    role: String!
}
type MSPPrincipalCombined {
    classification: String!
    mspPrincipals: [MSPPrincipal!]
}
type SignaturePolicyRule {
    type: String!
    noutOf: SignaturePolicyNOutOf
    signedBy: SignaturePolicySignedBy
}
type ApplicationPolicy {
    channelConfigPolicy: String!
    signaturePolicy: SignaturePolicy
}
type SignaturePolicySignedBy {
    signedBy: Int!
}
type SignaturePolicyNOutOf {
    n: Int!
    rules: [SignaturePolicyRule!]
}


type ChannelConfig {
    policies: [ChannelPolicy!]
    capabilities: [String!]
}
type ApplicationConfig {
    policies: [ChannelPolicy!]
    acls: [ChannelACL!]
    capabilities: [String!]
    organizations: [ChannelOrg!]
}
type ChannelACL {
    key: String!
    value: String!
}
type OrdererConfig {
    type: String!
    batchTimeout: Int!
    batchSize: OrdererConfigBatchSize!
    maxChannels: Int!
    capabilities: [String!]
    state: String!
    policies: [ChannelPolicy!]
    etcdDraft: OrdererConfigRaft!
    organizations: [ChannelOrg!]
}
type ChannelOrg {
    modPolicy: String!
    mspID: String!
    policies: [ChannelPolicy!]
    msp: ChannelMSP!
    ordererEndpoints: [String!]
    anchorPeer: [NetworkAddress!]
    nodeOUs: NodeOUs!
    cryptoConfig: CryptoConfig!
    ous: [OUIdentifier!]
}
type CryptoConfig {
    signatureHashFamily: String!
    identityIdentifierHashFunction: String!
}
type NodeOUs {
    enable: Boolean!
    clientOUIdentifier: OUIdentifier!
    peerOUIdentifier: OUIdentifier!
    adminOUIdentifier: OUIdentifier!
    ordererOUIdentifier: OUIdentifier!
}
type OUIdentifier {
    certificate: String!
    ouIdentifier: String!
}
type ChannelMSP {
    name: String!
    rootCerts: [String!]
    intermediateCerts: [String!]
    admins: [String!]
    revocationList: [String!]
    tlsRootCerts: [String!]
    tlsIntermediateCerts: [String!]
}
type OrdererConfigRaft {
    consenters: [OrdererConfigRaftConsenter!]
    options: OrdererConfigRaftOptions!
}
type OrdererConfigRaftConsenter {
    address: NetworkAddress!
    clientTlsCert: String!
    serverTlsCert: String!
}
type NetworkAddress {
    host: String!
    port: Int!
}
type OrdererConfigRaftOptions {
    tickInterval: String!
    electionTick: Int!
    heartbeatTick: Int!
    maxInflightBlocks: Int!
    snapshotIntervalSize: Int!
}
type ChannelPolicy {
    key: String!
    type: String!
    rule: String!
    modPolicy: String!
}
type OrdererConfigBatchSize {
    maxMessageCount: Int!
    absoluteMaxBytes: Int!
    preferredMaxBytes: Int!
}

type ChannelAnchorPeer {
    mspID: String!
    host: String!
    port: Int!
}

`, BuiltIn: false},
	{Name: "../schemas/schema.graphql", Input: `schema {
    query: Query
    mutation: Mutation
}

directive @requiresAuth on FIELD_DEFINITION

scalar Time
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_createCA_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateCAInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateCAInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCreateCAInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createOrderer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateOrdererInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateOrdererInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCreateOrdererInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createPeer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreatePeerInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreatePeerInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCreatePeerInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_getUpdateChannelBlock_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.GetUpdateChannelBlockInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNGetUpdateChannelBlockInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsGetUpdateChannelBlockInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_renewOrdererCertificates_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.RenewOrdererCertificatesInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNRenewOrdererCertificatesInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsRenewOrdererCertificatesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_renewPeerCertificates_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.RenewPeerCertificatesInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNRenewPeerCertificatesInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsRenewPeerCertificatesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCA_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.NameAndNamespace
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalNNameAndNamespace2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNameAndNamespace(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 models.UpdateCAInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateCAInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsUpdateCAInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateChannel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdateChannelInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateChannelInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsUpdateChannelInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateOrderer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.NameAndNamespace
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalNNameAndNamespace2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNameAndNamespace(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 models.UpdateeOrdererInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateeOrdererInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsUpdateeOrdererInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePeer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.NameAndNamespace
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalNNameAndNamespace2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNameAndNamespace(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 models.UpdateePeerInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateePeerInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsUpdateePeerInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_blockByTXID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["channelID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channelID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["channelID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["transactionID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("transactionID"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["transactionID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_blockWithPrivateData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["channelID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channelID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["channelID"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["blockNumber"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockNumber"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["blockNumber"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_block_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["channelID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channelID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["channelID"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["blockNumber"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockNumber"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["blockNumber"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_blocks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["channelID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channelID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["channelID"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["from"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["from"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["to"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["to"] = arg2
	var arg3 bool
	if tmp, ok := rawArgs["reverse"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reverse"))
		arg3, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["reverse"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_ca_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.NameAndNamespace
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNNameAndNamespace2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNameAndNamespace(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_channel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["channelID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channelID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["channelID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_orderer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.NameAndNamespace
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNNameAndNamespace2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNameAndNamespace(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_peer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.NameAndNamespace
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNNameAndNamespace2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNameAndNamespace(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ApplicationConfig_policies(ctx context.Context, field graphql.CollectedField, obj *models.ApplicationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationConfig_policies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Policies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelPolicy)
	fc.Result = res
	return ec.marshalOChannelPolicy2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationConfig_policies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_ChannelPolicy_key(ctx, field)
			case "type":
				return ec.fieldContext_ChannelPolicy_type(ctx, field)
			case "rule":
				return ec.fieldContext_ChannelPolicy_rule(ctx, field)
			case "modPolicy":
				return ec.fieldContext_ChannelPolicy_modPolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationConfig_acls(ctx context.Context, field graphql.CollectedField, obj *models.ApplicationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationConfig_acls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Acls, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelACL)
	fc.Result = res
	return ec.marshalOChannelACL2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelACL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationConfig_acls(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_ChannelACL_key(ctx, field)
			case "value":
				return ec.fieldContext_ChannelACL_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelACL", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationConfig_capabilities(ctx context.Context, field graphql.CollectedField, obj *models.ApplicationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationConfig_capabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capabilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationConfig_capabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationConfig_organizations(ctx context.Context, field graphql.CollectedField, obj *models.ApplicationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationConfig_organizations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Organizations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelOrg)
	fc.Result = res
	return ec.marshalOChannelOrg2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelOrg(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationConfig_organizations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "modPolicy":
				return ec.fieldContext_ChannelOrg_modPolicy(ctx, field)
			case "mspID":
				return ec.fieldContext_ChannelOrg_mspID(ctx, field)
			case "policies":
				return ec.fieldContext_ChannelOrg_policies(ctx, field)
			case "msp":
				return ec.fieldContext_ChannelOrg_msp(ctx, field)
			case "ordererEndpoints":
				return ec.fieldContext_ChannelOrg_ordererEndpoints(ctx, field)
			case "anchorPeer":
				return ec.fieldContext_ChannelOrg_anchorPeer(ctx, field)
			case "nodeOUs":
				return ec.fieldContext_ChannelOrg_nodeOUs(ctx, field)
			case "cryptoConfig":
				return ec.fieldContext_ChannelOrg_cryptoConfig(ctx, field)
			case "ous":
				return ec.fieldContext_ChannelOrg_ous(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelOrg", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationPolicy_channelConfigPolicy(ctx context.Context, field graphql.CollectedField, obj *models.ApplicationPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationPolicy_channelConfigPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChannelConfigPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationPolicy_channelConfigPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationPolicy_signaturePolicy(ctx context.Context, field graphql.CollectedField, obj *models.ApplicationPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationPolicy_signaturePolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignaturePolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SignaturePolicy)
	fc.Result = res
	return ec.marshalOSignaturePolicy2githubcomkfsoftwarehlfoperatoruiapigqlmodelsSignaturePolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationPolicy_signaturePolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_SignaturePolicy_version(ctx, field)
			case "rule":
				return ec.fieldContext_SignaturePolicy_rule(ctx, field)
			case "principals":
				return ec.fieldContext_SignaturePolicy_principals(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignaturePolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_blockNumber(ctx context.Context, field graphql.CollectedField, obj *models.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_blockNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_blockNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_dataHash(ctx context.Context, field graphql.CollectedField, obj *models.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_dataHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_dataHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_numTransactions(ctx context.Context, field graphql.CollectedField, obj *models.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_numTransactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumTransactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_numTransactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_transactions(ctx context.Context, field graphql.CollectedField, obj *models.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_transactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Transaction)
	fc.Result = res
	return ec.marshalOTransaction2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_transactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "txID":
				return ec.fieldContext_Transaction_txID(ctx, field)
			case "type":
				return ec.fieldContext_Transaction_type(ctx, field)
			case "createdAt":
				return ec.fieldContext_Transaction_createdAt(ctx, field)
			case "version":
				return ec.fieldContext_Transaction_version(ctx, field)
			case "path":
				return ec.fieldContext_Transaction_path(ctx, field)
			case "response":
				return ec.fieldContext_Transaction_response(ctx, field)
			case "request":
				return ec.fieldContext_Transaction_request(ctx, field)
			case "chaincode":
				return ec.fieldContext_Transaction_chaincode(ctx, field)
			case "writes":
				return ec.fieldContext_Transaction_writes(ctx, field)
			case "reads":
				return ec.fieldContext_Transaction_reads(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockWithPrivateData_blockNumber(ctx context.Context, field graphql.CollectedField, obj *models.BlockWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockWithPrivateData_blockNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockWithPrivateData_blockNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockWithPrivateData_dataHash(ctx context.Context, field graphql.CollectedField, obj *models.BlockWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockWithPrivateData_dataHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockWithPrivateData_dataHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockWithPrivateData_numTransactions(ctx context.Context, field graphql.CollectedField, obj *models.BlockWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockWithPrivateData_numTransactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumTransactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockWithPrivateData_numTransactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockWithPrivateData_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.BlockWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockWithPrivateData_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockWithPrivateData_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockWithPrivateData_transactions(ctx context.Context, field graphql.CollectedField, obj *models.BlockWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockWithPrivateData_transactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.TransactionWithPrivateData)
	fc.Result = res
	return ec.marshalOTransactionWithPrivateData2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionWithPrivateData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockWithPrivateData_transactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "txID":
				return ec.fieldContext_TransactionWithPrivateData_txID(ctx, field)
			case "type":
				return ec.fieldContext_TransactionWithPrivateData_type(ctx, field)
			case "createdAt":
				return ec.fieldContext_TransactionWithPrivateData_createdAt(ctx, field)
			case "version":
				return ec.fieldContext_TransactionWithPrivateData_version(ctx, field)
			case "path":
				return ec.fieldContext_TransactionWithPrivateData_path(ctx, field)
			case "response":
				return ec.fieldContext_TransactionWithPrivateData_response(ctx, field)
			case "request":
				return ec.fieldContext_TransactionWithPrivateData_request(ctx, field)
			case "chaincode":
				return ec.fieldContext_TransactionWithPrivateData_chaincode(ctx, field)
			case "writes":
				return ec.fieldContext_TransactionWithPrivateData_writes(ctx, field)
			case "reads":
				return ec.fieldContext_TransactionWithPrivateData_reads(ctx, field)
			case "pdcWrites":
				return ec.fieldContext_TransactionWithPrivateData_pdcWrites(ctx, field)
			case "pdcReads":
				return ec.fieldContext_TransactionWithPrivateData_pdcReads(ctx, field)
			case "pdcWriteHashes":
				return ec.fieldContext_TransactionWithPrivateData_pdcWriteHashes(ctx, field)
			case "pdcReadHashes":
				return ec.fieldContext_TransactionWithPrivateData_pdcReadHashes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionWithPrivateData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlocksResponse_height(ctx context.Context, field graphql.CollectedField, obj *models.BlocksResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlocksResponse_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlocksResponse_height(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlocksResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlocksResponse_blocks(ctx context.Context, field graphql.CollectedField, obj *models.BlocksResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlocksResponse_blocks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Blocks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Block)
	fc.Result = res
	return ec.marshalOBlock2githubcomkfsoftwarehlfoperatoruiapigqlmodelsBlock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlocksResponse_blocks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlocksResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "blockNumber":
				return ec.fieldContext_Block_blockNumber(ctx, field)
			case "dataHash":
				return ec.fieldContext_Block_dataHash(ctx, field)
			case "numTransactions":
				return ec.fieldContext_Block_numTransactions(ctx, field)
			case "createdAt":
				return ec.fieldContext_Block_createdAt(ctx, field)
			case "transactions":
				return ec.fieldContext_Block_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Block", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CA_name(ctx context.Context, field graphql.CollectedField, obj *models.Ca) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CA_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CA_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CA_namespace(ctx context.Context, field graphql.CollectedField, obj *models.Ca) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CA_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CA_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CA_yaml(ctx context.Context, field graphql.CollectedField, obj *models.Ca) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CA_yaml(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Yaml, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CA_yaml(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CA_storage(ctx context.Context, field graphql.CollectedField, obj *models.Ca) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CA_storage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CA().Storage(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.CAStorage)
	fc.Result = res
	return ec.marshalOCAStorage2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCAStorage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CA_storage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CA",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ca":
				return ec.fieldContext_CAStorage_ca(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CAStorage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CAStorage_ca(ctx context.Context, field graphql.CollectedField, obj *models.CAStorage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CAStorage_ca(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ca, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.StorageUsage)
	fc.Result = res
	return ec.marshalNStorageUsage2githubcomkfsoftwarehlfoperatoruiapigqlmodelsStorageUsage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CAStorage_ca(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CAStorage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "used":
				return ec.fieldContext_StorageUsage_used(ctx, field)
			case "usedGB":
				return ec.fieldContext_StorageUsage_usedGB(ctx, field)
			case "free":
				return ec.fieldContext_StorageUsage_free(ctx, field)
			case "freeGB":
				return ec.fieldContext_StorageUsage_freeGB(ctx, field)
			case "size":
				return ec.fieldContext_StorageUsage_size(ctx, field)
			case "sizeGB":
				return ec.fieldContext_StorageUsage_sizeGB(ctx, field)
			case "percentageUsed":
				return ec.fieldContext_StorageUsage_percentageUsed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StorageUsage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChaincodeApproval_mspID(ctx context.Context, field graphql.CollectedField, obj *models.ChaincodeApproval) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChaincodeApproval_mspID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MspID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChaincodeApproval_mspID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChaincodeApproval",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChaincodeApproval_approved(ctx context.Context, field graphql.CollectedField, obj *models.ChaincodeApproval) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChaincodeApproval_approved(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Approved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChaincodeApproval_approved(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChaincodeApproval",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_name(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_rawConfig(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_rawConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RawConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_rawConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_protoConfig(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_protoConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProtoConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_protoConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_channelConfig(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_channelConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChannelConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.ChannelConfig)
	fc.Result = res
	return ec.marshalNChannelConfig2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_channelConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "policies":
				return ec.fieldContext_ChannelConfig_policies(ctx, field)
			case "capabilities":
				return ec.fieldContext_ChannelConfig_capabilities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_application(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_application(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Application, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ApplicationConfig)
	fc.Result = res
	return ec.marshalOApplicationConfig2githubcomkfsoftwarehlfoperatoruiapigqlmodelsApplicationConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_application(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "policies":
				return ec.fieldContext_ApplicationConfig_policies(ctx, field)
			case "acls":
				return ec.fieldContext_ApplicationConfig_acls(ctx, field)
			case "capabilities":
				return ec.fieldContext_ApplicationConfig_capabilities(ctx, field)
			case "organizations":
				return ec.fieldContext_ApplicationConfig_organizations(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_orderer(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_orderer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Orderer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OrdererConfig)
	fc.Result = res
	return ec.marshalNOrdererConfig2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_orderer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_OrdererConfig_type(ctx, field)
			case "batchTimeout":
				return ec.fieldContext_OrdererConfig_batchTimeout(ctx, field)
			case "batchSize":
				return ec.fieldContext_OrdererConfig_batchSize(ctx, field)
			case "maxChannels":
				return ec.fieldContext_OrdererConfig_maxChannels(ctx, field)
			case "capabilities":
				return ec.fieldContext_OrdererConfig_capabilities(ctx, field)
			case "state":
				return ec.fieldContext_OrdererConfig_state(ctx, field)
			case "policies":
				return ec.fieldContext_OrdererConfig_policies(ctx, field)
			case "etcdDraft":
				return ec.fieldContext_OrdererConfig_etcdDraft(ctx, field)
			case "organizations":
				return ec.fieldContext_OrdererConfig_organizations(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrdererConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_height(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_height(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_chaincodes(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_chaincodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Channel().Chaincodes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelChaincode)
	fc.Result = res
	return ec.marshalOChannelChaincode2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelChaincode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_chaincodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ChannelChaincode_name(ctx, field)
			case "version":
				return ec.fieldContext_ChannelChaincode_version(ctx, field)
			case "sequence":
				return ec.fieldContext_ChannelChaincode_sequence(ctx, field)
			case "signaturePolicy":
				return ec.fieldContext_ChannelChaincode_signaturePolicy(ctx, field)
			case "endorsementPlugin":
				return ec.fieldContext_ChannelChaincode_endorsementPlugin(ctx, field)
			case "validationPlugin":
				return ec.fieldContext_ChannelChaincode_validationPlugin(ctx, field)
			case "configPolicy":
				return ec.fieldContext_ChannelChaincode_configPolicy(ctx, field)
			case "privateDataCollections":
				return ec.fieldContext_ChannelChaincode_privateDataCollections(ctx, field)
			case "approvals":
				return ec.fieldContext_ChannelChaincode_approvals(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelChaincode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Channel_peers(ctx context.Context, field graphql.CollectedField, obj *models.Channel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Channel_peers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Channel().Peers(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelPeer)
	fc.Result = res
	return ec.marshalOChannelPeer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelPeer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Channel_peers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Channel",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mspID":
				return ec.fieldContext_ChannelPeer_mspID(ctx, field)
			case "url":
				return ec.fieldContext_ChannelPeer_url(ctx, field)
			case "height":
				return ec.fieldContext_ChannelPeer_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelPeer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelACL_key(ctx context.Context, field graphql.CollectedField, obj *models.ChannelACL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelACL_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelACL_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelACL",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelACL_value(ctx context.Context, field graphql.CollectedField, obj *models.ChannelACL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelACL_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelACL_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelACL",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelAnchorPeer_mspID(ctx context.Context, field graphql.CollectedField, obj *models.ChannelAnchorPeer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelAnchorPeer_mspID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MspID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelAnchorPeer_mspID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelAnchorPeer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelAnchorPeer_host(ctx context.Context, field graphql.CollectedField, obj *models.ChannelAnchorPeer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelAnchorPeer_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelAnchorPeer_host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelAnchorPeer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelAnchorPeer_port(ctx context.Context, field graphql.CollectedField, obj *models.ChannelAnchorPeer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelAnchorPeer_port(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelAnchorPeer_port(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelAnchorPeer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_name(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_version(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_sequence(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_sequence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sequence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_sequence(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_signaturePolicy(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_signaturePolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignaturePolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.SignaturePolicy)
	fc.Result = res
	return ec.marshalNSignaturePolicy2githubcomkfsoftwarehlfoperatoruiapigqlmodelsSignaturePolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_signaturePolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_SignaturePolicy_version(ctx, field)
			case "rule":
				return ec.fieldContext_SignaturePolicy_rule(ctx, field)
			case "principals":
				return ec.fieldContext_SignaturePolicy_principals(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignaturePolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_endorsementPlugin(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_endorsementPlugin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndorsementPlugin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_endorsementPlugin(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_validationPlugin(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_validationPlugin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidationPlugin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_validationPlugin(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_configPolicy(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_configPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_configPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_privateDataCollections(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_privateDataCollections(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrivateDataCollections, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.PrivateDataCollection)
	fc.Result = res
	return ec.marshalOPrivateDataCollection2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPrivateDataCollection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_privateDataCollections(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_PrivateDataCollection_name(ctx, field)
			case "requiredPeerCount":
				return ec.fieldContext_PrivateDataCollection_requiredPeerCount(ctx, field)
			case "maxPeerCount":
				return ec.fieldContext_PrivateDataCollection_maxPeerCount(ctx, field)
			case "blockToLive":
				return ec.fieldContext_PrivateDataCollection_blockToLive(ctx, field)
			case "memberOnlyRead":
				return ec.fieldContext_PrivateDataCollection_memberOnlyRead(ctx, field)
			case "memberOnlyWrite":
				return ec.fieldContext_PrivateDataCollection_memberOnlyWrite(ctx, field)
			case "endorsementPolicy":
				return ec.fieldContext_PrivateDataCollection_endorsementPolicy(ctx, field)
			case "memberOrgsPolicy":
				return ec.fieldContext_PrivateDataCollection_memberOrgsPolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PrivateDataCollection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelChaincode_approvals(ctx context.Context, field graphql.CollectedField, obj *models.ChannelChaincode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelChaincode_approvals(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Approvals, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChaincodeApproval)
	fc.Result = res
	return ec.marshalOChaincodeApproval2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChaincodeApproval(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelChaincode_approvals(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelChaincode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mspID":
				return ec.fieldContext_ChaincodeApproval_mspID(ctx, field)
			case "approved":
				return ec.fieldContext_ChaincodeApproval_approved(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChaincodeApproval", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelConfig_policies(ctx context.Context, field graphql.CollectedField, obj *models.ChannelConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelConfig_policies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Policies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelPolicy)
	fc.Result = res
	return ec.marshalOChannelPolicy2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelConfig_policies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_ChannelPolicy_key(ctx, field)
			case "type":
				return ec.fieldContext_ChannelPolicy_type(ctx, field)
			case "rule":
				return ec.fieldContext_ChannelPolicy_rule(ctx, field)
			case "modPolicy":
				return ec.fieldContext_ChannelPolicy_modPolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelConfig_capabilities(ctx context.Context, field graphql.CollectedField, obj *models.ChannelConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelConfig_capabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capabilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelConfig_capabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMSP_name(ctx context.Context, field graphql.CollectedField, obj *models.ChannelMsp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelMSP_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelMSP_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMSP",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMSP_rootCerts(ctx context.Context, field graphql.CollectedField, obj *models.ChannelMsp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelMSP_rootCerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootCerts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelMSP_rootCerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMSP",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMSP_intermediateCerts(ctx context.Context, field graphql.CollectedField, obj *models.ChannelMsp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelMSP_intermediateCerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IntermediateCerts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelMSP_intermediateCerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMSP",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMSP_admins(ctx context.Context, field graphql.CollectedField, obj *models.ChannelMsp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelMSP_admins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Admins, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelMSP_admins(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMSP",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMSP_revocationList(ctx context.Context, field graphql.CollectedField, obj *models.ChannelMsp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelMSP_revocationList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RevocationList, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelMSP_revocationList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMSP",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMSP_tlsRootCerts(ctx context.Context, field graphql.CollectedField, obj *models.ChannelMsp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelMSP_tlsRootCerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TLSRootCerts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelMSP_tlsRootCerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMSP",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelMSP_tlsIntermediateCerts(ctx context.Context, field graphql.CollectedField, obj *models.ChannelMsp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelMSP_tlsIntermediateCerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TLSIntermediateCerts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelMSP_tlsIntermediateCerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelMSP",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_modPolicy(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_modPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_modPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_mspID(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_mspID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MspID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_mspID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_policies(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_policies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Policies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelPolicy)
	fc.Result = res
	return ec.marshalOChannelPolicy2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_policies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_ChannelPolicy_key(ctx, field)
			case "type":
				return ec.fieldContext_ChannelPolicy_type(ctx, field)
			case "rule":
				return ec.fieldContext_ChannelPolicy_rule(ctx, field)
			case "modPolicy":
				return ec.fieldContext_ChannelPolicy_modPolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_msp(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_msp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Msp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.ChannelMsp)
	fc.Result = res
	return ec.marshalNChannelMSP2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelMsp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_msp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ChannelMSP_name(ctx, field)
			case "rootCerts":
				return ec.fieldContext_ChannelMSP_rootCerts(ctx, field)
			case "intermediateCerts":
				return ec.fieldContext_ChannelMSP_intermediateCerts(ctx, field)
			case "admins":
				return ec.fieldContext_ChannelMSP_admins(ctx, field)
			case "revocationList":
				return ec.fieldContext_ChannelMSP_revocationList(ctx, field)
			case "tlsRootCerts":
				return ec.fieldContext_ChannelMSP_tlsRootCerts(ctx, field)
			case "tlsIntermediateCerts":
				return ec.fieldContext_ChannelMSP_tlsIntermediateCerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelMSP", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_ordererEndpoints(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_ordererEndpoints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrdererEndpoints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_ordererEndpoints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_anchorPeer(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_anchorPeer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnchorPeer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.NetworkAddress)
	fc.Result = res
	return ec.marshalONetworkAddress2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNetworkAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_anchorPeer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "host":
				return ec.fieldContext_NetworkAddress_host(ctx, field)
			case "port":
				return ec.fieldContext_NetworkAddress_port(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NetworkAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_nodeOUs(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_nodeOUs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NodeOUs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.NodeOUs)
	fc.Result = res
	return ec.marshalNNodeOUs2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNodeOUs(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_nodeOUs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "enable":
				return ec.fieldContext_NodeOUs_enable(ctx, field)
			case "clientOUIdentifier":
				return ec.fieldContext_NodeOUs_clientOUIdentifier(ctx, field)
			case "peerOUIdentifier":
				return ec.fieldContext_NodeOUs_peerOUIdentifier(ctx, field)
			case "adminOUIdentifier":
				return ec.fieldContext_NodeOUs_adminOUIdentifier(ctx, field)
			case "ordererOUIdentifier":
				return ec.fieldContext_NodeOUs_ordererOUIdentifier(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeOUs", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_cryptoConfig(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_cryptoConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CryptoConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.CryptoConfig)
	fc.Result = res
	return ec.marshalNCryptoConfig2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCryptoConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_cryptoConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "signatureHashFamily":
				return ec.fieldContext_CryptoConfig_signatureHashFamily(ctx, field)
			case "identityIdentifierHashFunction":
				return ec.fieldContext_CryptoConfig_identityIdentifierHashFunction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CryptoConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelOrg_ous(ctx context.Context, field graphql.CollectedField, obj *models.ChannelOrg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelOrg_ous(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ous, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.OUIdentifier)
	fc.Result = res
	return ec.marshalOOUIdentifier2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOUIdentifier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelOrg_ous(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelOrg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "certificate":
				return ec.fieldContext_OUIdentifier_certificate(ctx, field)
			case "ouIdentifier":
				return ec.fieldContext_OUIdentifier_ouIdentifier(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OUIdentifier", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelPeer_mspID(ctx context.Context, field graphql.CollectedField, obj *models.ChannelPeer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelPeer_mspID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MspID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelPeer_mspID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelPeer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelPeer_url(ctx context.Context, field graphql.CollectedField, obj *models.ChannelPeer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelPeer_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelPeer_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelPeer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelPeer_height(ctx context.Context, field graphql.CollectedField, obj *models.ChannelPeer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelPeer_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelPeer_height(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelPeer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelPolicy_key(ctx context.Context, field graphql.CollectedField, obj *models.ChannelPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelPolicy_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelPolicy_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelPolicy_type(ctx context.Context, field graphql.CollectedField, obj *models.ChannelPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelPolicy_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelPolicy_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelPolicy_rule(ctx context.Context, field graphql.CollectedField, obj *models.ChannelPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelPolicy_rule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelPolicy_rule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChannelPolicy_modPolicy(ctx context.Context, field graphql.CollectedField, obj *models.ChannelPolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChannelPolicy_modPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChannelPolicy_modPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChannelPolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CryptoConfig_signatureHashFamily(ctx context.Context, field graphql.CollectedField, obj *models.CryptoConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CryptoConfig_signatureHashFamily(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignatureHashFamily, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CryptoConfig_signatureHashFamily(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CryptoConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CryptoConfig_identityIdentifierHashFunction(ctx context.Context, field graphql.CollectedField, obj *models.CryptoConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CryptoConfig_identityIdentifierHashFunction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IdentityIdentifierHashFunction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CryptoConfig_identityIdentifierHashFunction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CryptoConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Error_message(ctx context.Context, field graphql.CollectedField, obj *models.Error) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Error_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Error_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Error",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetUpdateChannelBlockResponse_errors(ctx context.Context, field graphql.CollectedField, obj *models.GetUpdateChannelBlockResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetUpdateChannelBlockResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Error)
	fc.Result = res
	return ec.marshalOError2githubcomkfsoftwarehlfoperatoruiapigqlmodelsError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetUpdateChannelBlockResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetUpdateChannelBlockResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_Error_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Error", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetUpdateChannelBlockResponse_block(ctx context.Context, field graphql.CollectedField, obj *models.GetUpdateChannelBlockResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetUpdateChannelBlockResponse_block(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Block, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetUpdateChannelBlockResponse_block(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetUpdateChannelBlockResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetUpdateChannelBlockResponse_configUpdate(ctx context.Context, field graphql.CollectedField, obj *models.GetUpdateChannelBlockResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetUpdateChannelBlockResponse_configUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigUpdate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetUpdateChannelBlockResponse_configUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetUpdateChannelBlockResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LightChannel_name(ctx context.Context, field graphql.CollectedField, obj *models.LightChannel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LightChannel_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LightChannel_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LightChannel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MSPPrincipal_combined(ctx context.Context, field graphql.CollectedField, obj *models.MSPPrincipal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MSPPrincipal_combined(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Combined, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MSPPrincipalCombined)
	fc.Result = res
	return ec.marshalOMSPPrincipalCombined2githubcomkfsoftwarehlfoperatoruiapigqlmodelsMSPPrincipalCombined(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MSPPrincipal_combined(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MSPPrincipal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "classification":
				return ec.fieldContext_MSPPrincipalCombined_classification(ctx, field)
			case "mspPrincipals":
				return ec.fieldContext_MSPPrincipalCombined_mspPrincipals(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MSPPrincipalCombined", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MSPPrincipal_role(ctx context.Context, field graphql.CollectedField, obj *models.MSPPrincipal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MSPPrincipal_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MSPPrincipalRole)
	fc.Result = res
	return ec.marshalOMSPPrincipalRole2githubcomkfsoftwarehlfoperatoruiapigqlmodelsMSPPrincipalRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MSPPrincipal_role(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MSPPrincipal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mspID":
				return ec.fieldContext_MSPPrincipalRole_mspID(ctx, field)
			case "role":
				return ec.fieldContext_MSPPrincipalRole_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MSPPrincipalRole", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MSPPrincipalCombined_classification(ctx context.Context, field graphql.CollectedField, obj *models.MSPPrincipalCombined) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MSPPrincipalCombined_classification(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Classification, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MSPPrincipalCombined_classification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MSPPrincipalCombined",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MSPPrincipalCombined_mspPrincipals(ctx context.Context, field graphql.CollectedField, obj *models.MSPPrincipalCombined) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MSPPrincipalCombined_mspPrincipals(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MspPrincipals, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.MSPPrincipal)
	fc.Result = res
	return ec.marshalOMSPPrincipal2githubcomkfsoftwarehlfoperatoruiapigqlmodelsMSPPrincipal(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MSPPrincipalCombined_mspPrincipals(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MSPPrincipalCombined",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "combined":
				return ec.fieldContext_MSPPrincipal_combined(ctx, field)
			case "role":
				return ec.fieldContext_MSPPrincipal_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MSPPrincipal", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MSPPrincipalRole_mspID(ctx context.Context, field graphql.CollectedField, obj *models.MSPPrincipalRole) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MSPPrincipalRole_mspID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MspID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MSPPrincipalRole_mspID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MSPPrincipalRole",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MSPPrincipalRole_role(ctx context.Context, field graphql.CollectedField, obj *models.MSPPrincipalRole) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MSPPrincipalRole_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MSPPrincipalRole_role(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MSPPrincipalRole",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createPeer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createPeer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePeer(rctx, fc.Args["input"].(models.CreatePeerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Peer)
	fc.Result = res
	return ec.marshalOPeer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPeer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createPeer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Peer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Peer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Peer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Peer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Peer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createPeer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updatePeer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updatePeer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePeer(rctx, fc.Args["filter"].(models.NameAndNamespace), fc.Args["input"].(models.UpdateePeerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Peer)
	fc.Result = res
	return ec.marshalOPeer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPeer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updatePeer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Peer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Peer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Peer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Peer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Peer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updatePeer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createOrderer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createOrderer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateOrderer(rctx, fc.Args["input"].(models.CreateOrdererInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Orderer)
	fc.Result = res
	return ec.marshalOOrderer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrderer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createOrderer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Orderer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Orderer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Orderer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Orderer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Orderer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createOrderer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateOrderer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateOrderer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateOrderer(rctx, fc.Args["filter"].(models.NameAndNamespace), fc.Args["input"].(models.UpdateeOrdererInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Orderer)
	fc.Result = res
	return ec.marshalOOrderer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrderer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateOrderer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Orderer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Orderer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Orderer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Orderer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Orderer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateOrderer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createCA(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createCA(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateCa(rctx, fc.Args["input"].(models.CreateCAInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Ca)
	fc.Result = res
	return ec.marshalOCA2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCa(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createCA(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_CA_name(ctx, field)
			case "namespace":
				return ec.fieldContext_CA_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_CA_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_CA_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CA", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createCA_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateCA(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateCA(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateCa(rctx, fc.Args["filter"].(models.NameAndNamespace), fc.Args["input"].(models.UpdateCAInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Ca)
	fc.Result = res
	return ec.marshalOCA2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCa(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateCA(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_CA_name(ctx, field)
			case "namespace":
				return ec.fieldContext_CA_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_CA_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_CA_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CA", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateCA_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_renewPeerCertificates(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_renewPeerCertificates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RenewPeerCertificates(rctx, fc.Args["input"].(models.RenewPeerCertificatesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.RenewPeerCertificatesResponse)
	fc.Result = res
	return ec.marshalNRenewPeerCertificatesResponse2githubcomkfsoftwarehlfoperatoruiapigqlmodelsRenewPeerCertificatesResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_renewPeerCertificates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "peer":
				return ec.fieldContext_RenewPeerCertificatesResponse_peer(ctx, field)
			case "errors":
				return ec.fieldContext_RenewPeerCertificatesResponse_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RenewPeerCertificatesResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_renewPeerCertificates_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_renewOrdererCertificates(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_renewOrdererCertificates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RenewOrdererCertificates(rctx, fc.Args["input"].(models.RenewOrdererCertificatesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.RenewOrdererCertificatesResponse)
	fc.Result = res
	return ec.marshalNRenewOrdererCertificatesResponse2githubcomkfsoftwarehlfoperatoruiapigqlmodelsRenewOrdererCertificatesResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_renewOrdererCertificates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "orderer":
				return ec.fieldContext_RenewOrdererCertificatesResponse_orderer(ctx, field)
			case "errors":
				return ec.fieldContext_RenewOrdererCertificatesResponse_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RenewOrdererCertificatesResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_renewOrdererCertificates_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateChannel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateChannel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateChannel(rctx, fc.Args["input"].(models.UpdateChannelInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.UpdateChannelResponse)
	fc.Result = res
	return ec.marshalNUpdateChannelResponse2githubcomkfsoftwarehlfoperatoruiapigqlmodelsUpdateChannelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateChannel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_UpdateChannelResponse_errors(ctx, field)
			case "transactionID":
				return ec.fieldContext_UpdateChannelResponse_transactionID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateChannelResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateChannel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_getUpdateChannelBlock(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_getUpdateChannelBlock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GetUpdateChannelBlock(rctx, fc.Args["input"].(models.GetUpdateChannelBlockInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.GetUpdateChannelBlockResponse)
	fc.Result = res
	return ec.marshalNGetUpdateChannelBlockResponse2githubcomkfsoftwarehlfoperatoruiapigqlmodelsGetUpdateChannelBlockResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_getUpdateChannelBlock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_GetUpdateChannelBlockResponse_errors(ctx, field)
			case "block":
				return ec.fieldContext_GetUpdateChannelBlockResponse_block(ctx, field)
			case "configUpdate":
				return ec.fieldContext_GetUpdateChannelBlockResponse_configUpdate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetUpdateChannelBlockResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_getUpdateChannelBlock_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Namespace_name(ctx context.Context, field graphql.CollectedField, obj *models.Namespace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Namespace_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Namespace_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Namespace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkAddress_host(ctx context.Context, field graphql.CollectedField, obj *models.NetworkAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkAddress_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkAddress_host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkAddress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NetworkAddress_port(ctx context.Context, field graphql.CollectedField, obj *models.NetworkAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NetworkAddress_port(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NetworkAddress_port(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NetworkAddress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeOUs_enable(ctx context.Context, field graphql.CollectedField, obj *models.NodeOUs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeOUs_enable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeOUs_enable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeOUs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeOUs_clientOUIdentifier(ctx context.Context, field graphql.CollectedField, obj *models.NodeOUs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeOUs_clientOUIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientOUIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OUIdentifier)
	fc.Result = res
	return ec.marshalNOUIdentifier2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOUIdentifier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeOUs_clientOUIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeOUs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "certificate":
				return ec.fieldContext_OUIdentifier_certificate(ctx, field)
			case "ouIdentifier":
				return ec.fieldContext_OUIdentifier_ouIdentifier(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OUIdentifier", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeOUs_peerOUIdentifier(ctx context.Context, field graphql.CollectedField, obj *models.NodeOUs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeOUs_peerOUIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PeerOUIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OUIdentifier)
	fc.Result = res
	return ec.marshalNOUIdentifier2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOUIdentifier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeOUs_peerOUIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeOUs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "certificate":
				return ec.fieldContext_OUIdentifier_certificate(ctx, field)
			case "ouIdentifier":
				return ec.fieldContext_OUIdentifier_ouIdentifier(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OUIdentifier", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeOUs_adminOUIdentifier(ctx context.Context, field graphql.CollectedField, obj *models.NodeOUs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeOUs_adminOUIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdminOUIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OUIdentifier)
	fc.Result = res
	return ec.marshalNOUIdentifier2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOUIdentifier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeOUs_adminOUIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeOUs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "certificate":
				return ec.fieldContext_OUIdentifier_certificate(ctx, field)
			case "ouIdentifier":
				return ec.fieldContext_OUIdentifier_ouIdentifier(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OUIdentifier", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeOUs_ordererOUIdentifier(ctx context.Context, field graphql.CollectedField, obj *models.NodeOUs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeOUs_ordererOUIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrdererOUIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OUIdentifier)
	fc.Result = res
	return ec.marshalNOUIdentifier2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOUIdentifier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeOUs_ordererOUIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeOUs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "certificate":
				return ec.fieldContext_OUIdentifier_certificate(ctx, field)
			case "ouIdentifier":
				return ec.fieldContext_OUIdentifier_ouIdentifier(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OUIdentifier", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OUIdentifier_certificate(ctx context.Context, field graphql.CollectedField, obj *models.OUIdentifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OUIdentifier_certificate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Certificate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OUIdentifier_certificate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OUIdentifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OUIdentifier_ouIdentifier(ctx context.Context, field graphql.CollectedField, obj *models.OUIdentifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OUIdentifier_ouIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OuIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OUIdentifier_ouIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OUIdentifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Orderer_name(ctx context.Context, field graphql.CollectedField, obj *models.Orderer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Orderer_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Orderer_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Orderer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Orderer_namespace(ctx context.Context, field graphql.CollectedField, obj *models.Orderer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Orderer_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Orderer_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Orderer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Orderer_yaml(ctx context.Context, field graphql.CollectedField, obj *models.Orderer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Orderer_yaml(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Yaml, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Orderer_yaml(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Orderer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Orderer_storage(ctx context.Context, field graphql.CollectedField, obj *models.Orderer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Orderer_storage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Orderer().Storage(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.OrdererStorage)
	fc.Result = res
	return ec.marshalOOrdererStorage2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererStorage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Orderer_storage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Orderer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "orderer":
				return ec.fieldContext_OrdererStorage_orderer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrdererStorage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_type(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_batchTimeout(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_batchTimeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BatchTimeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_batchTimeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_batchSize(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_batchSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BatchSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OrdererConfigBatchSize)
	fc.Result = res
	return ec.marshalNOrdererConfigBatchSize2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigBatchSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_batchSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "maxMessageCount":
				return ec.fieldContext_OrdererConfigBatchSize_maxMessageCount(ctx, field)
			case "absoluteMaxBytes":
				return ec.fieldContext_OrdererConfigBatchSize_absoluteMaxBytes(ctx, field)
			case "preferredMaxBytes":
				return ec.fieldContext_OrdererConfigBatchSize_preferredMaxBytes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrdererConfigBatchSize", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_maxChannels(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_maxChannels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxChannels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_maxChannels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_capabilities(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_capabilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capabilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_capabilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_state(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_policies(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_policies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Policies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelPolicy)
	fc.Result = res
	return ec.marshalOChannelPolicy2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_policies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_ChannelPolicy_key(ctx, field)
			case "type":
				return ec.fieldContext_ChannelPolicy_type(ctx, field)
			case "rule":
				return ec.fieldContext_ChannelPolicy_rule(ctx, field)
			case "modPolicy":
				return ec.fieldContext_ChannelPolicy_modPolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_etcdDraft(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_etcdDraft(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EtcdDraft, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OrdererConfigRaft)
	fc.Result = res
	return ec.marshalNOrdererConfigRaft2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigRaft(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_etcdDraft(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "consenters":
				return ec.fieldContext_OrdererConfigRaft_consenters(ctx, field)
			case "options":
				return ec.fieldContext_OrdererConfigRaft_options(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrdererConfigRaft", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfig_organizations(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfig_organizations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Organizations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ChannelOrg)
	fc.Result = res
	return ec.marshalOChannelOrg2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelOrg(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfig_organizations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "modPolicy":
				return ec.fieldContext_ChannelOrg_modPolicy(ctx, field)
			case "mspID":
				return ec.fieldContext_ChannelOrg_mspID(ctx, field)
			case "policies":
				return ec.fieldContext_ChannelOrg_policies(ctx, field)
			case "msp":
				return ec.fieldContext_ChannelOrg_msp(ctx, field)
			case "ordererEndpoints":
				return ec.fieldContext_ChannelOrg_ordererEndpoints(ctx, field)
			case "anchorPeer":
				return ec.fieldContext_ChannelOrg_anchorPeer(ctx, field)
			case "nodeOUs":
				return ec.fieldContext_ChannelOrg_nodeOUs(ctx, field)
			case "cryptoConfig":
				return ec.fieldContext_ChannelOrg_cryptoConfig(ctx, field)
			case "ous":
				return ec.fieldContext_ChannelOrg_ous(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChannelOrg", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigBatchSize_maxMessageCount(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigBatchSize) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigBatchSize_maxMessageCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxMessageCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigBatchSize_maxMessageCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigBatchSize",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigBatchSize_absoluteMaxBytes(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigBatchSize) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigBatchSize_absoluteMaxBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbsoluteMaxBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigBatchSize_absoluteMaxBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigBatchSize",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigBatchSize_preferredMaxBytes(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigBatchSize) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigBatchSize_preferredMaxBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreferredMaxBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigBatchSize_preferredMaxBytes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigBatchSize",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaft_consenters(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaft_consenters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Consenters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.OrdererConfigRaftConsenter)
	fc.Result = res
	return ec.marshalOOrdererConfigRaftConsenter2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigRaftConsenter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaft_consenters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_OrdererConfigRaftConsenter_address(ctx, field)
			case "clientTlsCert":
				return ec.fieldContext_OrdererConfigRaftConsenter_clientTlsCert(ctx, field)
			case "serverTlsCert":
				return ec.fieldContext_OrdererConfigRaftConsenter_serverTlsCert(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrdererConfigRaftConsenter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaft_options(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaft_options(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Options, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OrdererConfigRaftOptions)
	fc.Result = res
	return ec.marshalNOrdererConfigRaftOptions2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigRaftOptions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaft_options(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tickInterval":
				return ec.fieldContext_OrdererConfigRaftOptions_tickInterval(ctx, field)
			case "electionTick":
				return ec.fieldContext_OrdererConfigRaftOptions_electionTick(ctx, field)
			case "heartbeatTick":
				return ec.fieldContext_OrdererConfigRaftOptions_heartbeatTick(ctx, field)
			case "maxInflightBlocks":
				return ec.fieldContext_OrdererConfigRaftOptions_maxInflightBlocks(ctx, field)
			case "snapshotIntervalSize":
				return ec.fieldContext_OrdererConfigRaftOptions_snapshotIntervalSize(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrdererConfigRaftOptions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaftConsenter_address(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaftConsenter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaftConsenter_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.NetworkAddress)
	fc.Result = res
	return ec.marshalNNetworkAddress2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNetworkAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaftConsenter_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaftConsenter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "host":
				return ec.fieldContext_NetworkAddress_host(ctx, field)
			case "port":
				return ec.fieldContext_NetworkAddress_port(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NetworkAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaftConsenter_clientTlsCert(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaftConsenter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaftConsenter_clientTlsCert(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientTLSCert, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaftConsenter_clientTlsCert(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaftConsenter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaftConsenter_serverTlsCert(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaftConsenter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaftConsenter_serverTlsCert(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServerTLSCert, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaftConsenter_serverTlsCert(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaftConsenter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaftOptions_tickInterval(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaftOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaftOptions_tickInterval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TickInterval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaftOptions_tickInterval(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaftOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaftOptions_electionTick(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaftOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaftOptions_electionTick(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ElectionTick, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaftOptions_electionTick(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaftOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaftOptions_heartbeatTick(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaftOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaftOptions_heartbeatTick(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeartbeatTick, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaftOptions_heartbeatTick(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaftOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaftOptions_maxInflightBlocks(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaftOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaftOptions_maxInflightBlocks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxInflightBlocks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaftOptions_maxInflightBlocks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaftOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererConfigRaftOptions_snapshotIntervalSize(ctx context.Context, field graphql.CollectedField, obj *models.OrdererConfigRaftOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererConfigRaftOptions_snapshotIntervalSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SnapshotIntervalSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererConfigRaftOptions_snapshotIntervalSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererConfigRaftOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrdererStorage_orderer(ctx context.Context, field graphql.CollectedField, obj *models.OrdererStorage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrdererStorage_orderer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Orderer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.StorageUsage)
	fc.Result = res
	return ec.marshalNStorageUsage2githubcomkfsoftwarehlfoperatoruiapigqlmodelsStorageUsage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrdererStorage_orderer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrdererStorage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "used":
				return ec.fieldContext_StorageUsage_used(ctx, field)
			case "usedGB":
				return ec.fieldContext_StorageUsage_usedGB(ctx, field)
			case "free":
				return ec.fieldContext_StorageUsage_free(ctx, field)
			case "freeGB":
				return ec.fieldContext_StorageUsage_freeGB(ctx, field)
			case "size":
				return ec.fieldContext_StorageUsage_size(ctx, field)
			case "sizeGB":
				return ec.fieldContext_StorageUsage_sizeGB(ctx, field)
			case "percentageUsed":
				return ec.fieldContext_StorageUsage_percentageUsed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StorageUsage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCRead_collectionName(ctx context.Context, field graphql.CollectedField, obj *models.PDCRead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCRead_collectionName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CollectionName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCRead_collectionName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCRead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCRead_key(ctx context.Context, field graphql.CollectedField, obj *models.PDCRead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCRead_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCRead_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCRead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCRead_block(ctx context.Context, field graphql.CollectedField, obj *models.PDCRead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCRead_block(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Block, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCRead_block(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCRead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCRead_txNum(ctx context.Context, field graphql.CollectedField, obj *models.PDCRead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCRead_txNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCRead_txNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCRead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCReadHash_pdcName(ctx context.Context, field graphql.CollectedField, obj *models.PDCReadHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCReadHash_pdcName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PdcName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCReadHash_pdcName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCReadHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCReadHash_keyHash(ctx context.Context, field graphql.CollectedField, obj *models.PDCReadHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCReadHash_keyHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KeyHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCReadHash_keyHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCReadHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCReadHash_rwSetHash(ctx context.Context, field graphql.CollectedField, obj *models.PDCReadHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCReadHash_rwSetHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RwSetHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCReadHash_rwSetHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCReadHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCReadHash_version(ctx context.Context, field graphql.CollectedField, obj *models.PDCReadHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCReadHash_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.PDCReadVersion)
	fc.Result = res
	return ec.marshalOPDCReadVersion2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCReadVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCReadHash_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCReadHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "blockNum":
				return ec.fieldContext_PDCReadVersion_blockNum(ctx, field)
			case "txNum":
				return ec.fieldContext_PDCReadVersion_txNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PDCReadVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCReadVersion_blockNum(ctx context.Context, field graphql.CollectedField, obj *models.PDCReadVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCReadVersion_blockNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCReadVersion_blockNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCReadVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCReadVersion_txNum(ctx context.Context, field graphql.CollectedField, obj *models.PDCReadVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCReadVersion_txNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCReadVersion_txNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCReadVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWrite_collectionName(ctx context.Context, field graphql.CollectedField, obj *models.PDCWrite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWrite_collectionName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CollectionName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWrite_collectionName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWrite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWrite_deleted(ctx context.Context, field graphql.CollectedField, obj *models.PDCWrite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWrite_deleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWrite_deleted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWrite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWrite_key(ctx context.Context, field graphql.CollectedField, obj *models.PDCWrite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWrite_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWrite_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWrite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWrite_value(ctx context.Context, field graphql.CollectedField, obj *models.PDCWrite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWrite_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWrite_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWrite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWriteHash_pdcName(ctx context.Context, field graphql.CollectedField, obj *models.PDCWriteHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWriteHash_pdcName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PdcName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWriteHash_pdcName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWriteHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWriteHash_keyHash(ctx context.Context, field graphql.CollectedField, obj *models.PDCWriteHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWriteHash_keyHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KeyHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWriteHash_keyHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWriteHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWriteHash_rwSetHash(ctx context.Context, field graphql.CollectedField, obj *models.PDCWriteHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWriteHash_rwSetHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RwSetHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWriteHash_rwSetHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWriteHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWriteHash_valueHash(ctx context.Context, field graphql.CollectedField, obj *models.PDCWriteHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWriteHash_valueHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValueHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWriteHash_valueHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWriteHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWriteHash_isDelete(ctx context.Context, field graphql.CollectedField, obj *models.PDCWriteHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWriteHash_isDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDelete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWriteHash_isDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWriteHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PDCWriteHash_isPurge(ctx context.Context, field graphql.CollectedField, obj *models.PDCWriteHash) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PDCWriteHash_isPurge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPurge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PDCWriteHash_isPurge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PDCWriteHash",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Peer_name(ctx context.Context, field graphql.CollectedField, obj *models.Peer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Peer_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Peer_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Peer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Peer_namespace(ctx context.Context, field graphql.CollectedField, obj *models.Peer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Peer_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Peer_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Peer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Peer_yaml(ctx context.Context, field graphql.CollectedField, obj *models.Peer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Peer_yaml(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Yaml, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Peer_yaml(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Peer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Peer_storage(ctx context.Context, field graphql.CollectedField, obj *models.Peer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Peer_storage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Peer().Storage(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.PeerStorage)
	fc.Result = res
	return ec.marshalOPeerStorage2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPeerStorage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Peer_storage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Peer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "chaincode":
				return ec.fieldContext_PeerStorage_chaincode(ctx, field)
			case "couchDB":
				return ec.fieldContext_PeerStorage_couchDB(ctx, field)
			case "peer":
				return ec.fieldContext_PeerStorage_peer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PeerStorage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeerStorage_chaincode(ctx context.Context, field graphql.CollectedField, obj *models.PeerStorage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeerStorage_chaincode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chaincode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.StorageUsage)
	fc.Result = res
	return ec.marshalOStorageUsage2githubcomkfsoftwarehlfoperatoruiapigqlmodelsStorageUsage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeerStorage_chaincode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeerStorage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "used":
				return ec.fieldContext_StorageUsage_used(ctx, field)
			case "usedGB":
				return ec.fieldContext_StorageUsage_usedGB(ctx, field)
			case "free":
				return ec.fieldContext_StorageUsage_free(ctx, field)
			case "freeGB":
				return ec.fieldContext_StorageUsage_freeGB(ctx, field)
			case "size":
				return ec.fieldContext_StorageUsage_size(ctx, field)
			case "sizeGB":
				return ec.fieldContext_StorageUsage_sizeGB(ctx, field)
			case "percentageUsed":
				return ec.fieldContext_StorageUsage_percentageUsed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StorageUsage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeerStorage_couchDB(ctx context.Context, field graphql.CollectedField, obj *models.PeerStorage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeerStorage_couchDB(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CouchDb, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.StorageUsage)
	fc.Result = res
	return ec.marshalNStorageUsage2githubcomkfsoftwarehlfoperatoruiapigqlmodelsStorageUsage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeerStorage_couchDB(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeerStorage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "used":
				return ec.fieldContext_StorageUsage_used(ctx, field)
			case "usedGB":
				return ec.fieldContext_StorageUsage_usedGB(ctx, field)
			case "free":
				return ec.fieldContext_StorageUsage_free(ctx, field)
			case "freeGB":
				return ec.fieldContext_StorageUsage_freeGB(ctx, field)
			case "size":
				return ec.fieldContext_StorageUsage_size(ctx, field)
			case "sizeGB":
				return ec.fieldContext_StorageUsage_sizeGB(ctx, field)
			case "percentageUsed":
				return ec.fieldContext_StorageUsage_percentageUsed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StorageUsage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeerStorage_peer(ctx context.Context, field graphql.CollectedField, obj *models.PeerStorage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeerStorage_peer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Peer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.StorageUsage)
	fc.Result = res
	return ec.marshalNStorageUsage2githubcomkfsoftwarehlfoperatoruiapigqlmodelsStorageUsage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeerStorage_peer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeerStorage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "used":
				return ec.fieldContext_StorageUsage_used(ctx, field)
			case "usedGB":
				return ec.fieldContext_StorageUsage_usedGB(ctx, field)
			case "free":
				return ec.fieldContext_StorageUsage_free(ctx, field)
			case "freeGB":
				return ec.fieldContext_StorageUsage_freeGB(ctx, field)
			case "size":
				return ec.fieldContext_StorageUsage_size(ctx, field)
			case "sizeGB":
				return ec.fieldContext_StorageUsage_sizeGB(ctx, field)
			case "percentageUsed":
				return ec.fieldContext_StorageUsage_percentageUsed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StorageUsage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivateDataCollection_name(ctx context.Context, field graphql.CollectedField, obj *models.PrivateDataCollection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivateDataCollection_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivateDataCollection_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivateDataCollection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivateDataCollection_requiredPeerCount(ctx context.Context, field graphql.CollectedField, obj *models.PrivateDataCollection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivateDataCollection_requiredPeerCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredPeerCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivateDataCollection_requiredPeerCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivateDataCollection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivateDataCollection_maxPeerCount(ctx context.Context, field graphql.CollectedField, obj *models.PrivateDataCollection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivateDataCollection_maxPeerCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxPeerCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivateDataCollection_maxPeerCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivateDataCollection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivateDataCollection_blockToLive(ctx context.Context, field graphql.CollectedField, obj *models.PrivateDataCollection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivateDataCollection_blockToLive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockToLive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivateDataCollection_blockToLive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivateDataCollection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivateDataCollection_memberOnlyRead(ctx context.Context, field graphql.CollectedField, obj *models.PrivateDataCollection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivateDataCollection_memberOnlyRead(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MemberOnlyRead, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivateDataCollection_memberOnlyRead(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivateDataCollection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivateDataCollection_memberOnlyWrite(ctx context.Context, field graphql.CollectedField, obj *models.PrivateDataCollection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivateDataCollection_memberOnlyWrite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MemberOnlyWrite, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivateDataCollection_memberOnlyWrite(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivateDataCollection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivateDataCollection_endorsementPolicy(ctx context.Context, field graphql.CollectedField, obj *models.PrivateDataCollection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivateDataCollection_endorsementPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndorsementPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ApplicationPolicy)
	fc.Result = res
	return ec.marshalOApplicationPolicy2githubcomkfsoftwarehlfoperatoruiapigqlmodelsApplicationPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivateDataCollection_endorsementPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivateDataCollection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "channelConfigPolicy":
				return ec.fieldContext_ApplicationPolicy_channelConfigPolicy(ctx, field)
			case "signaturePolicy":
				return ec.fieldContext_ApplicationPolicy_signaturePolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationPolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrivateDataCollection_memberOrgsPolicy(ctx context.Context, field graphql.CollectedField, obj *models.PrivateDataCollection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrivateDataCollection_memberOrgsPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MemberOrgsPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SignaturePolicy)
	fc.Result = res
	return ec.marshalOSignaturePolicy2githubcomkfsoftwarehlfoperatoruiapigqlmodelsSignaturePolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrivateDataCollection_memberOrgsPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrivateDataCollection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_SignaturePolicy_version(ctx, field)
			case "rule":
				return ec.fieldContext_SignaturePolicy_rule(ctx, field)
			case "principals":
				return ec.fieldContext_SignaturePolicy_principals(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignaturePolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_peers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_peers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Peers(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*models.Peer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kfsoftware/hlf-operator-ui/api/gql/models.Peer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Peer)
	fc.Result = res
	return ec.marshalOPeer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPeer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_peers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Peer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Peer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Peer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Peer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Peer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_peer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_peer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Peer(rctx, fc.Args["input"].(models.NameAndNamespace))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Peer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kfsoftware/hlf-operator-ui/api/gql/models.Peer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Peer)
	fc.Result = res
	return ec.marshalOPeer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPeer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_peer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Peer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Peer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Peer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Peer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Peer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_peer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_orderers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_orderers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Orderers(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*models.Orderer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kfsoftware/hlf-operator-ui/api/gql/models.Orderer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Orderer)
	fc.Result = res
	return ec.marshalOOrderer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrderer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_orderers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Orderer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Orderer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Orderer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Orderer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Orderer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_orderer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_orderer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Orderer(rctx, fc.Args["input"].(models.NameAndNamespace))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Orderer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kfsoftware/hlf-operator-ui/api/gql/models.Orderer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Orderer)
	fc.Result = res
	return ec.marshalOOrderer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrderer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_orderer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Orderer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Orderer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Orderer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Orderer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Orderer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_orderer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_networkConfigEnabled(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_networkConfigEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().NetworkConfigEnabled(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_networkConfigEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_cas(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Cas(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*models.Ca); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kfsoftware/hlf-operator-ui/api/gql/models.Ca`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Ca)
	fc.Result = res
	return ec.marshalOCA2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCa(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_CA_name(ctx, field)
			case "namespace":
				return ec.fieldContext_CA_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_CA_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_CA_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CA", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_ca(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ca(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Ca(rctx, fc.Args["input"].(models.NameAndNamespace))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Ca); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kfsoftware/hlf-operator-ui/api/gql/models.Ca`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Ca)
	fc.Result = res
	return ec.marshalOCA2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCa(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ca(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_CA_name(ctx, field)
			case "namespace":
				return ec.fieldContext_CA_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_CA_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_CA_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CA", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ca_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_namespaces(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_namespaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Namespaces(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*models.Namespace); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kfsoftware/hlf-operator-ui/api/gql/models.Namespace`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Namespace)
	fc.Result = res
	return ec.marshalONamespace2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNamespace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_namespaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Namespace_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Namespace", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_storageClasses(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_storageClasses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().StorageClasses(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*models.StorageClass); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kfsoftware/hlf-operator-ui/api/gql/models.StorageClass`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.StorageClass)
	fc.Result = res
	return ec.marshalOStorageClass2githubcomkfsoftwarehlfoperatoruiapigqlmodelsStorageClass(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_storageClasses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_StorageClass_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StorageClass", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_channels(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_channels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Channels(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*models.LightChannel); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/kfsoftware/hlf-operator-ui/api/gql/models.LightChannel`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.LightChannel)
	fc.Result = res
	return ec.marshalOLightChannel2githubcomkfsoftwarehlfoperatoruiapigqlmodelsLightChannel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_channels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_LightChannel_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LightChannel", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_channel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_channel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Channel(rctx, fc.Args["channelID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Channel); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kfsoftware/hlf-operator-ui/api/gql/models.Channel`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Channel)
	fc.Result = res
	return ec.marshalNChannel2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_channel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Channel_name(ctx, field)
			case "rawConfig":
				return ec.fieldContext_Channel_rawConfig(ctx, field)
			case "protoConfig":
				return ec.fieldContext_Channel_protoConfig(ctx, field)
			case "channelConfig":
				return ec.fieldContext_Channel_channelConfig(ctx, field)
			case "application":
				return ec.fieldContext_Channel_application(ctx, field)
			case "orderer":
				return ec.fieldContext_Channel_orderer(ctx, field)
			case "height":
				return ec.fieldContext_Channel_height(ctx, field)
			case "chaincodes":
				return ec.fieldContext_Channel_chaincodes(ctx, field)
			case "peers":
				return ec.fieldContext_Channel_peers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Channel", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_channel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_blocks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_blocks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Blocks(rctx, fc.Args["channelID"].(string), fc.Args["from"].(int), fc.Args["to"].(int), fc.Args["reverse"].(bool))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.BlocksResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kfsoftware/hlf-operator-ui/api/gql/models.BlocksResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BlocksResponse)
	fc.Result = res
	return ec.marshalNBlocksResponse2githubcomkfsoftwarehlfoperatoruiapigqlmodelsBlocksResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_blocks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "height":
				return ec.fieldContext_BlocksResponse_height(ctx, field)
			case "blocks":
				return ec.fieldContext_BlocksResponse_blocks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BlocksResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_blocks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_block(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_block(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Block(rctx, fc.Args["channelID"].(string), fc.Args["blockNumber"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Block); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kfsoftware/hlf-operator-ui/api/gql/models.Block`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Block)
	fc.Result = res
	return ec.marshalNBlock2githubcomkfsoftwarehlfoperatoruiapigqlmodelsBlock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_block(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "blockNumber":
				return ec.fieldContext_Block_blockNumber(ctx, field)
			case "dataHash":
				return ec.fieldContext_Block_dataHash(ctx, field)
			case "numTransactions":
				return ec.fieldContext_Block_numTransactions(ctx, field)
			case "createdAt":
				return ec.fieldContext_Block_createdAt(ctx, field)
			case "transactions":
				return ec.fieldContext_Block_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Block", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_block_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_blockWithPrivateData(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_blockWithPrivateData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().BlockWithPrivateData(rctx, fc.Args["channelID"].(string), fc.Args["blockNumber"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.BlockWithPrivateData); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kfsoftware/hlf-operator-ui/api/gql/models.BlockWithPrivateData`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BlockWithPrivateData)
	fc.Result = res
	return ec.marshalNBlockWithPrivateData2githubcomkfsoftwarehlfoperatoruiapigqlmodelsBlockWithPrivateData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_blockWithPrivateData(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "blockNumber":
				return ec.fieldContext_BlockWithPrivateData_blockNumber(ctx, field)
			case "dataHash":
				return ec.fieldContext_BlockWithPrivateData_dataHash(ctx, field)
			case "numTransactions":
				return ec.fieldContext_BlockWithPrivateData_numTransactions(ctx, field)
			case "createdAt":
				return ec.fieldContext_BlockWithPrivateData_createdAt(ctx, field)
			case "transactions":
				return ec.fieldContext_BlockWithPrivateData_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BlockWithPrivateData", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_blockWithPrivateData_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_blockByTXID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_blockByTXID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().BlockByTxid(rctx, fc.Args["channelID"].(string), fc.Args["transactionID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequiresAuth == nil {
				return nil, errors.New("directive requiresAuth is not implemented")
			}
			return ec.directives.RequiresAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Block); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/kfsoftware/hlf-operator-ui/api/gql/models.Block`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Block)
	fc.Result = res
	return ec.marshalNBlock2githubcomkfsoftwarehlfoperatoruiapigqlmodelsBlock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_blockByTXID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "blockNumber":
				return ec.fieldContext_Block_blockNumber(ctx, field)
			case "dataHash":
				return ec.fieldContext_Block_dataHash(ctx, field)
			case "numTransactions":
				return ec.fieldContext_Block_numTransactions(ctx, field)
			case "createdAt":
				return ec.fieldContext_Block_createdAt(ctx, field)
			case "transactions":
				return ec.fieldContext_Block_transactions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Block", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_blockByTXID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RenewOrdererCertificatesResponse_orderer(ctx context.Context, field graphql.CollectedField, obj *models.RenewOrdererCertificatesResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RenewOrdererCertificatesResponse_orderer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Orderer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Orderer)
	fc.Result = res
	return ec.marshalOOrderer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrderer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RenewOrdererCertificatesResponse_orderer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RenewOrdererCertificatesResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Orderer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Orderer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Orderer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Orderer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Orderer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RenewOrdererCertificatesResponse_errors(ctx context.Context, field graphql.CollectedField, obj *models.RenewOrdererCertificatesResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RenewOrdererCertificatesResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Error)
	fc.Result = res
	return ec.marshalOError2githubcomkfsoftwarehlfoperatoruiapigqlmodelsError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RenewOrdererCertificatesResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RenewOrdererCertificatesResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_Error_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Error", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RenewPeerCertificatesResponse_peer(ctx context.Context, field graphql.CollectedField, obj *models.RenewPeerCertificatesResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RenewPeerCertificatesResponse_peer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Peer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Peer)
	fc.Result = res
	return ec.marshalOPeer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPeer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RenewPeerCertificatesResponse_peer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RenewPeerCertificatesResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Peer_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Peer_namespace(ctx, field)
			case "yaml":
				return ec.fieldContext_Peer_yaml(ctx, field)
			case "storage":
				return ec.fieldContext_Peer_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Peer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RenewPeerCertificatesResponse_errors(ctx context.Context, field graphql.CollectedField, obj *models.RenewPeerCertificatesResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RenewPeerCertificatesResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Error)
	fc.Result = res
	return ec.marshalOError2githubcomkfsoftwarehlfoperatoruiapigqlmodelsError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RenewPeerCertificatesResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RenewPeerCertificatesResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_Error_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Error", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicy_version(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicy_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicy_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicy_rule(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicy_rule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.SignaturePolicyRule)
	fc.Result = res
	return ec.marshalNSignaturePolicyRule2githubcomkfsoftwarehlfoperatoruiapigqlmodelsSignaturePolicyRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicy_rule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_SignaturePolicyRule_type(ctx, field)
			case "noutOf":
				return ec.fieldContext_SignaturePolicyRule_noutOf(ctx, field)
			case "signedBy":
				return ec.fieldContext_SignaturePolicyRule_signedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignaturePolicyRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicy_principals(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicy_principals(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Principals, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.MSPPrincipal)
	fc.Result = res
	return ec.marshalOMSPPrincipal2githubcomkfsoftwarehlfoperatoruiapigqlmodelsMSPPrincipal(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicy_principals(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "combined":
				return ec.fieldContext_MSPPrincipal_combined(ctx, field)
			case "role":
				return ec.fieldContext_MSPPrincipal_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MSPPrincipal", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicyNOutOf_n(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicyNOutOf) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicyNOutOf_n(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.N, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicyNOutOf_n(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicyNOutOf",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicyNOutOf_rules(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicyNOutOf) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicyNOutOf_rules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.SignaturePolicyRule)
	fc.Result = res
	return ec.marshalOSignaturePolicyRule2githubcomkfsoftwarehlfoperatoruiapigqlmodelsSignaturePolicyRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicyNOutOf_rules(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicyNOutOf",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_SignaturePolicyRule_type(ctx, field)
			case "noutOf":
				return ec.fieldContext_SignaturePolicyRule_noutOf(ctx, field)
			case "signedBy":
				return ec.fieldContext_SignaturePolicyRule_signedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignaturePolicyRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicyRule_type(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicyRule_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicyRule_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicyRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicyRule_noutOf(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicyRule_noutOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoutOf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SignaturePolicyNOutOf)
	fc.Result = res
	return ec.marshalOSignaturePolicyNOutOf2githubcomkfsoftwarehlfoperatoruiapigqlmodelsSignaturePolicyNOutOf(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicyRule_noutOf(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicyRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "n":
				return ec.fieldContext_SignaturePolicyNOutOf_n(ctx, field)
			case "rules":
				return ec.fieldContext_SignaturePolicyNOutOf_rules(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignaturePolicyNOutOf", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicyRule_signedBy(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicyRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicyRule_signedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SignaturePolicySignedBy)
	fc.Result = res
	return ec.marshalOSignaturePolicySignedBy2githubcomkfsoftwarehlfoperatoruiapigqlmodelsSignaturePolicySignedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicyRule_signedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicyRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "signedBy":
				return ec.fieldContext_SignaturePolicySignedBy_signedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignaturePolicySignedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignaturePolicySignedBy_signedBy(ctx context.Context, field graphql.CollectedField, obj *models.SignaturePolicySignedBy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignaturePolicySignedBy_signedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignaturePolicySignedBy_signedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignaturePolicySignedBy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageClass_name(ctx context.Context, field graphql.CollectedField, obj *models.StorageClass) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageClass_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageClass_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageClass",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_used(ctx context.Context, field graphql.CollectedField, obj *models.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_used(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_usedGB(ctx context.Context, field graphql.CollectedField, obj *models.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_usedGB(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsedGb, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_usedGB(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_free(ctx context.Context, field graphql.CollectedField, obj *models.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_free(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Free, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_free(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_freeGB(ctx context.Context, field graphql.CollectedField, obj *models.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_freeGB(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FreeGb, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_freeGB(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_size(ctx context.Context, field graphql.CollectedField, obj *models.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_sizeGB(ctx context.Context, field graphql.CollectedField, obj *models.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_sizeGB(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SizeGb, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_sizeGB(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_percentageUsed(ctx context.Context, field graphql.CollectedField, obj *models.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_percentageUsed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PercentageUsed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_percentageUsed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_txID(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_txID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_txID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_type(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.TransactionType)
	fc.Result = res
	return ec.marshalNTransactionType2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TransactionType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_version(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_path(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_response(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_response(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Response, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_response(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_request(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_request(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Request, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_request(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_chaincode(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_chaincode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chaincode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_chaincode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_writes(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_writes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Writes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.TransactionWrite)
	fc.Result = res
	return ec.marshalOTransactionWrite2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionWrite(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_writes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "chaincodeID":
				return ec.fieldContext_TransactionWrite_chaincodeID(ctx, field)
			case "deleted":
				return ec.fieldContext_TransactionWrite_deleted(ctx, field)
			case "key":
				return ec.fieldContext_TransactionWrite_key(ctx, field)
			case "value":
				return ec.fieldContext_TransactionWrite_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionWrite", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_reads(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_reads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reads, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.TransactionRead)
	fc.Result = res
	return ec.marshalOTransactionRead2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionRead(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_reads(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "chaincodeID":
				return ec.fieldContext_TransactionRead_chaincodeID(ctx, field)
			case "key":
				return ec.fieldContext_TransactionRead_key(ctx, field)
			case "blockNumVersion":
				return ec.fieldContext_TransactionRead_blockNumVersion(ctx, field)
			case "txNumVersion":
				return ec.fieldContext_TransactionRead_txNumVersion(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionRead", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRead_chaincodeID(ctx context.Context, field graphql.CollectedField, obj *models.TransactionRead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionRead_chaincodeID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaincodeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionRead_chaincodeID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRead_key(ctx context.Context, field graphql.CollectedField, obj *models.TransactionRead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionRead_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionRead_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRead_blockNumVersion(ctx context.Context, field graphql.CollectedField, obj *models.TransactionRead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionRead_blockNumVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockNumVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionRead_blockNumVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRead_txNumVersion(ctx context.Context, field graphql.CollectedField, obj *models.TransactionRead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionRead_txNumVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxNumVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionRead_txNumVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_txID(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_txID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_txID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_type(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.TransactionType)
	fc.Result = res
	return ec.marshalNTransactionType2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TransactionType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_version(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_path(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_response(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_response(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Response, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_response(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_request(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_request(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Request, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_request(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_chaincode(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_chaincode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chaincode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_chaincode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_writes(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_writes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Writes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.TransactionWrite)
	fc.Result = res
	return ec.marshalOTransactionWrite2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionWrite(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_writes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "chaincodeID":
				return ec.fieldContext_TransactionWrite_chaincodeID(ctx, field)
			case "deleted":
				return ec.fieldContext_TransactionWrite_deleted(ctx, field)
			case "key":
				return ec.fieldContext_TransactionWrite_key(ctx, field)
			case "value":
				return ec.fieldContext_TransactionWrite_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionWrite", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_reads(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_reads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reads, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.TransactionRead)
	fc.Result = res
	return ec.marshalOTransactionRead2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionRead(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_reads(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "chaincodeID":
				return ec.fieldContext_TransactionRead_chaincodeID(ctx, field)
			case "key":
				return ec.fieldContext_TransactionRead_key(ctx, field)
			case "blockNumVersion":
				return ec.fieldContext_TransactionRead_blockNumVersion(ctx, field)
			case "txNumVersion":
				return ec.fieldContext_TransactionRead_txNumVersion(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionRead", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_pdcWrites(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_pdcWrites(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PdcWrites, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.PDCWrite)
	fc.Result = res
	return ec.marshalOPDCWrite2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCWrite(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_pdcWrites(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "collectionName":
				return ec.fieldContext_PDCWrite_collectionName(ctx, field)
			case "deleted":
				return ec.fieldContext_PDCWrite_deleted(ctx, field)
			case "key":
				return ec.fieldContext_PDCWrite_key(ctx, field)
			case "value":
				return ec.fieldContext_PDCWrite_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PDCWrite", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_pdcReads(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_pdcReads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PdcReads, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.PDCRead)
	fc.Result = res
	return ec.marshalOPDCRead2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCRead(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_pdcReads(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "collectionName":
				return ec.fieldContext_PDCRead_collectionName(ctx, field)
			case "key":
				return ec.fieldContext_PDCRead_key(ctx, field)
			case "block":
				return ec.fieldContext_PDCRead_block(ctx, field)
			case "txNum":
				return ec.fieldContext_PDCRead_txNum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PDCRead", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_pdcWriteHashes(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_pdcWriteHashes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PdcWriteHashes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.PDCWriteHash)
	fc.Result = res
	return ec.marshalOPDCWriteHash2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCWriteHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_pdcWriteHashes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pdcName":
				return ec.fieldContext_PDCWriteHash_pdcName(ctx, field)
			case "keyHash":
				return ec.fieldContext_PDCWriteHash_keyHash(ctx, field)
			case "rwSetHash":
				return ec.fieldContext_PDCWriteHash_rwSetHash(ctx, field)
			case "valueHash":
				return ec.fieldContext_PDCWriteHash_valueHash(ctx, field)
			case "isDelete":
				return ec.fieldContext_PDCWriteHash_isDelete(ctx, field)
			case "isPurge":
				return ec.fieldContext_PDCWriteHash_isPurge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PDCWriteHash", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWithPrivateData_pdcReadHashes(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWithPrivateData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWithPrivateData_pdcReadHashes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PdcReadHashes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.PDCReadHash)
	fc.Result = res
	return ec.marshalOPDCReadHash2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCReadHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWithPrivateData_pdcReadHashes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWithPrivateData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pdcName":
				return ec.fieldContext_PDCReadHash_pdcName(ctx, field)
			case "keyHash":
				return ec.fieldContext_PDCReadHash_keyHash(ctx, field)
			case "rwSetHash":
				return ec.fieldContext_PDCReadHash_rwSetHash(ctx, field)
			case "version":
				return ec.fieldContext_PDCReadHash_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PDCReadHash", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWrite_chaincodeID(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWrite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWrite_chaincodeID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaincodeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWrite_chaincodeID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWrite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWrite_deleted(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWrite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWrite_deleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWrite_deleted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWrite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWrite_key(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWrite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWrite_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWrite_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWrite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionWrite_value(ctx context.Context, field graphql.CollectedField, obj *models.TransactionWrite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionWrite_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionWrite_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionWrite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateChannelResponse_errors(ctx context.Context, field graphql.CollectedField, obj *models.UpdateChannelResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateChannelResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Error)
	fc.Result = res
	return ec.marshalOError2githubcomkfsoftwarehlfoperatoruiapigqlmodelsError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateChannelResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateChannelResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_Error_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Error", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateChannelResponse_transactionID(ctx context.Context, field graphql.CollectedField, obj *models.UpdateChannelResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateChannelResponse_transactionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TransactionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateChannelResponse_transactionID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateChannelResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputApplicationConfigInput(ctx context.Context, obj interface{}) (models.ApplicationConfigInput, error) {
	var it models.ApplicationConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"policies", "acls", "capabilities", "addOrgs", "delOrgs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "policies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("policies"))
			it.Policies, err = ec.unmarshalOPolicyInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPolicyInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "acls":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acls"))
			it.Acls, err = ec.unmarshalOChannelACLInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelACLInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "capabilities":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capabilities"))
			it.Capabilities, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "addOrgs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addOrgs"))
			it.AddOrgs, err = ec.unmarshalOChannelOrganization2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelOrganization(ctx, v)
			if err != nil {
				return it, err
			}
		case "delOrgs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("delOrgs"))
			it.DelOrgs, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChannelACLInput(ctx context.Context, obj interface{}) (models.ChannelACLInput, error) {
	var it models.ChannelACLInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			it.Key, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			it.Value, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChannelConfigInput(ctx context.Context, obj interface{}) (models.ChannelConfigInput, error) {
	var it models.ChannelConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"policies", "capabilities"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "policies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("policies"))
			it.Policies, err = ec.unmarshalOPolicyInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPolicyInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "capabilities":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capabilities"))
			it.Capabilities, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChannelOrganization(ctx context.Context, obj interface{}) (models.ChannelOrganization, error) {
	var it models.ChannelOrganization
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"mspID", "modPolicy", "policies", "msp", "anchorPeers", "ordererEndpoints"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "mspID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mspID"))
			it.MspID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "modPolicy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modPolicy"))
			it.ModPolicy, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "policies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("policies"))
			it.Policies, err = ec.unmarshalOPolicyInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPolicyInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "msp":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("msp"))
			it.Msp, err = ec.unmarshalNMSPInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsMSPInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "anchorPeers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("anchorPeers"))
			it.AnchorPeers, err = ec.unmarshalONetworkAddressInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNetworkAddressInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "ordererEndpoints":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ordererEndpoints"))
			it.OrdererEndpoints, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateCAInput(ctx context.Context, obj interface{}) (models.CreateCAInput, error) {
	var it models.CreateCAInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"yaml"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "yaml":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yaml"))
			it.Yaml, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateOrdererInput(ctx context.Context, obj interface{}) (models.CreateOrdererInput, error) {
	var it models.CreateOrdererInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"yaml"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "yaml":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yaml"))
			it.Yaml, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreatePeerInput(ctx context.Context, obj interface{}) (models.CreatePeerInput, error) {
	var it models.CreatePeerInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"yaml"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "yaml":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yaml"))
			it.Yaml, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCryptoConfigInput(ctx context.Context, obj interface{}) (models.CryptoConfigInput, error) {
	var it models.CryptoConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["signatureHashFamily"]; !present {
		asMap["signatureHashFamily"] = "SHA2"
	}
	if _, present := asMap["identityIdentifierHashFunction"]; !present {
		asMap["identityIdentifierHashFunction"] = "SHA256"
	}

	fieldsInOrder := [...]string{"signatureHashFamily", "identityIdentifierHashFunction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "signatureHashFamily":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signatureHashFamily"))
			it.SignatureHashFamily, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "identityIdentifierHashFunction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identityIdentifierHashFunction"))
			it.IdentityIdentifierHashFunction, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEtcdRaftInput(ctx context.Context, obj interface{}) (models.EtcdRaftInput, error) {
	var it models.EtcdRaftInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"addConsenters", "delConsenters", "options"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "addConsenters":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addConsenters"))
			it.AddConsenters, err = ec.unmarshalOOrdererConfigRaftConsenterInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigRaftConsenterInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "delConsenters":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("delConsenters"))
			it.DelConsenters, err = ec.unmarshalOOrdererConfigRaftConsenterInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigRaftConsenterInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "options":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
			it.Options, err = ec.unmarshalOOrdererConfigRaftOptionsInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigRaftOptionsInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGetUpdateChannelBlockInput(ctx context.Context, obj interface{}) (models.GetUpdateChannelBlockInput, error) {
	var it models.GetUpdateChannelBlockInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"channelID", "application", "orderer", "channel"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "channelID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channelID"))
			it.ChannelID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "application":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("application"))
			it.Application, err = ec.unmarshalNApplicationConfigInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsApplicationConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "orderer":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderer"))
			it.Orderer, err = ec.unmarshalOOrdererConfigInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "channel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channel"))
			it.Channel, err = ec.unmarshalNChannelConfigInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMSPInput(ctx context.Context, obj interface{}) (models.MSPInput, error) {
	var it models.MSPInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "rootCerts", "intermediateCerts", "admins", "revocationList", "ous", "tlsRootCerts", "tlsIntermediateCerts", "nodeOUs", "cryptoConfig"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rootCerts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rootCerts"))
			it.RootCerts, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "intermediateCerts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("intermediateCerts"))
			it.IntermediateCerts, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "admins":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
			it.Admins, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "revocationList":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revocationList"))
			it.RevocationList, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ous":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ous"))
			it.Ous, err = ec.unmarshalOOUIdentifierInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOUIdentifierInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "tlsRootCerts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tlsRootCerts"))
			it.TLSRootCerts, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tlsIntermediateCerts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tlsIntermediateCerts"))
			it.TLSIntermediateCerts, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nodeOUs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nodeOUs"))
			it.NodeOUs, err = ec.unmarshalNNodeOUsInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNodeOUsInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "cryptoConfig":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cryptoConfig"))
			it.CryptoConfig, err = ec.unmarshalNCryptoConfigInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCryptoConfigInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMSPSignature(ctx context.Context, obj interface{}) (models.MSPSignature, error) {
	var it models.MSPSignature
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"mspID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "mspID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mspID"))
			it.MspID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNameAndNamespace(ctx context.Context, obj interface{}) (models.NameAndNamespace, error) {
	var it models.NameAndNamespace
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			it.Namespace, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNetworkAddressInput(ctx context.Context, obj interface{}) (models.NetworkAddressInput, error) {
	var it models.NetworkAddressInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"host", "port"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "host":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("host"))
			it.Host, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "port":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("port"))
			it.Port, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNodeOUsInput(ctx context.Context, obj interface{}) (models.NodeOUsInput, error) {
	var it models.NodeOUsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"enable", "clientOUIdentifier", "peerOUIdentifier", "adminOUIdentifier", "ordererOUIdentifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "enable":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enable"))
			it.Enable, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "clientOUIdentifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientOUIdentifier"))
			it.ClientOUIdentifier, err = ec.unmarshalNOUIdentifierInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOUIdentifierInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "peerOUIdentifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("peerOUIdentifier"))
			it.PeerOUIdentifier, err = ec.unmarshalNOUIdentifierInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOUIdentifierInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "adminOUIdentifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adminOUIdentifier"))
			it.AdminOUIdentifier, err = ec.unmarshalNOUIdentifierInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOUIdentifierInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "ordererOUIdentifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ordererOUIdentifier"))
			it.OrdererOUIdentifier, err = ec.unmarshalNOUIdentifierInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOUIdentifierInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOUIdentifierInput(ctx context.Context, obj interface{}) (models.OUIdentifierInput, error) {
	var it models.OUIdentifierInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"certificate", "ouIdentifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "certificate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("certificate"))
			it.Certificate, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ouIdentifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ouIdentifier"))
			it.OuIdentifier, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOrdererConfigBatchSizeInput(ctx context.Context, obj interface{}) (models.OrdererConfigBatchSizeInput, error) {
	var it models.OrdererConfigBatchSizeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"maxMessageCount", "absoluteMaxBytes", "preferredMaxBytes"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "maxMessageCount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxMessageCount"))
			it.MaxMessageCount, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "absoluteMaxBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("absoluteMaxBytes"))
			it.AbsoluteMaxBytes, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "preferredMaxBytes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preferredMaxBytes"))
			it.PreferredMaxBytes, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOrdererConfigInput(ctx context.Context, obj interface{}) (models.OrdererConfigInput, error) {
	var it models.OrdererConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"batchTimeout", "state", "etcdRaft", "addPolicies", "addCapabilities", "addOrganizations", "delOrganizations", "batchSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "batchTimeout":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("batchTimeout"))
			it.BatchTimeout, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "state":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
			it.State, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "etcdRaft":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("etcdRaft"))
			it.EtcdRaft, err = ec.unmarshalOEtcdRaftInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsEtcdRaftInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "addPolicies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addPolicies"))
			it.AddPolicies, err = ec.unmarshalOPolicyInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPolicyInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "addCapabilities":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addCapabilities"))
			it.AddCapabilities, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "addOrganizations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addOrganizations"))
			it.AddOrganizations, err = ec.unmarshalOChannelOrganization2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelOrganization(ctx, v)
			if err != nil {
				return it, err
			}
		case "delOrganizations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("delOrganizations"))
			it.DelOrganizations, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "batchSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("batchSize"))
			it.BatchSize, err = ec.unmarshalOOrdererConfigBatchSizeInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigBatchSizeInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOrdererConfigRaftConsenterInput(ctx context.Context, obj interface{}) (models.OrdererConfigRaftConsenterInput, error) {
	var it models.OrdererConfigRaftConsenterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"address", "clientTlsCert", "serverTlsCert"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "address":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
			it.Address, err = ec.unmarshalNNetworkAddressInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNetworkAddressInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "clientTlsCert":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientTlsCert"))
			it.ClientTLSCert, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "serverTlsCert":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serverTlsCert"))
			it.ServerTLSCert, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOrdererConfigRaftOptionsInput(ctx context.Context, obj interface{}) (models.OrdererConfigRaftOptionsInput, error) {
	var it models.OrdererConfigRaftOptionsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tickInterval", "electionTick", "heartbeatTick", "maxInflightBlocks", "snapshotIntervalSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tickInterval":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tickInterval"))
			it.TickInterval, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "electionTick":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("electionTick"))
			it.ElectionTick, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "heartbeatTick":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("heartbeatTick"))
			it.HeartbeatTick, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxInflightBlocks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxInflightBlocks"))
			it.MaxInflightBlocks, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "snapshotIntervalSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("snapshotIntervalSize"))
			it.SnapshotIntervalSize, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPolicyInput(ctx context.Context, obj interface{}) (models.PolicyInput, error) {
	var it models.PolicyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "type", "rule", "modPolicy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			it.Key, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rule":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rule"))
			it.Rule, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "modPolicy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modPolicy"))
			it.ModPolicy, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRawSignature(ctx context.Context, obj interface{}) (models.RawSignature, error) {
	var it models.RawSignature
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"raw"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "raw":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("raw"))
			it.Raw, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRenewOrdererCertificatesInput(ctx context.Context, obj interface{}) (models.RenewOrdererCertificatesInput, error) {
	var it models.RenewOrdererCertificatesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"namespace", "name", "force"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			it.Namespace, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "force":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("force"))
			it.Force, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRenewPeerCertificatesInput(ctx context.Context, obj interface{}) (models.RenewPeerCertificatesInput, error) {
	var it models.RenewPeerCertificatesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"namespace", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			it.Namespace, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCAInput(ctx context.Context, obj interface{}) (models.UpdateCAInput, error) {
	var it models.UpdateCAInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"yaml"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "yaml":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yaml"))
			it.Yaml, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateChannelInput(ctx context.Context, obj interface{}) (models.UpdateChannelInput, error) {
	var it models.UpdateChannelInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "block", "rawSignatures", "mspSignatures"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "block":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("block"))
			it.Block, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rawSignatures":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rawSignatures"))
			it.RawSignatures, err = ec.unmarshalORawSignature2githubcomkfsoftwarehlfoperatoruiapigqlmodelsRawSignature(ctx, v)
			if err != nil {
				return it, err
			}
		case "mspSignatures":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mspSignatures"))
			it.MspSignatures, err = ec.unmarshalOMSPSignature2githubcomkfsoftwarehlfoperatoruiapigqlmodelsMSPSignature(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateeOrdererInput(ctx context.Context, obj interface{}) (models.UpdateeOrdererInput, error) {
	var it models.UpdateeOrdererInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"yaml"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "yaml":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yaml"))
			it.Yaml, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateePeerInput(ctx context.Context, obj interface{}) (models.UpdateePeerInput, error) {
	var it models.UpdateePeerInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"yaml"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "yaml":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yaml"))
			it.Yaml, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var applicationConfigImplementors = []string{"ApplicationConfig"}

func (ec *executionContext) _ApplicationConfig(ctx context.Context, sel ast.SelectionSet, obj *models.ApplicationConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationConfig")
		case "policies":

			out.Values[i] = ec._ApplicationConfig_policies(ctx, field, obj)

		case "acls":

			out.Values[i] = ec._ApplicationConfig_acls(ctx, field, obj)

		case "capabilities":

			out.Values[i] = ec._ApplicationConfig_capabilities(ctx, field, obj)

		case "organizations":

			out.Values[i] = ec._ApplicationConfig_organizations(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationPolicyImplementors = []string{"ApplicationPolicy"}

func (ec *executionContext) _ApplicationPolicy(ctx context.Context, sel ast.SelectionSet, obj *models.ApplicationPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationPolicyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationPolicy")
		case "channelConfigPolicy":

			out.Values[i] = ec._ApplicationPolicy_channelConfigPolicy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "signaturePolicy":

			out.Values[i] = ec._ApplicationPolicy_signaturePolicy(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blockImplementors = []string{"Block"}

func (ec *executionContext) _Block(ctx context.Context, sel ast.SelectionSet, obj *models.Block) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blockImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Block")
		case "blockNumber":

			out.Values[i] = ec._Block_blockNumber(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dataHash":

			out.Values[i] = ec._Block_dataHash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "numTransactions":

			out.Values[i] = ec._Block_numTransactions(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":

			out.Values[i] = ec._Block_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "transactions":

			out.Values[i] = ec._Block_transactions(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blockWithPrivateDataImplementors = []string{"BlockWithPrivateData"}

func (ec *executionContext) _BlockWithPrivateData(ctx context.Context, sel ast.SelectionSet, obj *models.BlockWithPrivateData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blockWithPrivateDataImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlockWithPrivateData")
		case "blockNumber":

			out.Values[i] = ec._BlockWithPrivateData_blockNumber(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dataHash":

			out.Values[i] = ec._BlockWithPrivateData_dataHash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "numTransactions":

			out.Values[i] = ec._BlockWithPrivateData_numTransactions(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":

			out.Values[i] = ec._BlockWithPrivateData_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "transactions":

			out.Values[i] = ec._BlockWithPrivateData_transactions(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blocksResponseImplementors = []string{"BlocksResponse"}

func (ec *executionContext) _BlocksResponse(ctx context.Context, sel ast.SelectionSet, obj *models.BlocksResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blocksResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlocksResponse")
		case "height":

			out.Values[i] = ec._BlocksResponse_height(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "blocks":

			out.Values[i] = ec._BlocksResponse_blocks(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cAImplementors = []string{"CA"}

func (ec *executionContext) _CA(ctx context.Context, sel ast.SelectionSet, obj *models.Ca) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cAImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CA")
		case "name":

			out.Values[i] = ec._CA_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "namespace":

			out.Values[i] = ec._CA_namespace(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "yaml":

			out.Values[i] = ec._CA_yaml(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "storage":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CA_storage(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cAStorageImplementors = []string{"CAStorage"}

func (ec *executionContext) _CAStorage(ctx context.Context, sel ast.SelectionSet, obj *models.CAStorage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cAStorageImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CAStorage")
		case "ca":

			out.Values[i] = ec._CAStorage_ca(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chaincodeApprovalImplementors = []string{"ChaincodeApproval"}

func (ec *executionContext) _ChaincodeApproval(ctx context.Context, sel ast.SelectionSet, obj *models.ChaincodeApproval) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chaincodeApprovalImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChaincodeApproval")
		case "mspID":

			out.Values[i] = ec._ChaincodeApproval_mspID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "approved":

			out.Values[i] = ec._ChaincodeApproval_approved(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelImplementors = []string{"Channel"}

func (ec *executionContext) _Channel(ctx context.Context, sel ast.SelectionSet, obj *models.Channel) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Channel")
		case "name":

			out.Values[i] = ec._Channel_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "rawConfig":

			out.Values[i] = ec._Channel_rawConfig(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "protoConfig":

			out.Values[i] = ec._Channel_protoConfig(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "channelConfig":

			out.Values[i] = ec._Channel_channelConfig(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "application":

			out.Values[i] = ec._Channel_application(ctx, field, obj)

		case "orderer":

			out.Values[i] = ec._Channel_orderer(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "height":

			out.Values[i] = ec._Channel_height(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "chaincodes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Channel_chaincodes(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "peers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Channel_peers(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelACLImplementors = []string{"ChannelACL"}

func (ec *executionContext) _ChannelACL(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelACL) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelACLImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelACL")
		case "key":

			out.Values[i] = ec._ChannelACL_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._ChannelACL_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelAnchorPeerImplementors = []string{"ChannelAnchorPeer"}

func (ec *executionContext) _ChannelAnchorPeer(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelAnchorPeer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelAnchorPeerImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelAnchorPeer")
		case "mspID":

			out.Values[i] = ec._ChannelAnchorPeer_mspID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "host":

			out.Values[i] = ec._ChannelAnchorPeer_host(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "port":

			out.Values[i] = ec._ChannelAnchorPeer_port(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelChaincodeImplementors = []string{"ChannelChaincode"}

func (ec *executionContext) _ChannelChaincode(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelChaincode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelChaincodeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelChaincode")
		case "name":

			out.Values[i] = ec._ChannelChaincode_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":

			out.Values[i] = ec._ChannelChaincode_version(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sequence":

			out.Values[i] = ec._ChannelChaincode_sequence(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "signaturePolicy":

			out.Values[i] = ec._ChannelChaincode_signaturePolicy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "endorsementPlugin":

			out.Values[i] = ec._ChannelChaincode_endorsementPlugin(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "validationPlugin":

			out.Values[i] = ec._ChannelChaincode_validationPlugin(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "configPolicy":

			out.Values[i] = ec._ChannelChaincode_configPolicy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "privateDataCollections":

			out.Values[i] = ec._ChannelChaincode_privateDataCollections(ctx, field, obj)

		case "approvals":

			out.Values[i] = ec._ChannelChaincode_approvals(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelConfigImplementors = []string{"ChannelConfig"}

func (ec *executionContext) _ChannelConfig(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelConfig")
		case "policies":

			out.Values[i] = ec._ChannelConfig_policies(ctx, field, obj)

		case "capabilities":

			out.Values[i] = ec._ChannelConfig_capabilities(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelMSPImplementors = []string{"ChannelMSP"}

func (ec *executionContext) _ChannelMSP(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelMsp) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelMSPImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelMSP")
		case "name":

			out.Values[i] = ec._ChannelMSP_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rootCerts":

			out.Values[i] = ec._ChannelMSP_rootCerts(ctx, field, obj)

		case "intermediateCerts":

			out.Values[i] = ec._ChannelMSP_intermediateCerts(ctx, field, obj)

		case "admins":

			out.Values[i] = ec._ChannelMSP_admins(ctx, field, obj)

		case "revocationList":

			out.Values[i] = ec._ChannelMSP_revocationList(ctx, field, obj)

		case "tlsRootCerts":

			out.Values[i] = ec._ChannelMSP_tlsRootCerts(ctx, field, obj)

		case "tlsIntermediateCerts":

			out.Values[i] = ec._ChannelMSP_tlsIntermediateCerts(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelOrgImplementors = []string{"ChannelOrg"}

func (ec *executionContext) _ChannelOrg(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelOrg) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelOrgImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelOrg")
		case "modPolicy":

			out.Values[i] = ec._ChannelOrg_modPolicy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mspID":

			out.Values[i] = ec._ChannelOrg_mspID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "policies":

			out.Values[i] = ec._ChannelOrg_policies(ctx, field, obj)

		case "msp":

			out.Values[i] = ec._ChannelOrg_msp(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ordererEndpoints":

			out.Values[i] = ec._ChannelOrg_ordererEndpoints(ctx, field, obj)

		case "anchorPeer":

			out.Values[i] = ec._ChannelOrg_anchorPeer(ctx, field, obj)

		case "nodeOUs":

			out.Values[i] = ec._ChannelOrg_nodeOUs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cryptoConfig":

			out.Values[i] = ec._ChannelOrg_cryptoConfig(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ous":

			out.Values[i] = ec._ChannelOrg_ous(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelPeerImplementors = []string{"ChannelPeer"}

func (ec *executionContext) _ChannelPeer(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelPeer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelPeerImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelPeer")
		case "mspID":

			out.Values[i] = ec._ChannelPeer_mspID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":

			out.Values[i] = ec._ChannelPeer_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "height":

			out.Values[i] = ec._ChannelPeer_height(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var channelPolicyImplementors = []string{"ChannelPolicy"}

func (ec *executionContext) _ChannelPolicy(ctx context.Context, sel ast.SelectionSet, obj *models.ChannelPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, channelPolicyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChannelPolicy")
		case "key":

			out.Values[i] = ec._ChannelPolicy_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec._ChannelPolicy_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rule":

			out.Values[i] = ec._ChannelPolicy_rule(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "modPolicy":

			out.Values[i] = ec._ChannelPolicy_modPolicy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cryptoConfigImplementors = []string{"CryptoConfig"}

func (ec *executionContext) _CryptoConfig(ctx context.Context, sel ast.SelectionSet, obj *models.CryptoConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cryptoConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CryptoConfig")
		case "signatureHashFamily":

			out.Values[i] = ec._CryptoConfig_signatureHashFamily(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "identityIdentifierHashFunction":

			out.Values[i] = ec._CryptoConfig_identityIdentifierHashFunction(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errorImplementors = []string{"Error"}

func (ec *executionContext) _Error(ctx context.Context, sel ast.SelectionSet, obj *models.Error) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errorImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Error")
		case "message":

			out.Values[i] = ec._Error_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var getUpdateChannelBlockResponseImplementors = []string{"GetUpdateChannelBlockResponse"}

func (ec *executionContext) _GetUpdateChannelBlockResponse(ctx context.Context, sel ast.SelectionSet, obj *models.GetUpdateChannelBlockResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getUpdateChannelBlockResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetUpdateChannelBlockResponse")
		case "errors":

			out.Values[i] = ec._GetUpdateChannelBlockResponse_errors(ctx, field, obj)

		case "block":

			out.Values[i] = ec._GetUpdateChannelBlockResponse_block(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "configUpdate":

			out.Values[i] = ec._GetUpdateChannelBlockResponse_configUpdate(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var lightChannelImplementors = []string{"LightChannel"}

func (ec *executionContext) _LightChannel(ctx context.Context, sel ast.SelectionSet, obj *models.LightChannel) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lightChannelImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LightChannel")
		case "name":

			out.Values[i] = ec._LightChannel_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mSPPrincipalImplementors = []string{"MSPPrincipal"}

func (ec *executionContext) _MSPPrincipal(ctx context.Context, sel ast.SelectionSet, obj *models.MSPPrincipal) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mSPPrincipalImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MSPPrincipal")
		case "combined":

			out.Values[i] = ec._MSPPrincipal_combined(ctx, field, obj)

		case "role":

			out.Values[i] = ec._MSPPrincipal_role(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mSPPrincipalCombinedImplementors = []string{"MSPPrincipalCombined"}

func (ec *executionContext) _MSPPrincipalCombined(ctx context.Context, sel ast.SelectionSet, obj *models.MSPPrincipalCombined) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mSPPrincipalCombinedImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MSPPrincipalCombined")
		case "classification":

			out.Values[i] = ec._MSPPrincipalCombined_classification(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mspPrincipals":

			out.Values[i] = ec._MSPPrincipalCombined_mspPrincipals(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mSPPrincipalRoleImplementors = []string{"MSPPrincipalRole"}

func (ec *executionContext) _MSPPrincipalRole(ctx context.Context, sel ast.SelectionSet, obj *models.MSPPrincipalRole) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mSPPrincipalRoleImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MSPPrincipalRole")
		case "mspID":

			out.Values[i] = ec._MSPPrincipalRole_mspID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "role":

			out.Values[i] = ec._MSPPrincipalRole_role(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createPeer":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createPeer(ctx, field)
			})

		case "updatePeer":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updatePeer(ctx, field)
			})

		case "createOrderer":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createOrderer(ctx, field)
			})

		case "updateOrderer":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateOrderer(ctx, field)
			})

		case "createCA":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createCA(ctx, field)
			})

		case "updateCA":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateCA(ctx, field)
			})

		case "renewPeerCertificates":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_renewPeerCertificates(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "renewOrdererCertificates":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_renewOrdererCertificates(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateChannel":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateChannel(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "getUpdateChannelBlock":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_getUpdateChannelBlock(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var namespaceImplementors = []string{"Namespace"}

func (ec *executionContext) _Namespace(ctx context.Context, sel ast.SelectionSet, obj *models.Namespace) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, namespaceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Namespace")
		case "name":

			out.Values[i] = ec._Namespace_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var networkAddressImplementors = []string{"NetworkAddress"}

func (ec *executionContext) _NetworkAddress(ctx context.Context, sel ast.SelectionSet, obj *models.NetworkAddress) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, networkAddressImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NetworkAddress")
		case "host":

			out.Values[i] = ec._NetworkAddress_host(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "port":

			out.Values[i] = ec._NetworkAddress_port(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var nodeOUsImplementors = []string{"NodeOUs"}

func (ec *executionContext) _NodeOUs(ctx context.Context, sel ast.SelectionSet, obj *models.NodeOUs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nodeOUsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NodeOUs")
		case "enable":

			out.Values[i] = ec._NodeOUs_enable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clientOUIdentifier":

			out.Values[i] = ec._NodeOUs_clientOUIdentifier(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "peerOUIdentifier":

			out.Values[i] = ec._NodeOUs_peerOUIdentifier(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "adminOUIdentifier":

			out.Values[i] = ec._NodeOUs_adminOUIdentifier(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ordererOUIdentifier":

			out.Values[i] = ec._NodeOUs_ordererOUIdentifier(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var oUIdentifierImplementors = []string{"OUIdentifier"}

func (ec *executionContext) _OUIdentifier(ctx context.Context, sel ast.SelectionSet, obj *models.OUIdentifier) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oUIdentifierImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OUIdentifier")
		case "certificate":

			out.Values[i] = ec._OUIdentifier_certificate(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ouIdentifier":

			out.Values[i] = ec._OUIdentifier_ouIdentifier(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ordererImplementors = []string{"Orderer"}

func (ec *executionContext) _Orderer(ctx context.Context, sel ast.SelectionSet, obj *models.Orderer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ordererImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Orderer")
		case "name":

			out.Values[i] = ec._Orderer_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "namespace":

			out.Values[i] = ec._Orderer_namespace(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "yaml":

			out.Values[i] = ec._Orderer_yaml(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "storage":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Orderer_storage(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ordererConfigImplementors = []string{"OrdererConfig"}

func (ec *executionContext) _OrdererConfig(ctx context.Context, sel ast.SelectionSet, obj *models.OrdererConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ordererConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrdererConfig")
		case "type":

			out.Values[i] = ec._OrdererConfig_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "batchTimeout":

			out.Values[i] = ec._OrdererConfig_batchTimeout(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "batchSize":

			out.Values[i] = ec._OrdererConfig_batchSize(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maxChannels":

			out.Values[i] = ec._OrdererConfig_maxChannels(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "capabilities":

			out.Values[i] = ec._OrdererConfig_capabilities(ctx, field, obj)

		case "state":

			out.Values[i] = ec._OrdererConfig_state(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "policies":

			out.Values[i] = ec._OrdererConfig_policies(ctx, field, obj)

		case "etcdDraft":

			out.Values[i] = ec._OrdererConfig_etcdDraft(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "organizations":

			out.Values[i] = ec._OrdererConfig_organizations(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ordererConfigBatchSizeImplementors = []string{"OrdererConfigBatchSize"}

func (ec *executionContext) _OrdererConfigBatchSize(ctx context.Context, sel ast.SelectionSet, obj *models.OrdererConfigBatchSize) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ordererConfigBatchSizeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrdererConfigBatchSize")
		case "maxMessageCount":

			out.Values[i] = ec._OrdererConfigBatchSize_maxMessageCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "absoluteMaxBytes":

			out.Values[i] = ec._OrdererConfigBatchSize_absoluteMaxBytes(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "preferredMaxBytes":

			out.Values[i] = ec._OrdererConfigBatchSize_preferredMaxBytes(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ordererConfigRaftImplementors = []string{"OrdererConfigRaft"}

func (ec *executionContext) _OrdererConfigRaft(ctx context.Context, sel ast.SelectionSet, obj *models.OrdererConfigRaft) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ordererConfigRaftImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrdererConfigRaft")
		case "consenters":

			out.Values[i] = ec._OrdererConfigRaft_consenters(ctx, field, obj)

		case "options":

			out.Values[i] = ec._OrdererConfigRaft_options(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ordererConfigRaftConsenterImplementors = []string{"OrdererConfigRaftConsenter"}

func (ec *executionContext) _OrdererConfigRaftConsenter(ctx context.Context, sel ast.SelectionSet, obj *models.OrdererConfigRaftConsenter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ordererConfigRaftConsenterImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrdererConfigRaftConsenter")
		case "address":

			out.Values[i] = ec._OrdererConfigRaftConsenter_address(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clientTlsCert":

			out.Values[i] = ec._OrdererConfigRaftConsenter_clientTlsCert(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "serverTlsCert":

			out.Values[i] = ec._OrdererConfigRaftConsenter_serverTlsCert(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ordererConfigRaftOptionsImplementors = []string{"OrdererConfigRaftOptions"}

func (ec *executionContext) _OrdererConfigRaftOptions(ctx context.Context, sel ast.SelectionSet, obj *models.OrdererConfigRaftOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ordererConfigRaftOptionsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrdererConfigRaftOptions")
		case "tickInterval":

			out.Values[i] = ec._OrdererConfigRaftOptions_tickInterval(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "electionTick":

			out.Values[i] = ec._OrdererConfigRaftOptions_electionTick(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "heartbeatTick":

			out.Values[i] = ec._OrdererConfigRaftOptions_heartbeatTick(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maxInflightBlocks":

			out.Values[i] = ec._OrdererConfigRaftOptions_maxInflightBlocks(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "snapshotIntervalSize":

			out.Values[i] = ec._OrdererConfigRaftOptions_snapshotIntervalSize(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ordererStorageImplementors = []string{"OrdererStorage"}

func (ec *executionContext) _OrdererStorage(ctx context.Context, sel ast.SelectionSet, obj *models.OrdererStorage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ordererStorageImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrdererStorage")
		case "orderer":

			out.Values[i] = ec._OrdererStorage_orderer(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pDCReadImplementors = []string{"PDCRead"}

func (ec *executionContext) _PDCRead(ctx context.Context, sel ast.SelectionSet, obj *models.PDCRead) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pDCReadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PDCRead")
		case "collectionName":

			out.Values[i] = ec._PDCRead_collectionName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "key":

			out.Values[i] = ec._PDCRead_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "block":

			out.Values[i] = ec._PDCRead_block(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "txNum":

			out.Values[i] = ec._PDCRead_txNum(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pDCReadHashImplementors = []string{"PDCReadHash"}

func (ec *executionContext) _PDCReadHash(ctx context.Context, sel ast.SelectionSet, obj *models.PDCReadHash) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pDCReadHashImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PDCReadHash")
		case "pdcName":

			out.Values[i] = ec._PDCReadHash_pdcName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "keyHash":

			out.Values[i] = ec._PDCReadHash_keyHash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rwSetHash":

			out.Values[i] = ec._PDCReadHash_rwSetHash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":

			out.Values[i] = ec._PDCReadHash_version(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pDCReadVersionImplementors = []string{"PDCReadVersion"}

func (ec *executionContext) _PDCReadVersion(ctx context.Context, sel ast.SelectionSet, obj *models.PDCReadVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pDCReadVersionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PDCReadVersion")
		case "blockNum":

			out.Values[i] = ec._PDCReadVersion_blockNum(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "txNum":

			out.Values[i] = ec._PDCReadVersion_txNum(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pDCWriteImplementors = []string{"PDCWrite"}

func (ec *executionContext) _PDCWrite(ctx context.Context, sel ast.SelectionSet, obj *models.PDCWrite) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pDCWriteImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PDCWrite")
		case "collectionName":

			out.Values[i] = ec._PDCWrite_collectionName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleted":

			out.Values[i] = ec._PDCWrite_deleted(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "key":

			out.Values[i] = ec._PDCWrite_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._PDCWrite_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pDCWriteHashImplementors = []string{"PDCWriteHash"}

func (ec *executionContext) _PDCWriteHash(ctx context.Context, sel ast.SelectionSet, obj *models.PDCWriteHash) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pDCWriteHashImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PDCWriteHash")
		case "pdcName":

			out.Values[i] = ec._PDCWriteHash_pdcName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "keyHash":

			out.Values[i] = ec._PDCWriteHash_keyHash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rwSetHash":

			out.Values[i] = ec._PDCWriteHash_rwSetHash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "valueHash":

			out.Values[i] = ec._PDCWriteHash_valueHash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDelete":

			out.Values[i] = ec._PDCWriteHash_isDelete(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isPurge":

			out.Values[i] = ec._PDCWriteHash_isPurge(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var peerImplementors = []string{"Peer"}

func (ec *executionContext) _Peer(ctx context.Context, sel ast.SelectionSet, obj *models.Peer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, peerImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Peer")
		case "name":

			out.Values[i] = ec._Peer_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "namespace":

			out.Values[i] = ec._Peer_namespace(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "yaml":

			out.Values[i] = ec._Peer_yaml(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "storage":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Peer_storage(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var peerStorageImplementors = []string{"PeerStorage"}

func (ec *executionContext) _PeerStorage(ctx context.Context, sel ast.SelectionSet, obj *models.PeerStorage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, peerStorageImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PeerStorage")
		case "chaincode":

			out.Values[i] = ec._PeerStorage_chaincode(ctx, field, obj)

		case "couchDB":

			out.Values[i] = ec._PeerStorage_couchDB(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "peer":

			out.Values[i] = ec._PeerStorage_peer(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var privateDataCollectionImplementors = []string{"PrivateDataCollection"}

func (ec *executionContext) _PrivateDataCollection(ctx context.Context, sel ast.SelectionSet, obj *models.PrivateDataCollection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, privateDataCollectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PrivateDataCollection")
		case "name":

			out.Values[i] = ec._PrivateDataCollection_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "requiredPeerCount":

			out.Values[i] = ec._PrivateDataCollection_requiredPeerCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maxPeerCount":

			out.Values[i] = ec._PrivateDataCollection_maxPeerCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "blockToLive":

			out.Values[i] = ec._PrivateDataCollection_blockToLive(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "memberOnlyRead":

			out.Values[i] = ec._PrivateDataCollection_memberOnlyRead(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "memberOnlyWrite":

			out.Values[i] = ec._PrivateDataCollection_memberOnlyWrite(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "endorsementPolicy":

			out.Values[i] = ec._PrivateDataCollection_endorsementPolicy(ctx, field, obj)

		case "memberOrgsPolicy":

			out.Values[i] = ec._PrivateDataCollection_memberOrgsPolicy(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "peers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_peers(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "peer":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_peer(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "orderers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_orderers(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "orderer":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_orderer(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "networkConfigEnabled":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_networkConfigEnabled(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cas":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cas(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "ca":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ca(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "namespaces":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_namespaces(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "storageClasses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_storageClasses(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "channels":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_channels(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "channel":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_channel(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "blocks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_blocks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "block":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_block(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "blockWithPrivateData":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_blockWithPrivateData(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "blockByTXID":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_blockByTXID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var renewOrdererCertificatesResponseImplementors = []string{"RenewOrdererCertificatesResponse"}

func (ec *executionContext) _RenewOrdererCertificatesResponse(ctx context.Context, sel ast.SelectionSet, obj *models.RenewOrdererCertificatesResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, renewOrdererCertificatesResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RenewOrdererCertificatesResponse")
		case "orderer":

			out.Values[i] = ec._RenewOrdererCertificatesResponse_orderer(ctx, field, obj)

		case "errors":

			out.Values[i] = ec._RenewOrdererCertificatesResponse_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var renewPeerCertificatesResponseImplementors = []string{"RenewPeerCertificatesResponse"}

func (ec *executionContext) _RenewPeerCertificatesResponse(ctx context.Context, sel ast.SelectionSet, obj *models.RenewPeerCertificatesResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, renewPeerCertificatesResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RenewPeerCertificatesResponse")
		case "peer":

			out.Values[i] = ec._RenewPeerCertificatesResponse_peer(ctx, field, obj)

		case "errors":

			out.Values[i] = ec._RenewPeerCertificatesResponse_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var signaturePolicyImplementors = []string{"SignaturePolicy"}

func (ec *executionContext) _SignaturePolicy(ctx context.Context, sel ast.SelectionSet, obj *models.SignaturePolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, signaturePolicyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SignaturePolicy")
		case "version":

			out.Values[i] = ec._SignaturePolicy_version(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rule":

			out.Values[i] = ec._SignaturePolicy_rule(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "principals":

			out.Values[i] = ec._SignaturePolicy_principals(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var signaturePolicyNOutOfImplementors = []string{"SignaturePolicyNOutOf"}

func (ec *executionContext) _SignaturePolicyNOutOf(ctx context.Context, sel ast.SelectionSet, obj *models.SignaturePolicyNOutOf) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, signaturePolicyNOutOfImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SignaturePolicyNOutOf")
		case "n":

			out.Values[i] = ec._SignaturePolicyNOutOf_n(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rules":

			out.Values[i] = ec._SignaturePolicyNOutOf_rules(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var signaturePolicyRuleImplementors = []string{"SignaturePolicyRule"}

func (ec *executionContext) _SignaturePolicyRule(ctx context.Context, sel ast.SelectionSet, obj *models.SignaturePolicyRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, signaturePolicyRuleImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SignaturePolicyRule")
		case "type":

			out.Values[i] = ec._SignaturePolicyRule_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "noutOf":

			out.Values[i] = ec._SignaturePolicyRule_noutOf(ctx, field, obj)

		case "signedBy":

			out.Values[i] = ec._SignaturePolicyRule_signedBy(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var signaturePolicySignedByImplementors = []string{"SignaturePolicySignedBy"}

func (ec *executionContext) _SignaturePolicySignedBy(ctx context.Context, sel ast.SelectionSet, obj *models.SignaturePolicySignedBy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, signaturePolicySignedByImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SignaturePolicySignedBy")
		case "signedBy":

			out.Values[i] = ec._SignaturePolicySignedBy_signedBy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var storageClassImplementors = []string{"StorageClass"}

func (ec *executionContext) _StorageClass(ctx context.Context, sel ast.SelectionSet, obj *models.StorageClass) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, storageClassImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StorageClass")
		case "name":

			out.Values[i] = ec._StorageClass_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var storageUsageImplementors = []string{"StorageUsage"}

func (ec *executionContext) _StorageUsage(ctx context.Context, sel ast.SelectionSet, obj *models.StorageUsage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, storageUsageImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StorageUsage")
		case "used":

			out.Values[i] = ec._StorageUsage_used(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "usedGB":

			out.Values[i] = ec._StorageUsage_usedGB(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "free":

			out.Values[i] = ec._StorageUsage_free(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "freeGB":

			out.Values[i] = ec._StorageUsage_freeGB(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "size":

			out.Values[i] = ec._StorageUsage_size(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sizeGB":

			out.Values[i] = ec._StorageUsage_sizeGB(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "percentageUsed":

			out.Values[i] = ec._StorageUsage_percentageUsed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionImplementors = []string{"Transaction"}

func (ec *executionContext) _Transaction(ctx context.Context, sel ast.SelectionSet, obj *models.Transaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transaction")
		case "txID":

			out.Values[i] = ec._Transaction_txID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec._Transaction_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":

			out.Values[i] = ec._Transaction_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":

			out.Values[i] = ec._Transaction_version(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "path":

			out.Values[i] = ec._Transaction_path(ctx, field, obj)

		case "response":

			out.Values[i] = ec._Transaction_response(ctx, field, obj)

		case "request":

			out.Values[i] = ec._Transaction_request(ctx, field, obj)

		case "chaincode":

			out.Values[i] = ec._Transaction_chaincode(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "writes":

			out.Values[i] = ec._Transaction_writes(ctx, field, obj)

		case "reads":

			out.Values[i] = ec._Transaction_reads(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionReadImplementors = []string{"TransactionRead"}

func (ec *executionContext) _TransactionRead(ctx context.Context, sel ast.SelectionSet, obj *models.TransactionRead) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionReadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionRead")
		case "chaincodeID":

			out.Values[i] = ec._TransactionRead_chaincodeID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "key":

			out.Values[i] = ec._TransactionRead_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "blockNumVersion":

			out.Values[i] = ec._TransactionRead_blockNumVersion(ctx, field, obj)

		case "txNumVersion":

			out.Values[i] = ec._TransactionRead_txNumVersion(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionWithPrivateDataImplementors = []string{"TransactionWithPrivateData"}

func (ec *executionContext) _TransactionWithPrivateData(ctx context.Context, sel ast.SelectionSet, obj *models.TransactionWithPrivateData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionWithPrivateDataImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionWithPrivateData")
		case "txID":

			out.Values[i] = ec._TransactionWithPrivateData_txID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec._TransactionWithPrivateData_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":

			out.Values[i] = ec._TransactionWithPrivateData_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":

			out.Values[i] = ec._TransactionWithPrivateData_version(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "path":

			out.Values[i] = ec._TransactionWithPrivateData_path(ctx, field, obj)

		case "response":

			out.Values[i] = ec._TransactionWithPrivateData_response(ctx, field, obj)

		case "request":

			out.Values[i] = ec._TransactionWithPrivateData_request(ctx, field, obj)

		case "chaincode":

			out.Values[i] = ec._TransactionWithPrivateData_chaincode(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "writes":

			out.Values[i] = ec._TransactionWithPrivateData_writes(ctx, field, obj)

		case "reads":

			out.Values[i] = ec._TransactionWithPrivateData_reads(ctx, field, obj)

		case "pdcWrites":

			out.Values[i] = ec._TransactionWithPrivateData_pdcWrites(ctx, field, obj)

		case "pdcReads":

			out.Values[i] = ec._TransactionWithPrivateData_pdcReads(ctx, field, obj)

		case "pdcWriteHashes":

			out.Values[i] = ec._TransactionWithPrivateData_pdcWriteHashes(ctx, field, obj)

		case "pdcReadHashes":

			out.Values[i] = ec._TransactionWithPrivateData_pdcReadHashes(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionWriteImplementors = []string{"TransactionWrite"}

func (ec *executionContext) _TransactionWrite(ctx context.Context, sel ast.SelectionSet, obj *models.TransactionWrite) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionWriteImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionWrite")
		case "chaincodeID":

			out.Values[i] = ec._TransactionWrite_chaincodeID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleted":

			out.Values[i] = ec._TransactionWrite_deleted(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "key":

			out.Values[i] = ec._TransactionWrite_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._TransactionWrite_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateChannelResponseImplementors = []string{"UpdateChannelResponse"}

func (ec *executionContext) _UpdateChannelResponse(ctx context.Context, sel ast.SelectionSet, obj *models.UpdateChannelResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateChannelResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateChannelResponse")
		case "errors":

			out.Values[i] = ec._UpdateChannelResponse_errors(ctx, field, obj)

		case "transactionID":

			out.Values[i] = ec._UpdateChannelResponse_transactionID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNApplicationConfigInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsApplicationConfigInput(ctx context.Context, v interface{}) (*models.ApplicationConfigInput, error) {
	res, err := ec.unmarshalInputApplicationConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBlock2githubcomkfsoftwarehlfoperatoruiapigqlmodelsBlock(ctx context.Context, sel ast.SelectionSet, v models.Block) graphql.Marshaler {
	return ec._Block(ctx, sel, &v)
}

func (ec *executionContext) marshalNBlock2githubcomkfsoftwarehlfoperatoruiapigqlmodelsBlock(ctx context.Context, sel ast.SelectionSet, v *models.Block) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Block(ctx, sel, v)
}

func (ec *executionContext) marshalNBlockWithPrivateData2githubcomkfsoftwarehlfoperatoruiapigqlmodelsBlockWithPrivateData(ctx context.Context, sel ast.SelectionSet, v models.BlockWithPrivateData) graphql.Marshaler {
	return ec._BlockWithPrivateData(ctx, sel, &v)
}

func (ec *executionContext) marshalNBlockWithPrivateData2githubcomkfsoftwarehlfoperatoruiapigqlmodelsBlockWithPrivateData(ctx context.Context, sel ast.SelectionSet, v *models.BlockWithPrivateData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BlockWithPrivateData(ctx, sel, v)
}

func (ec *executionContext) marshalNBlocksResponse2githubcomkfsoftwarehlfoperatoruiapigqlmodelsBlocksResponse(ctx context.Context, sel ast.SelectionSet, v models.BlocksResponse) graphql.Marshaler {
	return ec._BlocksResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNBlocksResponse2githubcomkfsoftwarehlfoperatoruiapigqlmodelsBlocksResponse(ctx context.Context, sel ast.SelectionSet, v *models.BlocksResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BlocksResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCA2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCa(ctx context.Context, sel ast.SelectionSet, v *models.Ca) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CA(ctx, sel, v)
}

func (ec *executionContext) marshalNChaincodeApproval2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChaincodeApproval(ctx context.Context, sel ast.SelectionSet, v *models.ChaincodeApproval) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChaincodeApproval(ctx, sel, v)
}

func (ec *executionContext) marshalNChannel2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannel(ctx context.Context, sel ast.SelectionSet, v models.Channel) graphql.Marshaler {
	return ec._Channel(ctx, sel, &v)
}

func (ec *executionContext) marshalNChannel2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannel(ctx context.Context, sel ast.SelectionSet, v *models.Channel) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Channel(ctx, sel, v)
}

func (ec *executionContext) marshalNChannelACL2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelACL(ctx context.Context, sel ast.SelectionSet, v *models.ChannelACL) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelACL(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChannelACLInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelACLInput(ctx context.Context, v interface{}) (*models.ChannelACLInput, error) {
	res, err := ec.unmarshalInputChannelACLInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChannelChaincode2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelChaincode(ctx context.Context, sel ast.SelectionSet, v *models.ChannelChaincode) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelChaincode(ctx, sel, v)
}

func (ec *executionContext) marshalNChannelConfig2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelConfig(ctx context.Context, sel ast.SelectionSet, v *models.ChannelConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChannelConfigInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelConfigInput(ctx context.Context, v interface{}) (*models.ChannelConfigInput, error) {
	res, err := ec.unmarshalInputChannelConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChannelMSP2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelMsp(ctx context.Context, sel ast.SelectionSet, v *models.ChannelMsp) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelMSP(ctx, sel, v)
}

func (ec *executionContext) marshalNChannelOrg2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelOrg(ctx context.Context, sel ast.SelectionSet, v *models.ChannelOrg) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelOrg(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChannelOrganization2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelOrganization(ctx context.Context, v interface{}) (*models.ChannelOrganization, error) {
	res, err := ec.unmarshalInputChannelOrganization(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChannelPeer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelPeer(ctx context.Context, sel ast.SelectionSet, v *models.ChannelPeer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelPeer(ctx, sel, v)
}

func (ec *executionContext) marshalNChannelPolicy2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelPolicy(ctx context.Context, sel ast.SelectionSet, v *models.ChannelPolicy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChannelPolicy(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateCAInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCreateCAInput(ctx context.Context, v interface{}) (models.CreateCAInput, error) {
	res, err := ec.unmarshalInputCreateCAInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateOrdererInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCreateOrdererInput(ctx context.Context, v interface{}) (models.CreateOrdererInput, error) {
	res, err := ec.unmarshalInputCreateOrdererInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreatePeerInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCreatePeerInput(ctx context.Context, v interface{}) (models.CreatePeerInput, error) {
	res, err := ec.unmarshalInputCreatePeerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCryptoConfig2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCryptoConfig(ctx context.Context, sel ast.SelectionSet, v *models.CryptoConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CryptoConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCryptoConfigInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCryptoConfigInput(ctx context.Context, v interface{}) (*models.CryptoConfigInput, error) {
	res, err := ec.unmarshalInputCryptoConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNError2githubcomkfsoftwarehlfoperatoruiapigqlmodelsError(ctx context.Context, sel ast.SelectionSet, v *models.Error) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Error(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalNGetUpdateChannelBlockInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsGetUpdateChannelBlockInput(ctx context.Context, v interface{}) (models.GetUpdateChannelBlockInput, error) {
	res, err := ec.unmarshalInputGetUpdateChannelBlockInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGetUpdateChannelBlockResponse2githubcomkfsoftwarehlfoperatoruiapigqlmodelsGetUpdateChannelBlockResponse(ctx context.Context, sel ast.SelectionSet, v models.GetUpdateChannelBlockResponse) graphql.Marshaler {
	return ec._GetUpdateChannelBlockResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetUpdateChannelBlockResponse2githubcomkfsoftwarehlfoperatoruiapigqlmodelsGetUpdateChannelBlockResponse(ctx context.Context, sel ast.SelectionSet, v *models.GetUpdateChannelBlockResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetUpdateChannelBlockResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNLightChannel2githubcomkfsoftwarehlfoperatoruiapigqlmodelsLightChannel(ctx context.Context, sel ast.SelectionSet, v *models.LightChannel) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LightChannel(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMSPInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsMSPInput(ctx context.Context, v interface{}) (*models.MSPInput, error) {
	res, err := ec.unmarshalInputMSPInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMSPPrincipal2githubcomkfsoftwarehlfoperatoruiapigqlmodelsMSPPrincipal(ctx context.Context, sel ast.SelectionSet, v *models.MSPPrincipal) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MSPPrincipal(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMSPSignature2githubcomkfsoftwarehlfoperatoruiapigqlmodelsMSPSignature(ctx context.Context, v interface{}) (*models.MSPSignature, error) {
	res, err := ec.unmarshalInputMSPSignature(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNameAndNamespace2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNameAndNamespace(ctx context.Context, v interface{}) (models.NameAndNamespace, error) {
	res, err := ec.unmarshalInputNameAndNamespace(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNamespace2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNamespace(ctx context.Context, sel ast.SelectionSet, v *models.Namespace) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Namespace(ctx, sel, v)
}

func (ec *executionContext) marshalNNetworkAddress2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNetworkAddress(ctx context.Context, sel ast.SelectionSet, v *models.NetworkAddress) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NetworkAddress(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNetworkAddressInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNetworkAddressInput(ctx context.Context, v interface{}) (*models.NetworkAddressInput, error) {
	res, err := ec.unmarshalInputNetworkAddressInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNodeOUs2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNodeOUs(ctx context.Context, sel ast.SelectionSet, v *models.NodeOUs) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NodeOUs(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNodeOUsInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNodeOUsInput(ctx context.Context, v interface{}) (*models.NodeOUsInput, error) {
	res, err := ec.unmarshalInputNodeOUsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOUIdentifier2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOUIdentifier(ctx context.Context, sel ast.SelectionSet, v *models.OUIdentifier) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OUIdentifier(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOUIdentifierInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOUIdentifierInput(ctx context.Context, v interface{}) (*models.OUIdentifierInput, error) {
	res, err := ec.unmarshalInputOUIdentifierInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrderer(ctx context.Context, sel ast.SelectionSet, v *models.Orderer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Orderer(ctx, sel, v)
}

func (ec *executionContext) marshalNOrdererConfig2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfig(ctx context.Context, sel ast.SelectionSet, v *models.OrdererConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrdererConfig(ctx, sel, v)
}

func (ec *executionContext) marshalNOrdererConfigBatchSize2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigBatchSize(ctx context.Context, sel ast.SelectionSet, v *models.OrdererConfigBatchSize) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrdererConfigBatchSize(ctx, sel, v)
}

func (ec *executionContext) marshalNOrdererConfigRaft2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigRaft(ctx context.Context, sel ast.SelectionSet, v *models.OrdererConfigRaft) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrdererConfigRaft(ctx, sel, v)
}

func (ec *executionContext) marshalNOrdererConfigRaftConsenter2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigRaftConsenter(ctx context.Context, sel ast.SelectionSet, v *models.OrdererConfigRaftConsenter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrdererConfigRaftConsenter(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOrdererConfigRaftConsenterInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigRaftConsenterInput(ctx context.Context, v interface{}) (*models.OrdererConfigRaftConsenterInput, error) {
	res, err := ec.unmarshalInputOrdererConfigRaftConsenterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrdererConfigRaftOptions2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigRaftOptions(ctx context.Context, sel ast.SelectionSet, v *models.OrdererConfigRaftOptions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrdererConfigRaftOptions(ctx, sel, v)
}

func (ec *executionContext) marshalNPDCRead2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCRead(ctx context.Context, sel ast.SelectionSet, v *models.PDCRead) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PDCRead(ctx, sel, v)
}

func (ec *executionContext) marshalNPDCReadHash2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCReadHash(ctx context.Context, sel ast.SelectionSet, v *models.PDCReadHash) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PDCReadHash(ctx, sel, v)
}

func (ec *executionContext) marshalNPDCWrite2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCWrite(ctx context.Context, sel ast.SelectionSet, v *models.PDCWrite) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PDCWrite(ctx, sel, v)
}

func (ec *executionContext) marshalNPDCWriteHash2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCWriteHash(ctx context.Context, sel ast.SelectionSet, v *models.PDCWriteHash) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PDCWriteHash(ctx, sel, v)
}

func (ec *executionContext) marshalNPeer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPeer(ctx context.Context, sel ast.SelectionSet, v *models.Peer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Peer(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPolicyInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPolicyInput(ctx context.Context, v interface{}) (*models.PolicyInput, error) {
	res, err := ec.unmarshalInputPolicyInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPrivateDataCollection2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPrivateDataCollection(ctx context.Context, sel ast.SelectionSet, v *models.PrivateDataCollection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PrivateDataCollection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRawSignature2githubcomkfsoftwarehlfoperatoruiapigqlmodelsRawSignature(ctx context.Context, v interface{}) (*models.RawSignature, error) {
	res, err := ec.unmarshalInputRawSignature(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRenewOrdererCertificatesInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsRenewOrdererCertificatesInput(ctx context.Context, v interface{}) (models.RenewOrdererCertificatesInput, error) {
	res, err := ec.unmarshalInputRenewOrdererCertificatesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRenewOrdererCertificatesResponse2githubcomkfsoftwarehlfoperatoruiapigqlmodelsRenewOrdererCertificatesResponse(ctx context.Context, sel ast.SelectionSet, v models.RenewOrdererCertificatesResponse) graphql.Marshaler {
	return ec._RenewOrdererCertificatesResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRenewOrdererCertificatesResponse2githubcomkfsoftwarehlfoperatoruiapigqlmodelsRenewOrdererCertificatesResponse(ctx context.Context, sel ast.SelectionSet, v *models.RenewOrdererCertificatesResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RenewOrdererCertificatesResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRenewPeerCertificatesInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsRenewPeerCertificatesInput(ctx context.Context, v interface{}) (models.RenewPeerCertificatesInput, error) {
	res, err := ec.unmarshalInputRenewPeerCertificatesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRenewPeerCertificatesResponse2githubcomkfsoftwarehlfoperatoruiapigqlmodelsRenewPeerCertificatesResponse(ctx context.Context, sel ast.SelectionSet, v models.RenewPeerCertificatesResponse) graphql.Marshaler {
	return ec._RenewPeerCertificatesResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRenewPeerCertificatesResponse2githubcomkfsoftwarehlfoperatoruiapigqlmodelsRenewPeerCertificatesResponse(ctx context.Context, sel ast.SelectionSet, v *models.RenewPeerCertificatesResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RenewPeerCertificatesResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNSignaturePolicy2githubcomkfsoftwarehlfoperatoruiapigqlmodelsSignaturePolicy(ctx context.Context, sel ast.SelectionSet, v *models.SignaturePolicy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SignaturePolicy(ctx, sel, v)
}

func (ec *executionContext) marshalNSignaturePolicyRule2githubcomkfsoftwarehlfoperatoruiapigqlmodelsSignaturePolicyRule(ctx context.Context, sel ast.SelectionSet, v *models.SignaturePolicyRule) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SignaturePolicyRule(ctx, sel, v)
}

func (ec *executionContext) marshalNStorageClass2githubcomkfsoftwarehlfoperatoruiapigqlmodelsStorageClass(ctx context.Context, sel ast.SelectionSet, v *models.StorageClass) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StorageClass(ctx, sel, v)
}

func (ec *executionContext) marshalNStorageUsage2githubcomkfsoftwarehlfoperatoruiapigqlmodelsStorageUsage(ctx context.Context, sel ast.SelectionSet, v *models.StorageUsage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StorageUsage(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTransaction2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransaction(ctx context.Context, sel ast.SelectionSet, v *models.Transaction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Transaction(ctx, sel, v)
}

func (ec *executionContext) marshalNTransactionRead2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionRead(ctx context.Context, sel ast.SelectionSet, v *models.TransactionRead) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionRead(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTransactionType2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionType(ctx context.Context, v interface{}) (models.TransactionType, error) {
	var res models.TransactionType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTransactionType2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionType(ctx context.Context, sel ast.SelectionSet, v models.TransactionType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTransactionWithPrivateData2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionWithPrivateData(ctx context.Context, sel ast.SelectionSet, v *models.TransactionWithPrivateData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionWithPrivateData(ctx, sel, v)
}

func (ec *executionContext) marshalNTransactionWrite2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionWrite(ctx context.Context, sel ast.SelectionSet, v *models.TransactionWrite) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionWrite(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateCAInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsUpdateCAInput(ctx context.Context, v interface{}) (models.UpdateCAInput, error) {
	res, err := ec.unmarshalInputUpdateCAInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateChannelInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsUpdateChannelInput(ctx context.Context, v interface{}) (models.UpdateChannelInput, error) {
	res, err := ec.unmarshalInputUpdateChannelInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateChannelResponse2githubcomkfsoftwarehlfoperatoruiapigqlmodelsUpdateChannelResponse(ctx context.Context, sel ast.SelectionSet, v models.UpdateChannelResponse) graphql.Marshaler {
	return ec._UpdateChannelResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateChannelResponse2githubcomkfsoftwarehlfoperatoruiapigqlmodelsUpdateChannelResponse(ctx context.Context, sel ast.SelectionSet, v *models.UpdateChannelResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateChannelResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateeOrdererInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsUpdateeOrdererInput(ctx context.Context, v interface{}) (models.UpdateeOrdererInput, error) {
	res, err := ec.unmarshalInputUpdateeOrdererInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateePeerInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsUpdateePeerInput(ctx context.Context, v interface{}) (models.UpdateePeerInput, error) {
	res, err := ec.unmarshalInputUpdateePeerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOApplicationConfig2githubcomkfsoftwarehlfoperatoruiapigqlmodelsApplicationConfig(ctx context.Context, sel ast.SelectionSet, v *models.ApplicationConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOApplicationPolicy2githubcomkfsoftwarehlfoperatoruiapigqlmodelsApplicationPolicy(ctx context.Context, sel ast.SelectionSet, v *models.ApplicationPolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationPolicy(ctx, sel, v)
}

func (ec *executionContext) marshalOBlock2githubcomkfsoftwarehlfoperatoruiapigqlmodelsBlock(ctx context.Context, sel ast.SelectionSet, v []*models.Block) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBlock2githubcomkfsoftwarehlfoperatoruiapigqlmodelsBlock(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOCA2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCa(ctx context.Context, sel ast.SelectionSet, v []*models.Ca) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCA2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCa(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCA2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCa(ctx context.Context, sel ast.SelectionSet, v *models.Ca) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CA(ctx, sel, v)
}

func (ec *executionContext) marshalOCAStorage2githubcomkfsoftwarehlfoperatoruiapigqlmodelsCAStorage(ctx context.Context, sel ast.SelectionSet, v *models.CAStorage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CAStorage(ctx, sel, v)
}

func (ec *executionContext) marshalOChaincodeApproval2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChaincodeApproval(ctx context.Context, sel ast.SelectionSet, v []*models.ChaincodeApproval) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChaincodeApproval2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChaincodeApproval(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOChannelACL2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelACL(ctx context.Context, sel ast.SelectionSet, v []*models.ChannelACL) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChannelACL2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelACL(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOChannelACLInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelACLInput(ctx context.Context, v interface{}) ([]*models.ChannelACLInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.ChannelACLInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNChannelACLInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelACLInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOChannelChaincode2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelChaincode(ctx context.Context, sel ast.SelectionSet, v []*models.ChannelChaincode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChannelChaincode2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelChaincode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOChannelOrg2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelOrg(ctx context.Context, sel ast.SelectionSet, v []*models.ChannelOrg) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChannelOrg2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelOrg(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOChannelOrganization2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelOrganization(ctx context.Context, v interface{}) ([]*models.ChannelOrganization, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.ChannelOrganization, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOChannelOrganization2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelOrganization(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOChannelOrganization2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelOrganization(ctx context.Context, v interface{}) ([]*models.ChannelOrganization, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.ChannelOrganization, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNChannelOrganization2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelOrganization(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOChannelOrganization2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelOrganization(ctx context.Context, v interface{}) (*models.ChannelOrganization, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputChannelOrganization(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOChannelPeer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelPeer(ctx context.Context, sel ast.SelectionSet, v []*models.ChannelPeer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChannelPeer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelPeer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOChannelPolicy2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelPolicy(ctx context.Context, sel ast.SelectionSet, v []*models.ChannelPolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChannelPolicy2githubcomkfsoftwarehlfoperatoruiapigqlmodelsChannelPolicy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOError2githubcomkfsoftwarehlfoperatoruiapigqlmodelsError(ctx context.Context, sel ast.SelectionSet, v []*models.Error) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNError2githubcomkfsoftwarehlfoperatoruiapigqlmodelsError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOEtcdRaftInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsEtcdRaftInput(ctx context.Context, v interface{}) (*models.EtcdRaftInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEtcdRaftInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOLightChannel2githubcomkfsoftwarehlfoperatoruiapigqlmodelsLightChannel(ctx context.Context, sel ast.SelectionSet, v []*models.LightChannel) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLightChannel2githubcomkfsoftwarehlfoperatoruiapigqlmodelsLightChannel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOMSPPrincipal2githubcomkfsoftwarehlfoperatoruiapigqlmodelsMSPPrincipal(ctx context.Context, sel ast.SelectionSet, v []*models.MSPPrincipal) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMSPPrincipal2githubcomkfsoftwarehlfoperatoruiapigqlmodelsMSPPrincipal(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOMSPPrincipalCombined2githubcomkfsoftwarehlfoperatoruiapigqlmodelsMSPPrincipalCombined(ctx context.Context, sel ast.SelectionSet, v *models.MSPPrincipalCombined) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MSPPrincipalCombined(ctx, sel, v)
}

func (ec *executionContext) marshalOMSPPrincipalRole2githubcomkfsoftwarehlfoperatoruiapigqlmodelsMSPPrincipalRole(ctx context.Context, sel ast.SelectionSet, v *models.MSPPrincipalRole) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MSPPrincipalRole(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMSPSignature2githubcomkfsoftwarehlfoperatoruiapigqlmodelsMSPSignature(ctx context.Context, v interface{}) ([]*models.MSPSignature, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.MSPSignature, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMSPSignature2githubcomkfsoftwarehlfoperatoruiapigqlmodelsMSPSignature(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalONamespace2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNamespace(ctx context.Context, sel ast.SelectionSet, v []*models.Namespace) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNamespace2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNamespace(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalONetworkAddress2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNetworkAddress(ctx context.Context, sel ast.SelectionSet, v []*models.NetworkAddress) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNetworkAddress2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNetworkAddress(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalONetworkAddressInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNetworkAddressInput(ctx context.Context, v interface{}) ([]*models.NetworkAddressInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.NetworkAddressInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNNetworkAddressInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsNetworkAddressInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOOUIdentifier2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOUIdentifier(ctx context.Context, sel ast.SelectionSet, v []*models.OUIdentifier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOUIdentifier2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOUIdentifier(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOOUIdentifierInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOUIdentifierInput(ctx context.Context, v interface{}) ([]*models.OUIdentifierInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.OUIdentifierInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNOUIdentifierInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOUIdentifierInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOOrderer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrderer(ctx context.Context, sel ast.SelectionSet, v []*models.Orderer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOrderer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrderer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOOrderer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrderer(ctx context.Context, sel ast.SelectionSet, v *models.Orderer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Orderer(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOrdererConfigBatchSizeInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigBatchSizeInput(ctx context.Context, v interface{}) (*models.OrdererConfigBatchSizeInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOrdererConfigBatchSizeInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOOrdererConfigInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigInput(ctx context.Context, v interface{}) (*models.OrdererConfigInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOrdererConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrdererConfigRaftConsenter2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigRaftConsenter(ctx context.Context, sel ast.SelectionSet, v []*models.OrdererConfigRaftConsenter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOrdererConfigRaftConsenter2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigRaftConsenter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOOrdererConfigRaftConsenterInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigRaftConsenterInput(ctx context.Context, v interface{}) ([]*models.OrdererConfigRaftConsenterInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.OrdererConfigRaftConsenterInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNOrdererConfigRaftConsenterInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigRaftConsenterInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOOrdererConfigRaftOptionsInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererConfigRaftOptionsInput(ctx context.Context, v interface{}) (*models.OrdererConfigRaftOptionsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOrdererConfigRaftOptionsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrdererStorage2githubcomkfsoftwarehlfoperatoruiapigqlmodelsOrdererStorage(ctx context.Context, sel ast.SelectionSet, v *models.OrdererStorage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OrdererStorage(ctx, sel, v)
}

func (ec *executionContext) marshalOPDCRead2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCRead(ctx context.Context, sel ast.SelectionSet, v []*models.PDCRead) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPDCRead2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCRead(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPDCReadHash2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCReadHash(ctx context.Context, sel ast.SelectionSet, v []*models.PDCReadHash) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPDCReadHash2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCReadHash(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPDCReadVersion2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCReadVersion(ctx context.Context, sel ast.SelectionSet, v *models.PDCReadVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PDCReadVersion(ctx, sel, v)
}

func (ec *executionContext) marshalOPDCWrite2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCWrite(ctx context.Context, sel ast.SelectionSet, v []*models.PDCWrite) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPDCWrite2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCWrite(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPDCWriteHash2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCWriteHash(ctx context.Context, sel ast.SelectionSet, v []*models.PDCWriteHash) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPDCWriteHash2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPDCWriteHash(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPeer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPeer(ctx context.Context, sel ast.SelectionSet, v []*models.Peer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPeer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPeer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPeer2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPeer(ctx context.Context, sel ast.SelectionSet, v *models.Peer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Peer(ctx, sel, v)
}

func (ec *executionContext) marshalOPeerStorage2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPeerStorage(ctx context.Context, sel ast.SelectionSet, v *models.PeerStorage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PeerStorage(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPolicyInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPolicyInput(ctx context.Context, v interface{}) ([]*models.PolicyInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.PolicyInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPolicyInput2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPolicyInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPrivateDataCollection2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPrivateDataCollection(ctx context.Context, sel ast.SelectionSet, v []*models.PrivateDataCollection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPrivateDataCollection2githubcomkfsoftwarehlfoperatoruiapigqlmodelsPrivateDataCollection(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalORawSignature2githubcomkfsoftwarehlfoperatoruiapigqlmodelsRawSignature(ctx context.Context, v interface{}) ([]*models.RawSignature, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models.RawSignature, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRawSignature2githubcomkfsoftwarehlfoperatoruiapigqlmodelsRawSignature(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOSignaturePolicy2githubcomkfsoftwarehlfoperatoruiapigqlmodelsSignaturePolicy(ctx context.Context, sel ast.SelectionSet, v *models.SignaturePolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SignaturePolicy(ctx, sel, v)
}

func (ec *executionContext) marshalOSignaturePolicyNOutOf2githubcomkfsoftwarehlfoperatoruiapigqlmodelsSignaturePolicyNOutOf(ctx context.Context, sel ast.SelectionSet, v *models.SignaturePolicyNOutOf) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SignaturePolicyNOutOf(ctx, sel, v)
}

func (ec *executionContext) marshalOSignaturePolicyRule2githubcomkfsoftwarehlfoperatoruiapigqlmodelsSignaturePolicyRule(ctx context.Context, sel ast.SelectionSet, v []*models.SignaturePolicyRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSignaturePolicyRule2githubcomkfsoftwarehlfoperatoruiapigqlmodelsSignaturePolicyRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOSignaturePolicySignedBy2githubcomkfsoftwarehlfoperatoruiapigqlmodelsSignaturePolicySignedBy(ctx context.Context, sel ast.SelectionSet, v *models.SignaturePolicySignedBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SignaturePolicySignedBy(ctx, sel, v)
}

func (ec *executionContext) marshalOStorageClass2githubcomkfsoftwarehlfoperatoruiapigqlmodelsStorageClass(ctx context.Context, sel ast.SelectionSet, v []*models.StorageClass) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStorageClass2githubcomkfsoftwarehlfoperatoruiapigqlmodelsStorageClass(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOStorageUsage2githubcomkfsoftwarehlfoperatoruiapigqlmodelsStorageUsage(ctx context.Context, sel ast.SelectionSet, v *models.StorageUsage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StorageUsage(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTransaction2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransaction(ctx context.Context, sel ast.SelectionSet, v []*models.Transaction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransaction2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTransactionRead2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionRead(ctx context.Context, sel ast.SelectionSet, v []*models.TransactionRead) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionRead2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionRead(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTransactionWithPrivateData2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionWithPrivateData(ctx context.Context, sel ast.SelectionSet, v []*models.TransactionWithPrivateData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionWithPrivateData2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionWithPrivateData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTransactionWrite2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionWrite(ctx context.Context, sel ast.SelectionSet, v []*models.TransactionWrite) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionWrite2githubcomkfsoftwarehlfoperatoruiapigqlmodelsTransactionWrite(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
